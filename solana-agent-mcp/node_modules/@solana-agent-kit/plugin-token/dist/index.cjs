"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => index_default
});
module.exports = __toCommonJS(index_exports);

// src/dexscreener/actions/getTokenData.ts
var import_web32 = require("@solana/web3.js");
var import_zod = require("zod");

// src/dexscreener/tools/get_token_data.ts
var import_web3 = require("@solana/web3.js");
async function getTokenDataByAddress(mint) {
  try {
    if (!mint) {
      throw new Error("Mint address is required");
    }
    const response = await fetch(`https://tokens.jup.ag/token/${mint}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    const token = await response.json();
    return token;
  } catch (error) {
    throw new Error(`Error fetching token data: ${error.message}`);
  }
}
async function getTokenAddressFromTicker(ticker) {
  try {
    const response = await fetch(
      `https://api.dexscreener.com/latest/dex/search?q=${ticker}`
    );
    const data = await response.json();
    if (!data.pairs || data.pairs.length === 0) {
      return null;
    }
    let solanaPairs = data.pairs.filter((pair) => pair.chainId === "solana").sort((a, b) => (b.fdv || 0) - (a.fdv || 0));
    solanaPairs = solanaPairs.filter(
      (pair) => pair.baseToken.symbol.toLowerCase() === ticker.toLowerCase()
    );
    return solanaPairs[0].baseToken.address;
  } catch (error) {
    console.error("Error fetching token address from DexScreener:", error);
    return null;
  }
}

// src/dexscreener/actions/getTokenData.ts
var getTokenDataAction = {
  name: "GET_TOKEN_DATA",
  similes: [
    "get token info",
    "token details",
    "lookup token",
    "find token",
    "token data"
  ],
  description: "Get token data from either a token address or ticker symbol",
  examples: [
    [
      {
        input: {
          address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        output: {
          status: "success",
          token: {
            name: "USD Coin",
            symbol: "USDC",
            address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            decimals: 6
          }
        },
        explanation: "Get token data using the token's address"
      }
    ],
    [
      {
        input: {
          ticker: "SOL"
        },
        output: {
          status: "success",
          token: {
            name: "Wrapped SOL",
            symbol: "SOL",
            address: "So11111111111111111111111111111111111111112",
            decimals: 9
          }
        },
        explanation: "Get token data using the token's ticker symbol"
      }
    ]
  ],
  schema: import_zod.z.object({
    address: import_zod.z.string().optional().describe("The token's mint address"),
    ticker: import_zod.z.string().optional().describe("The token's ticker symbol")
  }),
  handler: async (_agent, input) => {
    try {
      let tokenData;
      if (input.address) {
        tokenData = await getTokenDataByAddress(new import_web32.PublicKey(input.address));
      } else if (input.ticker) {
        const address = await getTokenAddressFromTicker(input.ticker);
        if (address) {
          tokenData = await getTokenDataByAddress(new import_web32.PublicKey(address));
        }
      }
      if (!tokenData) {
        return {
          status: "error",
          message: "Token not found or not verified"
        };
      }
      return {
        status: "success",
        token: {
          name: tokenData.name,
          symbol: tokenData.symbol,
          address: tokenData.address,
          decimals: tokenData.decimals,
          logoURI: tokenData.logoURI
        }
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to get token data: ${error.message}`
      };
    }
  }
};
var getTokenData_default = getTokenDataAction;

// src/jupiter/actions/cancelLimitOrders.ts
var import_zod2 = require("zod");

// src/jupiter/tools/cancel_limit_orders.ts
var import_solana_agent_kit = require("solana-agent-kit");

// src/jupiter/tools/common/jupiterLimitApi.ts
var import_redaxios = __toESM(require("redaxios"), 1);
var jupiterApi = import_redaxios.default.create({
  baseURL: "https://api.jup.ag/limit/v2",
  headers: {
    "Content-Type": "application/json"
  }
});
async function handleApiRequest(apiCall) {
  try {
    const { data } = await apiCall();
    return data;
  } catch (error) {
    throw new Error(
      `Jupiter API error: ${// @ts-expect-error - Redaxios error type mismatch
      error.message}`
    );
  }
}
async function createOrderApi(data) {
  return handleApiRequest(
    async () => jupiterApi.post("/createOrder", data)
  );
}
async function getOpenOrdersApi(walletAddress) {
  return handleApiRequest(
    async () => jupiterApi.get("/openOrders", {
      params: { wallet: walletAddress }
    })
  );
}
async function cancelOrdersApi(data) {
  return handleApiRequest(
    async () => jupiterApi.post("/cancelOrders", data)
  );
}
async function getOrderHistoryApi(walletAddress, page = 1) {
  return handleApiRequest(
    async () => jupiterApi.get("/orderHistory", {
      params: {
        wallet: walletAddress,
        page
      }
    })
  );
}

// src/jupiter/tools/common/transactions.ts
var import_web33 = require("@solana/web3.js");
function deserializeTransaction(txBase64) {
  return import_web33.VersionedTransaction.deserialize(Buffer.from(txBase64, "base64"));
}

// src/jupiter/tools/cancel_limit_orders.ts
async function cancelLimitOrders(agent, params) {
  params.maker = agent.wallet.publicKey.toString();
  try {
    const data = await cancelOrdersApi(params);
    const transactions = data.txs.map(
      (tx) => deserializeTransaction(tx)
    );
    const signatures = await (0, import_solana_agent_kit.signOrSendTX)(agent, transactions);
    return {
      signatures,
      success: true
    };
  } catch (error) {
    console.error(error);
    throw new Error(`Error canceling limit orders: ${error}`);
  }
}

// src/jupiter/actions/cancelLimitOrders.ts
var cancelOrdersSchema = import_zod2.z.object({
  orders: import_zod2.z.array(import_zod2.z.string()).describe("The order public keys to cancel")
});
var cancelOrdersAction = {
  name: "CANCEL_LIMIT_ORDERS",
  similes: [
    "abort orders",
    "cancel limit order",
    "revoke orders",
    "terminate orders"
  ],
  description: "Cancels specified orders on the Solana blockchain.",
  examples: [
    [
      {
        input: {
          orders: ["GgMvwcfMz...ienihZvTmyBZYM", "HhNvwcfMz...Qa8ihZvTmyBZYN"]
        },
        output: {
          signatures: ["5K3N9...3J4", "6L4O0...4K5"],
          success: true,
          explanation: "Orders canceled successfully."
        },
        explanation: "Successfully canceled the specified orders."
      },
      {
        input: {
          orders: ["InvalidOrderKey"]
        },
        output: {
          signatures: [],
          success: false,
          error: "Error canceling orders: Invalid order key",
          explanation: "Failed to cancel orders due to invalid order key."
        },
        explanation: "Failed to cancel orders due to an invalid order key."
      }
    ]
  ],
  schema: cancelOrdersSchema,
  handler: async (agent, input) => {
    const params = cancelOrdersSchema.parse(input);
    try {
      const result = await cancelLimitOrders(agent, params);
      return {
        status: "success",
        result,
        message: "Orders canceled successfully."
      };
    } catch (error) {
      const errorMessage = `Error canceling orders: ${error}`;
      console.error(errorMessage);
      return {
        status: "error",
        message: errorMessage
      };
    }
  }
};
var cancelLimitOrders_default = cancelOrdersAction;

// src/jupiter/actions/createLimitOrder.ts
var import_zod3 = require("zod");

// src/jupiter/tools/create_limit_order.ts
var import_solana_agent_kit2 = require("solana-agent-kit");
async function createLimitOrder(agent, params) {
  const wallet = agent.wallet.publicKey.toString();
  params.maker = params.payer = wallet;
  try {
    const data = await createOrderApi(params);
    const transaction = deserializeTransaction(data.tx);
    const signature = await (0, import_solana_agent_kit2.signOrSendTX)(agent, transaction);
    return {
      signature,
      order: data.order,
      success: true
    };
  } catch (error) {
    console.error(error);
    throw new Error(`Error creating limit order: ${error}`);
  }
}

// src/jupiter/actions/createLimitOrder.ts
var createLimitOrderSchema = import_zod3.z.object({
  inputMint: import_zod3.z.string(),
  outputMint: import_zod3.z.string(),
  params: import_zod3.z.object({
    makingAmount: import_zod3.z.string(),
    takingAmount: import_zod3.z.string(),
    expiredAt: import_zod3.z.string().optional()
  })
});
var createLimitOrderAction = {
  name: "CREATE_LIMIT_ORDER",
  similes: ["place limit order", "submit limit order", "create trading order"],
  description: "Creates and sends a limit order on the Solana blockchain.",
  examples: [
    [
      {
        input: {
          inputAmount: "5500000",
          outputAmount: "50000000"
        },
        output: {
          signature: "5K3N9...3J4",
          order: "order123",
          success: true,
          explanation: "Order created and sent successfully."
        },
        explanation: "Successfully created a limit order with specified amounts."
      },
      {
        input: {
          inputAmount: "1000000",
          outputAmount: "20000000"
        },
        output: {
          signature: "",
          order: "",
          success: false,
          error: "Error creating and sending limit order: Network error",
          explanation: "Failed to create and send the order."
        },
        explanation: "Failed to create a limit order due to a network error."
      }
    ]
  ],
  schema: createLimitOrderSchema,
  handler: async (agent, input) => {
    const params = createLimitOrderSchema.parse(input);
    try {
      const result = await createLimitOrder(agent, params);
      return {
        status: "success",
        result,
        message: "Order created and sent successfully."
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to create limit order: ${error}`
      };
    }
  }
};
var createLimitOrder_default = createLimitOrderAction;

// src/jupiter/actions/fetchPrice.ts
var import_web37 = require("@solana/web3.js");
var import_zod4 = require("zod");

// src/jupiter/tools/fetch_price.ts
async function fetchPrice(tokenId) {
  try {
    const response = await fetch(
      `https://api.jup.ag/price/v2?ids=${tokenId.toBase58()}`
    );
    if (!response.ok) {
      throw new Error(`Failed to fetch price: ${response.statusText}`);
    }
    const data = await response.json();
    const price = data.data[tokenId.toBase58()]?.price;
    if (!price) {
      throw new Error("Price data not available for the given token.");
    }
    return price;
  } catch (error) {
    throw new Error(`Price fetch failed: ${error.message}`);
  }
}

// src/jupiter/tools/stake_with_jup.ts
var import_web34 = require("@solana/web3.js");
var import_solana_agent_kit3 = require("solana-agent-kit");
async function stakeWithJup(agent, amount) {
  try {
    const res = await fetch(
      `https://worker.jup.ag/blinks/swap/So11111111111111111111111111111111111111112/jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v/${amount}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          account: agent.wallet.publicKey.toBase58()
        })
      }
    );
    const data = await res.json();
    const txn = import_web34.VersionedTransaction.deserialize(
      Buffer.from(data.transaction, "base64")
    );
    const { blockhash } = await agent.connection.getLatestBlockhash();
    txn.message.recentBlockhash = blockhash;
    return await (0, import_solana_agent_kit3.signOrSendTX)(agent, txn);
  } catch (error) {
    console.error(error);
    throw new Error(`jupSOL staking failed: ${error.message}`);
  }
}

// src/jupiter/tools/trade.ts
var import_spl_token = require("@solana/spl-token");
var import_web36 = require("@solana/web3.js");
var import_solana_agent_kit4 = require("solana-agent-kit");

// src/jupiter/tools/utils/constants.ts
var import_web35 = require("@solana/web3.js");
var TOKENS = {
  SEND: new import_web35.PublicKey("SENDdRQtYMWaQrBroBrJ2Q53fgVuq95CV9UPGEvpCxa"),
  USDC: new import_web35.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),
  SOL: new import_web35.PublicKey("So11111111111111111111111111111111111111112")
};
var DEFAULT_OPTIONS = {
  SLIPPAGE_BPS: 300,
  TOKEN_DECIMALS: 9,
  RERERRAL_FEE: 200,
  LEVERAGE_BPS: 5e4
  // 10000 = x1, 50000 = x5, 100000 = x10, 1000000 = x100
};
var JUP_API = "https://quote-api.jup.ag/v6";
var JUP_REFERRAL_ADDRESS = "REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3";
var METEORA_DYNAMIC_AMM_PROGRAM_ID = new import_web35.PublicKey(
  "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
);
var METEORA_DLMM_PROGRAM_ID = new import_web35.PublicKey(
  "LbVRzDTvBDEcrthxfZ4RL6yiq3uZw8bS6MwtdY6UhFQ"
);

// src/jupiter/tools/trade.ts
async function trade(agent, outputMint, inputAmount, inputMint = TOKENS.USDC, _slippageBps = DEFAULT_OPTIONS.SLIPPAGE_BPS) {
  try {
    const isNativeSol = inputMint.equals(TOKENS.SOL);
    const inputDecimals = isNativeSol ? 9 : (await (0, import_spl_token.getMint)(agent.connection, inputMint)).decimals;
    const scaledAmount = inputAmount * Math.pow(10, inputDecimals);
    const quoteResponse = await (await fetch(
      `${JUP_API}/quote?inputMint=${isNativeSol ? TOKENS.SOL.toString() : inputMint.toString()}&outputMint=${outputMint.toString()}&amount=${scaledAmount}&dynamicSlippage=true&minimizeSlippage=false&onlyDirectRoutes=false&maxAccounts=64&swapMode=ExactIn${agent.config?.JUPITER_FEE_BPS ? `&platformFeeBps=${agent.config?.JUPITER_FEE_BPS}` : ""}`
    )).json();
    let feeAccount;
    if (agent.config?.JUPITER_REFERRAL_ACCOUNT) {
      [feeAccount] = import_web36.PublicKey.findProgramAddressSync(
        [
          Buffer.from("referral_ata"),
          new import_web36.PublicKey(agent.config?.JUPITER_REFERRAL_ACCOUNT).toBuffer(),
          TOKENS.SOL.toBuffer()
        ],
        new import_web36.PublicKey(JUP_REFERRAL_ADDRESS)
      );
    }
    const { swapTransaction } = await (await fetch("https://quote-api.jup.ag/v6/swap", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        quoteResponse,
        userPublicKey: agent.wallet.publicKey.toString(),
        wrapAndUnwrapSol: true,
        dynamicComputeUnitLimit: true,
        dynamicSlippage: true,
        prioritizationFeeLamports: {
          priorityLevelWithMaxLamports: {
            maxLamports: 1e7,
            global: false,
            priorityLevel: agent.config?.PRIORITY_LEVEL || "medium"
          }
        },
        feeAccount: feeAccount ? feeAccount.toString() : null
      })
    })).json();
    const swapTransactionBuf = Buffer.from(swapTransaction, "base64");
    const transaction = import_web36.VersionedTransaction.deserialize(swapTransactionBuf);
    const { blockhash } = await agent.connection.getLatestBlockhash();
    transaction.message.recentBlockhash = blockhash;
    return await (0, import_solana_agent_kit4.signOrSendTX)(agent, transaction);
  } catch (error) {
    throw new Error(`Swap failed: ${error.message}`);
  }
}

// src/jupiter/tools/get_open_limit_orders.ts
async function getOpenLimitOrders(agent) {
  try {
    const orders = await getOpenOrdersApi(agent.wallet.publicKey.toString());
    return { orders, success: true };
  } catch (error) {
    console.error(error);
    throw new Error(`Error fetching open orders: ${error}`);
  }
}

// src/jupiter/tools/get_limit_order_history.ts
async function getLimitOrderHistory(agent) {
  try {
    const history = await getOrderHistoryApi(agent.wallet.publicKey.toString());
    return { history, success: true };
  } catch (error) {
    console.error(error);
    throw new Error(`Error fetching order history: ${error}`);
  }
}

// src/jupiter/tools/get_token_by_ticker.ts
async function getTokenByTicker(ticker) {
  try {
    const response = await fetch(
      "https://api.jup.ag/tokens/v1/tagged/verified"
    );
    if (!response.ok) {
      throw new Error(`Failed to fetch price: ${response.statusText}`);
    }
    const data = await response.json();
    const tokenData = data.toSorted((a, b) => (b.daily_volume ?? 0) - (a.daily_volume ?? 0)).find(
      (token) => token.symbol.toLowerCase() === ticker.toLowerCase()
    );
    if (!tokenData) {
      throw new Error("Token data not available for the given ticker.");
    }
    return tokenData;
  } catch (e) {
    throw new Error(`Token fetch failed: ${e.message}`);
  }
}

// src/jupiter/actions/fetchPrice.ts
var fetchPriceAction = {
  name: "FETCH_PRICE",
  similes: [
    "get token price",
    "check price",
    "token value",
    "price check",
    "get price in usd"
  ],
  description: "Fetch the current price of a Solana token in USDC using Jupiter API",
  examples: [
    [
      {
        input: {
          tokenAddress: "So11111111111111111111111111111111111111112"
        },
        output: {
          status: "success",
          price: "23.45",
          message: "Current price: $23.45 USDC"
        },
        explanation: "Get the current price of SOL token in USDC"
      }
    ]
  ],
  schema: import_zod4.z.object({
    tokenAddress: import_zod4.z.string().describe("The mint address of the token to fetch the price for")
  }),
  handler: async (_agent, input) => {
    try {
      const tokenId = new import_web37.PublicKey(input.tokenAddress);
      const price = await fetchPrice(tokenId);
      return {
        status: "success",
        price,
        message: `Current price: $${price} USDC`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to fetch price: ${error.message}`
      };
    }
  }
};
var fetchPrice_default = fetchPriceAction;

// src/jupiter/actions/getLimitOrderHistory.ts
var import_zod5 = require("zod");
var getLimitOrderHistoryAction = {
  name: "GET_LIMIT_ORDER_HISTORY",
  similes: [
    "fetch order history",
    "get limit order history",
    "retrieve order history",
    "get past orders"
  ],
  description: "Fetches the limit order history for a given wallet.",
  examples: [
    [
      {
        input: {
          walletPublicKey: "CmwPTro4ogHPhuG9Dozx1X7KiATNudF1rkem3BQmuPn7",
          page: 1
        },
        output: {
          history: {
            orders: [
              {
                userPubkey: "CmwPTro4ogHPhuG9Dozx1X7KiATNudF1rkem3BQmuPn7",
                orderKey: "GgMvwcfMzP9AmfwZuMzNienXGBhQa8dksihZvTmyBZYM",
                inputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
                outputMint: "So11111111111111111111111111111111111111112",
                makingAmount: "10000000",
                takingAmount: "50000000",
                remainingMakingAmount: "50000000",
                remainingTakingAmount: "10000000",
                expiredAt: null,
                createdAt: "2023-10-01T00:00:00Z",
                updatedAt: "2023-10-02T00:00:00Z",
                status: "Open",
                openTx: "https://solscan.io/tx/2431GhdanFFwWg...77BBCSk34SW2iFHwu17zQARjr",
                closeTx: "",
                programVersion: "1.0",
                trades: [
                  {
                    amount: "10000000",
                    price: "50000000",
                    timestamp: "2023-10-01T01:00:00Z"
                  }
                ]
              }
            ],
            hasMoreData: false,
            page: 1
          },
          success: true
        },
        explanation: "Successfully fetched order history for the given wallet."
      }
    ]
  ],
  schema: import_zod5.z.object({}),
  handler: async (agent) => {
    try {
      const history = await getLimitOrderHistory(agent);
      return {
        status: "success",
        result: { history, success: true },
        message: "Successfully fetched order history for the given wallet."
      };
    } catch (error) {
      const errorMessage = `Error fetching order history: ${error}`;
      console.error(errorMessage);
      return {
        status: "error",
        message: errorMessage,
        result: { history: [], success: false }
      };
    }
  }
};
var getLimitOrderHistory_default = getLimitOrderHistoryAction;

// src/jupiter/actions/getOpenLimitOrders.ts
var import_zod6 = require("zod");
var getOpenLimitOrdersAction = {
  name: "GET_OPEN_LIMIT_ORDERS",
  similes: ["fetch open orders", "get limit orders", "retrieve open orders"],
  description: "Fetches the open limit orders for a given wallet.",
  examples: [
    [
      {
        input: {
          walletPublicKey: "CmwPTro4ogHP...muPn7"
        },
        output: {
          orders: [
            {
              userPubkey: "CmwPTro4ogHP...muPn7",
              orderKey: "GgMvwcfM...vTmyBZYM",
              inputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
              outputMint: "So11111111111111111111111111111111111111112",
              makingAmount: "10000000",
              takingAmount: "50000000",
              remainingMakingAmount: "50000000",
              remainingTakingAmount: "10000000",
              expiredAt: null,
              createdAt: "2023-10-01T00:00:00Z",
              updatedAt: "2023-10-02T00:00:00Z",
              status: "Open",
              openTx: "https://solscan.io/tx/2431GhdanFFwWg...77BBCSk34SW2iFHwu17zQARjr",
              closeTx: "",
              programVersion: "1.0",
              trades: [
                {
                  amount: "10000000",
                  price: "50000000",
                  timestamp: "2023-10-01T01:00:00Z"
                }
              ]
            }
          ],
          success: true
        },
        explanation: "Successfully fetched open orders for the given wallet."
      }
    ]
  ],
  schema: import_zod6.z.object({}),
  handler: async (agent) => {
    try {
      const orders = await getOpenLimitOrders(agent);
      return {
        status: "success",
        result: { orders, success: true },
        message: "Successfully fetched open orders for the given wallet."
      };
    } catch (error) {
      const errorMessage = `Error fetching open orders: ${error}`;
      console.error(errorMessage);
      return {
        status: "error",
        message: errorMessage,
        result: { orders: [], success: false }
      };
    }
  }
};
var getOpenLimitOrders_default = getOpenLimitOrdersAction;

// src/jupiter/actions/getTokenDataByTicker.ts
var import_zod7 = require("zod");
var tokenDataByTickerAction = {
  name: "GET_TOKEN_DATA_OR_INFO_BY_TICKER_OR_SYMBOL",
  similes: [
    "token data by symbol",
    "fetch token info by symbol",
    "lookup token ticker info",
    "get token info by ticker"
  ],
  description: "Get the token data for a given token ticker or symbol",
  examples: [
    [
      {
        input: {
          ticker: "USDC"
        },
        output: {
          status: "success",
          tokenData: {
            symbol: "USDC",
            name: "USD Coin",
            decimals: 6,
            mintAddress: "FhRg..."
          }
        },
        explanation: "Fetches metadata for the USDC token by its ticker."
      }
    ]
  ],
  schema: import_zod7.z.object({
    ticker: import_zod7.z.string().min(1).describe("Ticker of the token, e.g. 'USDC'")
  }),
  handler: async (_agent, input) => {
    try {
      const ticker = input.ticker;
      const tokenData = await getTokenByTicker(ticker);
      return {
        status: "success",
        tokenData,
        message: `Successfully fetched token data for ticker: ${ticker}`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to fetch token data for ticker: ${input.ticker || ""}. ${error.message}`,
        code: error.code || "UNKNOWN_ERROR"
      };
    }
  }
};
var getTokenDataByTicker_default = tokenDataByTickerAction;

// src/jupiter/actions/stakeWithJup.ts
var import_zod8 = require("zod");
var stakeWithJupAction = {
  name: "STAKE_WITH_JUPITER",
  similes: [
    "stake sol",
    "stake with jupiter",
    "jup staking",
    "stake with jup",
    "liquid staking",
    "get jupsol"
  ],
  description: "Stake SOL tokens with Jupiter's liquid staking protocol to receive jupSOL",
  examples: [
    [
      {
        input: {
          amount: 1.5
        },
        output: {
          status: "success",
          signature: "5KtPn3...",
          message: "Successfully staked 1.5 SOL for jupSOL"
        },
        explanation: "Stake 1.5 SOL to receive jupSOL tokens"
      }
    ]
  ],
  schema: import_zod8.z.object({
    amount: import_zod8.z.number().positive().describe("Amount of SOL to stake")
  }),
  handler: async (agent, input) => {
    try {
      const amount = input.amount;
      const res = await stakeWithJup(agent, amount);
      return {
        status: "success",
        transaction: res,
        message: `Successfully staked ${amount} SOL for jupSOL`
      };
    } catch (error) {
      return {
        status: "error",
        message: `jupSOL staking failed: ${error.message}`
      };
    }
  }
};
var stakeWithJup_default = stakeWithJupAction;

// src/jupiter/actions/trade.ts
var import_web38 = require("@solana/web3.js");
var import_zod9 = require("zod");
var tradeAction = {
  name: "TRADE",
  similes: [
    "swap tokens",
    "exchange tokens",
    "trade tokens",
    "convert tokens",
    "swap sol"
  ],
  description: `This tool can be used to swap tokens to another token (It uses Jupiter Exchange).`,
  examples: [
    [
      {
        input: {
          outputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
          inputAmount: 1
        },
        output: {
          status: "success",
          message: "Trade executed successfully",
          transaction: "5UfgJ5vVZxUxefDGqzqkVLHzHxVTyYH9StYyHKgvHYmXJgqJKxEqy9k4Rz9LpXrHF9kUZB7",
          inputAmount: 1,
          inputToken: "SOL",
          outputToken: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        explanation: "Swap 1 SOL for USDC"
      }
    ],
    [
      {
        input: {
          outputMint: "So11111111111111111111111111111111111111112",
          inputAmount: 100,
          inputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
          slippageBps: 100
        },
        output: {
          status: "success",
          message: "Trade executed successfully",
          transaction: "4VfgJ5vVZxUxefDGqzqkVLHzHxVTyYH9StYyHKgvHYmXJgqJKxEqy9k4Rz9LpXrHF9kUZB7",
          inputAmount: 100,
          inputToken: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
          outputToken: "So11111111111111111111111111111111111111112"
        },
        explanation: "Swap 100 USDC for SOL with 1% slippage"
      }
    ]
  ],
  schema: import_zod9.z.object({
    outputMint: import_zod9.z.string().min(32, "Invalid output mint address"),
    inputAmount: import_zod9.z.number().positive("Input amount must be positive"),
    inputMint: import_zod9.z.string().min(32, "Invalid input mint address").optional(),
    slippageBps: import_zod9.z.number().min(0).max(1e4).optional()
  }),
  handler: async (agent, input) => {
    const tx = await trade(
      agent,
      new import_web38.PublicKey(input.outputMint),
      input.inputAmount,
      input.inputMint ? new import_web38.PublicKey(input.inputMint) : new import_web38.PublicKey("So11111111111111111111111111111111111111112"),
      input.slippageBps
    );
    return {
      status: "success",
      message: "Trade executed successfully",
      transaction: tx,
      inputAmount: input.inputAmount,
      inputToken: input.inputMint || "SOL",
      outputToken: input.outputMint
    };
  }
};
var trade_default = tradeAction;

// src/lightprotocol/actions/compressedAirdrop.ts
var import_zod10 = require("zod");

// src/lightprotocol/tools/send_compressed_airdrop.ts
var import_compressed_token = require("@lightprotocol/compressed-token");
var import_stateless = require("@lightprotocol/stateless.js");
var import_spl_token2 = require("@solana/spl-token");
var import_web39 = require("@solana/web3.js");
var import_solana_agent_kit5 = require("solana-agent-kit");
var MAX_AIRDROP_RECIPIENTS = 1e3;
async function sendCompressedAirdrop(agent, mintAddress, amount, decimals, recipients, priorityFeeInLamports) {
  const setupTransaction = new import_web39.Transaction();
  if (recipients.length > MAX_AIRDROP_RECIPIENTS) {
    throw new Error(
      `Max airdrop can be ${MAX_AIRDROP_RECIPIENTS} recipients at a time. For more scale, use open source ZK Compression airdrop tools such as https://github.com/helius-labs/airship.`
    );
  }
  const url = agent.connection.rpcEndpoint;
  if (url.includes("devnet")) {
    throw new Error("Devnet is not supported for airdrop. Please use mainnet.");
  }
  if (!url.includes("helius")) {
    console.warn(
      "Warning: Must use RPC with ZK Compression support. Double check with your RPC provider if in doubt."
    );
  }
  try {
    await (0, import_spl_token2.getAssociatedTokenAddress)(mintAddress, agent.wallet.publicKey);
  } catch (_error) {
    const associatedToken = (0, import_spl_token2.getAssociatedTokenAddressSync)(
      mintAddress,
      agent.wallet.publicKey
    );
    setupTransaction.add(
      (0, import_spl_token2.createAssociatedTokenAccountInstruction)(
        agent.wallet.publicKey,
        associatedToken,
        agent.wallet.publicKey,
        mintAddress
      )
    );
  }
  try {
    const createTokenPoolInstruction = await import_compressed_token.CompressedTokenProgram.createTokenPool({
      mint: mintAddress,
      feePayer: agent.wallet.publicKey
    });
    setupTransaction.add(createTokenPoolInstruction);
  } catch (error) {
    if (error.message.includes("already in use")) {
    } else {
      throw error;
    }
  }
  return await processAll(
    agent,
    amount * 10 ** decimals,
    mintAddress,
    recipients,
    priorityFeeInLamports,
    setupTransaction
  );
}
async function processAll(agent, amount, mint, recipients, priorityFeeInLamports, setupTransaction) {
  const mintAddress = mint;
  const transaction = import_web39.Transaction.from(setupTransaction.serialize());
  transaction.add(
    import_web39.ComputeBudgetProgram.setComputeUnitLimit({ units: 5e5 }),
    import_web39.ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: (0, import_stateless.calculateComputeUnitPrice)(priorityFeeInLamports, 5e5)
    })
  );
  const sourceTokenAccount = (0, import_spl_token2.getAssociatedTokenAddressSync)(
    mint,
    agent.wallet.publicKey
  );
  const maxRecipientsPerInstruction = 5;
  const maxIxs = 3;
  const lookupTableAddress = new import_web39.PublicKey(
    "9NYFyEqPkyXUhkerbGHXUXkvb4qpzeEdHuGpgbgpH1NJ"
  );
  const lookupTableAccount = (await agent.connection.getAddressLookupTable(lookupTableAddress)).value;
  const batches = [];
  for (let i = 0; i < recipients.length; i += maxRecipientsPerInstruction * maxIxs) {
    batches.push(recipients.slice(i, i + maxRecipientsPerInstruction * maxIxs));
  }
  const compressInstructionSet = await Promise.all(
    batches.map(async (recipientBatch) => {
      const compressIxPromises = [];
      for (let i = 0; i < recipientBatch.length; i += maxRecipientsPerInstruction) {
        const batch = recipientBatch.slice(i, i + maxRecipientsPerInstruction);
        compressIxPromises.push(
          import_compressed_token.CompressedTokenProgram.compress({
            payer: agent.wallet.publicKey,
            owner: agent.wallet.publicKey,
            source: sourceTokenAccount,
            toAddress: batch,
            amount: batch.map(() => amount),
            mint: mintAddress
          })
        );
      }
      const compressIxs = await Promise.all(compressIxPromises);
      return compressIxs;
    })
  );
  transaction.add(...compressInstructionSet.flat());
  const { blockhash } = await agent.connection.getLatestBlockhash();
  const tx = (0, import_stateless.buildTx)(
    transaction.instructions,
    agent.wallet.publicKey,
    blockhash,
    [lookupTableAccount]
  );
  return await (0, import_solana_agent_kit5.signOrSendTX)(agent, tx);
}

// src/lightprotocol/actions/compressedAirdrop.ts
var compressedAirdropAction = {
  name: "COMPRESSED_AIRDROP",
  similes: [
    "ZK Compressed airdrop",
    "Airdrop tokens with compression",
    "Send compressed SPL airdrop",
    "Airdrop to multiple recipients"
  ],
  description: "Airdrop SPL tokens with ZK Compression (also known as airdropping tokens) to multiple recipients",
  examples: [
    [
      {
        input: {
          mintAddress: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
          amount: 42,
          decimals: 6,
          recipients: [
            "1nc1nerator11111111111111111111111111111111",
            "BrFndAe111111111111111111111111111111111"
          ],
          priorityFeeInLamports: 3e4,
          shouldLog: true
        },
        output: {
          status: "success",
          message: "Airdropped 42 tokens to 2 recipients.",
          transactionHashes: ["4uyfBN...", "9XsF2N..."]
        },
        explanation: "Airdrops 42 tokens (with 6 decimals) to 2 recipients, optionally logging progress to stdout."
      }
    ]
  ],
  // Validate inputs with zod
  schema: import_zod10.z.object({
    mintAddress: import_zod10.z.string().min(1).describe("Mint address of the token, e.g., 'JUPy...'"),
    amount: import_zod10.z.number().positive().describe("Number of tokens to airdrop per recipient, e.g., 42"),
    decimals: import_zod10.z.number().nonnegative().int().describe("Decimals of the token, e.g., 6"),
    recipients: import_zod10.z.array(import_zod10.z.string()).nonempty().describe("Array of recipient addresses, e.g., ['1nc1n...']"),
    priorityFeeInLamports: import_zod10.z.number().optional().describe("Priority fee in lamports (default is 30_000)"),
    shouldLog: import_zod10.z.boolean().optional().describe("Whether to log progress to stdout (default is false)")
  }),
  handler: async (_agent, input) => {
    try {
      const {
        mintAddress,
        amount,
        decimals,
        recipients,
        priorityFeeInLamports,
        shouldLog
      } = input;
      const txs = await sendCompressedAirdrop(
        mintAddress,
        amount,
        decimals,
        recipients,
        priorityFeeInLamports || 3e4,
        shouldLog || false
      );
      return {
        status: "success",
        message: `Airdropped ${amount} tokens to ${recipients.length} recipients.`,
        transactions: txs
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to airdrop tokens: ${error.message}`,
        code: error.code || "UNKNOWN_ERROR"
      };
    }
  }
};
var compressedAirdrop_default = compressedAirdropAction;

// src/solana/actions/balance.ts
var import_web318 = require("@solana/web3.js");
var import_zod11 = require("zod");

// src/solana/tools/get_tps.ts
async function getTPS(agent) {
  const perfSamples = await agent.connection.getRecentPerformanceSamples();
  if (!perfSamples.length || !perfSamples[0]?.numTransactions || !perfSamples[0]?.samplePeriodSecs) {
    throw new Error("No performance samples available");
  }
  const tps = perfSamples[0].numTransactions / perfSamples[0].samplePeriodSecs;
  return tps;
}

// src/solana/tools/request_faucet_funds.ts
var import_web310 = require("@solana/web3.js");
async function request_faucet_funds(agent) {
  const tx = await agent.connection.requestAirdrop(
    agent.wallet.publicKey,
    5 * import_web310.LAMPORTS_PER_SOL
  );
  const latestBlockHash = await agent.connection.getLatestBlockhash();
  await agent.connection.confirmTransaction({
    signature: tx,
    blockhash: latestBlockHash.blockhash,
    lastValidBlockHeight: latestBlockHash.lastValidBlockHeight
  });
  return tx;
}

// src/solana/tools/close_empty_token_accounts.ts
var import_spl_token3 = require("@solana/spl-token");
var import_web311 = require("@solana/web3.js");
var import_solana_agent_kit6 = require("solana-agent-kit");
async function closeEmptyTokenAccounts(agent) {
  try {
    const spl_token = await create_close_instruction(agent, import_spl_token3.TOKEN_PROGRAM_ID);
    const token_2022 = await create_close_instruction(
      agent,
      import_spl_token3.TOKEN_2022_PROGRAM_ID
    );
    const transaction = new import_web311.Transaction();
    const MAX_INSTRUCTIONS = 40;
    for (let i = 0; i < Math.min(MAX_INSTRUCTIONS, spl_token.length); i++) {
      transaction.add(spl_token[i]);
    }
    for (let i = 0; i < Math.max(0, MAX_INSTRUCTIONS - spl_token.length); i++) {
      transaction.add(token_2022[i]);
    }
    const size = spl_token.length + token_2022.length;
    if (size === 0) {
      return {
        signature: "",
        size: 0
      };
    }
    if (agent.config.signOnly) {
      return {
        signedTransaction: await (0, import_solana_agent_kit6.signOrSendTX)(
          agent,
          transaction
        ),
        size
      };
    }
    const { blockhash } = await agent.connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    const signature = await (0, import_solana_agent_kit6.signOrSendTX)(agent, transaction);
    return { signature, size };
  } catch (error) {
    throw new Error(`Error closing empty token accounts: ${error}`);
  }
}
async function create_close_instruction(agent, token_program) {
  const instructions = [];
  const ata_accounts = await agent.connection.getTokenAccountsByOwner(
    agent.wallet.publicKey,
    { programId: token_program },
    "confirmed"
  );
  const tokens = ata_accounts.value;
  const accountExceptions = [
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    // USDC
  ];
  for (let i = 0; i < tokens.length; i++) {
    const token_data = import_spl_token3.AccountLayout.decode(tokens[i].account.data);
    if (token_data.amount === BigInt(0) && !accountExceptions.includes(token_data.mint.toString())) {
      const closeInstruction = (0, import_spl_token3.createCloseAccountInstruction)(
        ata_accounts.value[i].pubkey,
        agent.wallet.publicKey,
        agent.wallet.publicKey,
        [],
        token_program
      );
      instructions.push(closeInstruction);
    }
  }
  return instructions;
}

// src/solana/tools/transfer.ts
var import_spl_token4 = require("@solana/spl-token");
var import_web312 = require("@solana/web3.js");
var import_web313 = require("@solana/web3.js");
var import_solana_agent_kit7 = require("solana-agent-kit");
async function transfer(agent, to, amount, mint) {
  try {
    let tx;
    if (!mint) {
      const transaction = new import_web312.Transaction().add(
        import_web312.SystemProgram.transfer({
          fromPubkey: agent.wallet.publicKey,
          toPubkey: to,
          lamports: amount * import_web313.LAMPORTS_PER_SOL
        })
      );
      const { blockhash } = await agent.connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      tx = await (0, import_solana_agent_kit7.signOrSendTX)(agent, transaction.instructions);
    } else {
      const transaction = new import_web312.Transaction();
      const fromAta = await (0, import_spl_token4.getAssociatedTokenAddress)(
        mint,
        agent.wallet.publicKey
      );
      const toAta = await (0, import_spl_token4.getAssociatedTokenAddress)(mint, to);
      try {
        await (0, import_spl_token4.getAccount)(agent.connection, toAta);
      } catch {
        transaction.add(
          (0, import_spl_token4.createAssociatedTokenAccountInstruction)(
            agent.wallet.publicKey,
            toAta,
            to,
            mint
          )
        );
      }
      const mintInfo = await (0, import_spl_token4.getMint)(agent.connection, mint);
      const adjustedAmount = amount * Math.pow(10, mintInfo.decimals);
      transaction.add(
        (0, import_spl_token4.createTransferInstruction)(
          fromAta,
          toAta,
          agent.wallet.publicKey,
          adjustedAmount
        )
      );
      const { blockhash } = await agent.connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      tx = await (0, import_solana_agent_kit7.signOrSendTX)(agent, transaction.instructions);
    }
    return tx;
  } catch (error) {
    throw new Error(`Transfer failed: ${error.message}`);
  }
}

// src/solana/tools/get_balance.ts
var import_web314 = require("@solana/web3.js");
async function get_balance(agent, token_address) {
  if (!token_address) {
    return await agent.connection.getBalance(agent.wallet.publicKey) / import_web314.LAMPORTS_PER_SOL;
  }
  const token_account = await agent.connection.getTokenAccountBalance(token_address);
  return token_account.value.uiAmount || 0;
}

// src/solana/tools/get_balance_other.ts
var import_web315 = require("@solana/web3.js");
async function get_balance_other(agent, wallet_address, token_address) {
  try {
    if (!token_address) {
      return await agent.connection.getBalance(wallet_address) / import_web315.LAMPORTS_PER_SOL;
    }
    const tokenAccounts = await agent.connection.getTokenAccountsByOwner(
      wallet_address,
      { mint: token_address }
    );
    if (tokenAccounts.value.length === 0) {
      console.warn(
        `No token accounts found for wallet ${wallet_address.toString()} and token ${token_address.toString()}`
      );
      return 0;
    }
    const tokenAccount = await agent.connection.getParsedAccountInfo(
      tokenAccounts.value[0].pubkey
    );
    const tokenData = tokenAccount.value?.data;
    return tokenData.parsed?.info?.tokenAmount?.uiAmount || 0;
  } catch (error) {
    throw new Error(
      `Error fetching on-chain balance for ${token_address?.toString()}: ${error}`
    );
  }
}

// src/solana/tools/get_token_balances.ts
var import_spl_token5 = require("@solana/spl-token");
var import_web317 = require("@solana/web3.js");

// src/solana/tools/utils/tokenMetadata.ts
var import_web316 = require("@solana/web3.js");
async function getTokenMetadata(connection, tokenMint) {
  const METADATA_PROGRAM_ID = new import_web316.PublicKey(
    "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
  );
  const [metadataPDA] = import_web316.PublicKey.findProgramAddressSync(
    [
      Buffer.from("metadata"),
      METADATA_PROGRAM_ID.toBuffer(),
      new import_web316.PublicKey(tokenMint).toBuffer()
    ],
    METADATA_PROGRAM_ID
  );
  const metadata = await connection.getAccountInfo(metadataPDA);
  if (!metadata?.data) {
    throw new Error("Metadata not found");
  }
  let offset = 1 + 32 + 32;
  const data = metadata.data;
  const decoder = new TextDecoder();
  const readString = () => {
    let nameLength = data[offset];
    while (nameLength === 0) {
      offset++;
      nameLength = data[offset];
      if (offset >= data.length) {
        return null;
      }
    }
    offset++;
    const name2 = decoder.decode(data.slice(offset, offset + nameLength)).replace(new RegExp(String.fromCharCode(0), "g"), "");
    offset += nameLength;
    return name2;
  };
  const name = readString();
  const symbol = readString();
  const uri = readString();
  const sellerFeeBasisPoints = data.readUInt16LE(offset);
  offset += 2;
  let creators = null;
  if (data[offset] === 1) {
    offset++;
    const numCreators = data[offset];
    offset++;
    creators = [...Array(numCreators)].map(() => {
      const creator = {
        address: new import_web316.PublicKey(data.slice(offset, offset + 32)),
        verified: data[offset + 32] === 1,
        share: data[offset + 33]
      };
      offset += 34;
      return creator;
    });
  }
  return {
    name,
    symbol,
    uri,
    sellerFeeBasisPoints,
    creators
  };
}

// src/solana/tools/get_token_balances.ts
async function get_token_balance(agent, walletAddress) {
  const [lamportsBalance, tokenAccountData] = await Promise.all([
    agent.connection.getBalance(walletAddress ?? agent.wallet.publicKey),
    agent.connection.getParsedTokenAccountsByOwner(
      walletAddress ?? agent.wallet.publicKey,
      {
        programId: import_spl_token5.TOKEN_PROGRAM_ID
      }
    )
  ]);
  const removedZeroBalance = tokenAccountData.value.filter(
    (v) => v.account.data.parsed.info.tokenAmount.uiAmount !== 0
  );
  const tokenBalances = await Promise.all(
    removedZeroBalance.map(async (v) => {
      const mint = v.account.data.parsed.info.mint;
      const mintInfo = await getTokenMetadata(agent.connection, mint);
      return {
        tokenAddress: mint,
        name: mintInfo.name ?? "",
        symbol: mintInfo.symbol ?? "",
        balance: v.account.data.parsed.info.tokenAmount.uiAmount,
        decimals: v.account.data.parsed.info.tokenAmount.decimals
      };
    })
  );
  const solBalance = lamportsBalance / import_web317.LAMPORTS_PER_SOL;
  return {
    sol: solBalance,
    tokens: tokenBalances
  };
}

// src/solana/tools/get_wallet_address.ts
function getWalletAddress(agent) {
  return agent.wallet.publicKey.toBase58();
}

// src/solana/actions/balance.ts
var balanceAction = {
  name: "BALANCE_ACTION",
  similes: [
    "check balance",
    "get wallet balance",
    "view balance",
    "show balance",
    "check token balance"
  ],
  description: `Get the balance of a Solana wallet or token account.
  If you want to get the balance of your wallet, you don't need to provide the tokenAddress.
  If no tokenAddress is provided, the balance will be in SOL.`,
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          balance: "100",
          token: "SOL"
        },
        explanation: "Get SOL balance of the wallet"
      }
    ],
    [
      {
        input: {
          tokenAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        output: {
          status: "success",
          balance: "1000",
          token: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        explanation: "Get USDC token balance"
      }
    ]
  ],
  schema: import_zod11.z.object({
    tokenAddress: import_zod11.z.string().optional()
  }),
  handler: async (agent, input) => {
    const balance = await get_balance(
      agent,
      input.tokenAddress && new import_web318.PublicKey(input.tokenAddress)
    );
    return {
      status: "success",
      balance,
      token: input.tokenAddress || "SOL"
    };
  }
};
var balance_default = balanceAction;

// src/solana/actions/closeEmptyTokenAccounts.ts
var import_zod12 = require("zod");
var closeEmptyTokenAccountsAction = {
  name: "CLOSE_EMPTY_TOKEN_ACCOUNTS",
  similes: [
    "close token accounts",
    "remove empty accounts",
    "clean up token accounts",
    "close SPL token accounts",
    "clean wallet"
  ],
  description: `Close empty SPL Token accounts associated with your wallet to reclaim rent.
 This action will close both regular SPL Token accounts and Token-2022 accounts that have zero balance. `,
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          signature: "3KmPyiZvJQk8CfBVVaz8nf3c2crb6iqjQVDqNxknnusyb1FTFpXqD8zVSCBAd1X3rUcD8WiG1bdSjFbeHsmcYGXY",
          accountsClosed: 10
        },
        explanation: "Closed 10 empty token accounts successfully."
      }
    ],
    [
      {
        input: {},
        output: {
          status: "success",
          signature: "",
          accountsClosed: 0
        },
        explanation: "No empty token accounts were found to close."
      }
    ]
  ],
  schema: import_zod12.z.object({}),
  handler: async (agent) => {
    try {
      const result = await closeEmptyTokenAccounts(agent);
      if (result.size === 0) {
        return {
          status: "success",
          signature: "",
          accountsClosed: 0,
          message: "No empty token accounts found to close"
        };
      }
      return {
        status: "success",
        transaction: result.signature ?? result.signedTransaction,
        accountsClosed: result.size,
        message: `Successfully closed ${result.size} empty token accounts`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to close empty token accounts: ${error.message}`
      };
    }
  }
};
var closeEmptyTokenAccounts_default = closeEmptyTokenAccountsAction;

// src/solana/actions/getTPS.ts
var import_zod13 = require("zod");
var getTPSAction = {
  name: "GET_TPS",
  similes: [
    "get transactions per second",
    "check network speed",
    "network performance",
    "transaction throughput",
    "network tps"
  ],
  description: "Get the current transactions per second (TPS) of the Solana network",
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          tps: 3500,
          message: "Current network TPS: 3500"
        },
        explanation: "Get the current TPS of the Solana network"
      }
    ]
  ],
  schema: import_zod13.z.object({}),
  // No input parameters required
  handler: async (agent, _input) => {
    try {
      const response = await getTPS(agent);
      return {
        status: "success",
        response,
        message: `Current network TPS: ${response}`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to get TPS: ${error.message}`
      };
    }
  }
};
var getTPS_default = getTPSAction;

// src/solana/actions/requestFunds.ts
var import_zod14 = require("zod");
var requestFundsAction = {
  name: "REQUEST_FUNDS",
  similes: [
    "request sol",
    "get test sol",
    "use faucet",
    "request test tokens",
    "get devnet sol"
  ],
  description: "Request SOL from Solana faucet (devnet/testnet only)",
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          message: "Successfully requested faucet funds",
          network: "devnet.solana.com"
        },
        explanation: "Request SOL from the devnet faucet"
      }
    ]
  ],
  schema: import_zod14.z.object({}),
  // No input parameters required
  handler: async (agent, _input) => {
    await request_faucet_funds(agent);
    return {
      status: "success",
      message: "Successfully requested faucet funds",
      network: agent.connection.rpcEndpoint.split("/")[2]
    };
  }
};
var requestFunds_default = requestFundsAction;

// src/solana/actions/tokenBalances.ts
var import_web319 = require("@solana/web3.js");
var import_zod15 = require("zod");
var tokenBalancesAction = {
  name: "TOKEN_BALANCE_ACTION",
  similes: [
    "check token balances",
    "get wallet token balances",
    "view token balances",
    "show token balances",
    "check token balance"
  ],
  description: `Get the token balances of a Solana wallet.
  If you want to get the balance of your wallet, you don't need to provide the wallet address.`,
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          balance: {
            sol: 100,
            tokens: [
              {
                tokenAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
                name: "USD Coin",
                symbol: "USDC",
                balance: 100,
                decimals: 9
              }
            ]
          }
        },
        explanation: "Get token balances of the wallet"
      }
    ],
    [
      {
        input: {
          walletAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        output: {
          status: "success",
          balance: {
            sol: 100,
            tokens: [
              {
                tokenAddress: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
                name: "USD Coin",
                symbol: "USDC",
                balance: 100,
                decimals: 9
              }
            ]
          }
        },
        explanation: "Get address token balance"
      }
    ]
  ],
  schema: import_zod15.z.object({
    walletAddress: import_zod15.z.string().optional()
  }),
  handler: async (agent, input) => {
    const balance = await get_token_balance(
      agent,
      input.walletAddress ? new import_web319.PublicKey(input.walletAddress) : void 0
    );
    return {
      status: "success",
      balance
    };
  }
};
var tokenBalances_default = tokenBalancesAction;

// src/solana/actions/transfer.ts
var import_web320 = require("@solana/web3.js");
var import_zod16 = require("zod");
var transferAction = {
  name: "TRANSFER",
  similes: [
    "send tokens",
    "transfer funds",
    "send money",
    "send sol",
    "transfer tokens"
  ],
  description: `Transfer tokens or SOL to another address (also called as wallet address).`,
  examples: [
    [
      {
        input: {
          to: "8x2dR8Mpzuz2YqyZyZjUbYWKSWesBo5jMx2Q9Y86udVk",
          amount: 1
        },
        output: {
          status: "success",
          message: "Transfer completed successfully",
          amount: 1,
          recipient: "8x2dR8Mpzuz2YqyZyZjUbYWKSWesBo5jMx2Q9Y86udVk",
          token: "SOL",
          transaction: "5UfgJ5vVZxUxefDGqzqkVLHzHxVTyYH9StYyHKgvHYmXJgqJKxEqy9k4Rz9LpXrHF9kUZB7"
        },
        explanation: "Transfer 1 SOL to the recipient address"
      }
    ],
    [
      {
        input: {
          to: "8x2dR8Mpzuz2YqyZyZjUbYWKSWesBo5jMx2Q9Y86udVk",
          amount: 100,
          mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        output: {
          status: "success",
          message: "Transfer completed successfully",
          amount: 100,
          recipient: "8x2dR8Mpzuz2YqyZyZjUbYWKSWesBo5jMx2Q9Y86udVk",
          token: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
          transaction: "4VfgJ5vVZxUxefDGqzqkVLHzHxVTyYH9StYyHKgvHYmXJgqJKxEqy9k4Rz9LpXrHF9kUZB7"
        },
        explanation: "Transfer 100 USDC tokens to the recipient address"
      }
    ]
  ],
  schema: import_zod16.z.object({
    to: import_zod16.z.string().min(32, "Invalid Solana address"),
    amount: import_zod16.z.number().positive("Amount must be positive"),
    mint: import_zod16.z.string().optional()
  }),
  handler: async (agent, input) => {
    const recipient = new import_web320.PublicKey(input.to);
    const mintAddress = input.mint ? new import_web320.PublicKey(input.mint) : void 0;
    const tx = await transfer(agent, recipient, input.amount, mintAddress);
    return {
      status: "success",
      message: "Transfer completed successfully",
      amount: input.amount,
      recipient: input.to,
      token: input.mint || "SOL",
      transaction: tx
    };
  }
};
var transfer_default = transferAction;

// src/solana/actions/walletAddress.ts
var import_zod17 = require("zod");
var walletAddressAction = {
  name: "WALLET_ADDRESS",
  similes: [
    "get wallet address",
    "show wallet address",
    "display wallet address",
    "my wallet address"
  ],
  description: `Get your wallet address.`,
  examples: [
    [
      {
        input: {},
        output: {
          status: "success",
          message: "Wallet address retrieved successfully",
          address: "8x2dR8Mpzuz2YqyZyZjUbYWKSWesBo5jMx2Q9Y86udVk"
        },
        explanation: "Get your wallet address"
      }
    ]
  ],
  schema: import_zod17.z.object({}),
  handler: async (agent) => {
    const address = getWalletAddress(agent);
    return {
      status: "success",
      message: "Wallet address retrieved successfully",
      address
    };
  }
};
var walletAddress_default = walletAddressAction;

// src/mayan/actions/swap.ts
var import_zod18 = require("zod");

// src/mayan/tools/swap.ts
var import_swap_sdk = require("@mayanfinance/swap-sdk");
var import_ERC20Permit = __toESM(require("@openzeppelin/contracts/build/contracts/ERC20Permit.json"), 1);
var import_ethers = require("ethers");

// src/mayan/tools/MayanForwarderArtifact.ts
var MayanForwarderArtifact_default = {
  _format: "hh-sol-artifact-1",
  contractName: "MayanForwarder",
  sourceName: "src/MayanForwarder.sol",
  abi: [
    {
      inputs: [
        {
          internalType: "address",
          name: "_guardian",
          type: "address"
        },
        {
          internalType: "address[]",
          name: "_swapProtocols",
          type: "address[]"
        },
        {
          internalType: "address[]",
          name: "_mayanProtocols",
          type: "address[]"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [],
      name: "UnsupportedProtocol",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "protocolData",
          type: "bytes"
        }
      ],
      name: "ForwardedERC20",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "protocolData",
          type: "bytes"
        }
      ],
      name: "ForwardedEth",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "SwapAndForwarded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "middleToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "middleAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "mayanData",
          type: "bytes"
        }
      ],
      name: "SwapAndForwardedERC20",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "middleToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "middleAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "mayanData",
          type: "bytes"
        }
      ],
      name: "SwapAndForwardedEth",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newGuardian",
          type: "address"
        }
      ],
      name: "changeGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "claimGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "deadline",
              type: "uint256"
            },
            {
              internalType: "uint8",
              name: "v",
              type: "uint8"
            },
            {
              internalType: "bytes32",
              name: "r",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "s",
              type: "bytes32"
            }
          ],
          internalType: "struct MayanForwarder.PermitParams",
          name: "permitParams",
          type: "tuple"
        },
        {
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "protocolData",
          type: "bytes"
        }
      ],
      name: "forwardERC20",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "protocolData",
          type: "bytes"
        }
      ],
      name: "forwardEth",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [],
      name: "guardian",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "mayanProtocols",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "nextGuardian",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address payable",
          name: "to",
          type: "address"
        }
      ],
      name: "rescueEth",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "rescueToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          internalType: "bool",
          name: "enabled",
          type: "bool"
        }
      ],
      name: "setMayanProtocol",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          internalType: "bool",
          name: "enabled",
          type: "bool"
        }
      ],
      name: "setSwapProtocol",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "deadline",
              type: "uint256"
            },
            {
              internalType: "uint8",
              name: "v",
              type: "uint8"
            },
            {
              internalType: "bytes32",
              name: "r",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "s",
              type: "bytes32"
            }
          ],
          internalType: "struct MayanForwarder.PermitParams",
          name: "permitParams",
          type: "tuple"
        },
        {
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "swapData",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "middleToken",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "minMiddleAmount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "mayanData",
          type: "bytes"
        }
      ],
      name: "swapAndForwardERC20",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "swapData",
          type: "bytes"
        },
        {
          internalType: "address",
          name: "middleToken",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "minMiddleAmount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "mayanProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "mayanData",
          type: "bytes"
        }
      ],
      name: "swapAndForwardEth",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "swapProtocols",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ],
  linkReferences: {},
  deployedLinkReferences: {}
};

// src/mayan/tools/swap.ts
async function findTokenContract(symbol, chain) {
  const tokens = await (0, import_swap_sdk.fetchTokenList)(chain, true);
  const token = tokens.find(
    (t) => t.symbol.toLowerCase() === symbol.toLowerCase()
  );
  if (!token) {
    throw new Error(`Couldn't find token with ${symbol} symbol`);
  }
  return token.contract;
}
async function swap(agent, amount, fromChain, fromToken, toChain, toToken, dstAddr, slippageBps = "auto") {
  if (fromToken.length < 32) {
    fromToken = await findTokenContract(fromToken, fromChain);
  }
  if (toToken.length < 32) {
    toToken = await findTokenContract(toToken, toChain);
  }
  const quotes = await (0, import_swap_sdk.fetchQuote)({
    amount: +amount,
    fromChain,
    toChain,
    fromToken,
    toToken,
    slippageBps
  });
  if (quotes.length === 0) {
    throw new Error(
      "There is no quote available for the tokens you requested."
    );
  }
  let txHash;
  if (fromChain === "solana") {
    txHash = await swapSolana(quotes[0], agent, dstAddr);
  } else {
    txHash = await swapEVM(quotes[0], agent, dstAddr);
  }
  return `https://explorer.mayan.finance/swap/${txHash}`;
}
async function swapSolana(quote, agent, dstAddr) {
  const jitoConfig = await getJitoConfig();
  const jitoTipLamports = await getJitoTipLamports();
  const jitoTip = jitoConfig?.enable ? Math.min(
    jitoTipLamports || jitoConfig?.defaultTipLamports,
    jitoConfig?.maxTipLamports
  ) : 0;
  const jitoOptions = {
    tipLamports: jitoTip,
    jitoAccount: jitoConfig.jitoAccount,
    jitoSendUrl: jitoConfig.sendBundleUrl,
    signAllTransactions: agent.wallet.signAllTransactions
  };
  const swapRes = await (0, import_swap_sdk.swapFromSolana)(
    quote,
    agent.wallet.publicKey.toBase58(),
    dstAddr,
    null,
    agent.wallet.signTransaction,
    agent.connection,
    [],
    { skipPreflight: true },
    jitoOptions
  );
  if (!swapRes.signature) {
    throw new Error("Error on swap from solana. Try again.");
  }
  try {
    const { blockhash, lastValidBlockHeight } = await agent.connection.getLatestBlockhash();
    const result = await agent.connection.confirmTransaction(
      {
        signature: swapRes.signature,
        blockhash,
        lastValidBlockHeight
      },
      "confirmed"
    );
    if (result?.value.err) {
      throw new Error(`Transaction ${swapRes.serializedTrx} reverted!`);
    }
    return swapRes.signature;
  } catch (error) {
    await new Promise((resolve) => setTimeout(resolve, 3e3));
    const res = await fetch(
      `https://explorer-api.mayan.finance/v3/swap/trx/${swapRes.signature}`
    );
    if (res.status !== 200) {
      throw error;
    }
    return swapRes.signature;
  }
}
var evmWallet;
async function swapEVM(quote, agent, dstAddr) {
  if (!evmWallet) {
    if (agent.config?.ETHEREUM_PRIVATE_KEY) {
      evmWallet = new import_ethers.Wallet(agent.config?.ETHEREUM_PRIVATE_KEY);
    } else {
      throw new Error("You haven't provided EVM wallet private key.");
    }
  }
  const signer = evmWallet.connect((0, import_ethers.getDefaultProvider)(quote.fromToken.chainId));
  const amountIn = getAmountOfFractionalAmount(
    quote.effectiveAmountIn,
    quote.fromToken.decimals
  );
  const tokenContract = new import_ethers.Contract(
    quote.fromToken.contract,
    import_ERC20Permit.default.abi,
    signer
  );
  const allowance = await tokenContract.allowance(
    evmWallet.address,
    import_swap_sdk.addresses.MAYAN_FORWARDER_CONTRACT
  );
  if (allowance < amountIn) {
    const approveTx = await tokenContract.approve(
      import_swap_sdk.addresses.MAYAN_FORWARDER_CONTRACT,
      amountIn
    );
    await approveTx.wait();
  }
  let permit;
  if (quote.fromToken.supportsPermit) {
    permit = await getERC20Permit(quote, tokenContract, amountIn, signer);
  }
  const swapRes = await (0, import_swap_sdk.swapFromEvm)(
    quote,
    evmWallet.address,
    dstAddr,
    null,
    signer,
    permit,
    null,
    null
  );
  if (typeof swapRes === "string") {
    return swapRes;
  }
  return swapRes.hash;
}
async function getJitoConfig() {
  const res = await fetch(`https://sia.mayan.finance/v4/init`);
  const data = await res.json();
  return data.solanaJitoConfig;
}
async function getJitoTipLamports() {
  const res = await fetch(`https://price-api.mayan.finance/jito-tips/suggest`);
  const data = await res.json();
  const tip = typeof data?.default === "number" && Number.isFinite(data.default) ? data?.default?.toFixed(9) : null;
  return tip ? Math.floor(Number(tip) * 10 ** 9) : null;
}
function getAmountOfFractionalAmount(amount, decimals) {
  const cutFactor = Math.min(8, Number(decimals));
  const numStr = Number(amount).toFixed(cutFactor + 1);
  const reg = new RegExp(`^-?\\d+(?:\\.\\d{0,${cutFactor}})?`);
  const matchResult = numStr.match(reg);
  if (!matchResult) {
    throw new Error("getAmountOfFractionalAmount: fixedAmount is null");
  }
  const fixedAmount = matchResult[0];
  return (0, import_ethers.parseUnits)(fixedAmount, Number(decimals));
}
async function getERC20Permit(quote, tokenContract, amountIn, signer) {
  const walletSrcAddr = await signer.getAddress();
  const nonce = await tokenContract.nonces(walletSrcAddr);
  const deadline = Math.floor(Date.now() / 1e3) + 3600;
  const domain = {
    name: await tokenContract.name(),
    version: "1",
    chainId: quote.fromToken.chainId,
    verifyingContract: await tokenContract.getAddress()
  };
  const domainSeparator = await tokenContract.DOMAIN_SEPARATOR();
  for (let i = 1; i < 11; i++) {
    domain.version = String(i);
    const hash = import_ethers.TypedDataEncoder.hashDomain(domain);
    if (hash.toLowerCase() === domainSeparator.toLowerCase()) {
      break;
    }
  }
  let spender = import_swap_sdk.addresses.MAYAN_FORWARDER_CONTRACT;
  if (quote.type === "SWIFT" && quote.gasless) {
    const forwarderContract = new import_ethers.Contract(
      import_swap_sdk.addresses.MAYAN_FORWARDER_CONTRACT,
      MayanForwarderArtifact_default.abi,
      signer.provider
    );
    const isValidSwiftContract = await forwarderContract.mayanProtocols(
      quote.swiftMayanContract
    );
    if (!isValidSwiftContract) {
      throw new Error("Invalid Swift contract for gasless swap");
    }
    if (!quote.swiftMayanContract) {
      throw new Error("Swift contract not found");
    }
    spender = quote.swiftMayanContract;
  }
  const types = {
    Permit: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
      { name: "value", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  };
  const value = {
    owner: walletSrcAddr,
    spender,
    value: amountIn,
    nonce,
    deadline
  };
  const signature = await signer.signTypedData(domain, types, value);
  const { v, r, s } = import_ethers.Signature.from(signature);
  const permitTx = await tokenContract.permit(
    walletSrcAddr,
    spender,
    amountIn,
    deadline,
    v,
    r,
    s
  );
  await permitTx.wait();
  return {
    value: amountIn,
    deadline,
    v,
    r,
    s
  };
}

// src/mayan/actions/swap.ts
var swapAction = {
  name: "SWAP",
  similes: ["swap tokens", "exchange tokens", "cross-chain swap"],
  description: `This tool can be used to swap tokens to another token cross-chain (It uses Mayan Swap SDK).`,
  examples: [
    [
      {
        input: {
          amount: "0.02",
          fromChain: "solana",
          fromToken: "SOL",
          toChain: "polygon",
          toToken: "POL",
          dstAddr: "0x0cae42c0ce52e6e64c1e384ff98e686c6ee225f0"
        },
        output: {
          status: "success",
          message: "Swap executed successfully",
          url: "https://explorer.mayan.finance/swap/3JywZA6om5t1c5gT1bkFX91bEewHGmntJAqRZniEzETDEBMERvzxBeXVUUMFaernRCmvniZTKsAM7TVG3CTumc12"
        },
        explanation: "swap 0.02 SOL from solana to pol polygon destination 0x0cae42c0ce52e6e64c1e384ff98e686c6ee225f0"
      },
      {
        input: {
          amount: "0.02",
          fromChain: "solana",
          fromToken: "sol",
          toChain: "solana",
          toToken: "HNT",
          dstAddr: "4ZgCP2idpqrxuQNfsjakJEm9nFyZ2xnT4CrDPKPULJPk"
        },
        output: {
          status: "success",
          message: "Swap executed successfully",
          url: "https://explorer.mayan.finance/swap/2GLNqs5gXCBSwRt6VjtfQRnLWYbcU1gzkgjWMWautv1RUj13Di4qJPjV29YRpoAdMYxgXj8ArMLzF3bCCZmVUXHz"
        },
        explanation: "swap 0.02 sol from solana to hnt solana destination 4ZgCP2idpqrxuQNfsjakJEm9nFyZ2xnT4CrDPKPULJPk"
      }
    ],
    [
      {
        input: {
          amount: "0.02",
          fromChain: "solana",
          fromToken: "sol",
          toChain: "solana",
          toToken: "HNT",
          dstAddr: "4ZgCP2idpqrxuQNfsjakJEm9nFyZ2xnT4CrDPKPULJPk"
        },
        output: {
          status: "success",
          message: "Swap executed successfully",
          url: "https://explorer.mayan.finance/swap/2GLNqs5gXCBSwRt6VjtfQRnLWYbcU1gzkgjWMWautv1RUj13Di4qJPjV29YRpoAdMYxgXj8ArMLzF3bCCZmVUXHz"
        },
        explanation: "swap 0.02 sol from solana to hnt solana destination 4ZgCP2idpqrxuQNfsjakJEm9nFyZ2xnT4CrDPKPULJPk"
      }
    ]
  ],
  schema: import_zod18.z.object({
    amount: import_zod18.z.string().refine(
      (val) => !isNaN(+val) && Number(val).toString() === val,
      "amount is not a valid number"
    ),
    fromChain: import_zod18.z.enum([
      "solana",
      "ethereum",
      "bsc",
      "polygon",
      "avalanche",
      "arbitrum",
      "optimism",
      "base"
    ]),
    fromToken: import_zod18.z.string(),
    toChain: import_zod18.z.enum([
      "solana",
      "ethereum",
      "bsc",
      "polygon",
      "avalanche",
      "arbitrum",
      "optimism",
      "base"
    ]),
    toToken: import_zod18.z.string(),
    dstAddr: import_zod18.z.string().min(32, "Invalid destination address"),
    inputAmount: import_zod18.z.number().positive("Input amount must be positive"),
    slippageBps: import_zod18.z.number().min(0).max(1e4).optional()
  }),
  handler: async (agent, input) => {
    if (input.fromChain !== "solana" && input.toChain !== "solana") {
      throw new Error("one of the from or to chain should be solana.");
    }
    const url = await swap(
      agent,
      input.amount,
      input.fromChain,
      input.fromToken,
      input.toChain,
      input.toToken,
      input.dstAddr,
      input.slippageBps
    );
    return {
      status: "success",
      message: "Swap executed successfully",
      url
    };
  }
};
var swap_default = swapAction;

// src/pumpfun/actions/launchPumpfunToken.ts
var import_zod19 = require("zod");

// src/pumpfun/tools/launch_pumpfun_token.ts
var import_web321 = require("@solana/web3.js");
var import_solana_agent_kit8 = require("solana-agent-kit");
async function uploadMetadata(tokenName, tokenTicker, description, imageUrl, options) {
  const formData = new URLSearchParams();
  formData.append("name", tokenName);
  formData.append("symbol", tokenTicker);
  formData.append("description", description);
  formData.append("showName", "true");
  if (options?.twitter) {
    formData.append("twitter", options.twitter);
  }
  if (options?.telegram) {
    formData.append("telegram", options.telegram);
  }
  if (options?.website) {
    formData.append("website", options.website);
  }
  const imageResponse = await fetch(imageUrl);
  const imageBlob = await imageResponse.blob();
  const files = {
    file: new File([imageBlob], "token_image.png", { type: "image/png" })
  };
  const finalFormData = new FormData();
  for (const [key, value] of formData.entries()) {
    finalFormData.append(key, value);
  }
  if (files?.file) {
    finalFormData.append("file", files.file);
  }
  const metadataResponse = await fetch("https://pump.fun/api/ipfs", {
    method: "POST",
    body: finalFormData
  });
  if (!metadataResponse.ok) {
    throw new Error(`Metadata upload failed: ${metadataResponse.statusText}`);
  }
  return await metadataResponse.json();
}
async function createTokenTransaction(agent, mintKeypair, metadataResponse, options) {
  const payload = {
    publicKey: agent.wallet.publicKey.toBase58(),
    action: "create",
    tokenMetadata: {
      name: metadataResponse.metadata.name,
      symbol: metadataResponse.metadata.symbol,
      uri: metadataResponse.metadataUri
    },
    mint: mintKeypair.publicKey.toBase58(),
    denominatedInSol: "true",
    // API expects string "true"
    amount: options?.initialLiquiditySOL || 1e-4,
    slippage: options?.slippageBps || 5,
    priorityFee: options?.priorityFee || 5e-5,
    pool: "pump"
  };
  const response = await fetch("https://pumpportal.fun/api/trade-local", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(
      `Transaction creation failed: ${response.status} - ${errorText}`
    );
  }
  return response;
}
async function launchPumpFunToken(agent, tokenName, tokenTicker, description, imageUrl, options) {
  try {
    const mintKeypair = import_web321.Keypair.generate();
    const metadataResponse = await uploadMetadata(
      tokenName,
      tokenTicker,
      description,
      imageUrl,
      options
    );
    const response = await createTokenTransaction(
      agent,
      mintKeypair,
      metadataResponse,
      options
    );
    const transactionData = await response.arrayBuffer();
    const tx = import_web321.VersionedTransaction.deserialize(
      new Uint8Array(transactionData)
    );
    if (agent.config.signOnly) {
      return {
        signedTransaction: await agent.wallet.signTransaction(tx),
        mint: mintKeypair.publicKey.toBase58(),
        metadataUri: metadataResponse.metadataUri
      };
    }
    const { blockhash } = await agent.connection.getLatestBlockhash();
    tx.message.recentBlockhash = blockhash;
    return {
      signature: await (0, import_solana_agent_kit8.signOrSendTX)(agent, tx, [mintKeypair]),
      mint: mintKeypair.publicKey.toBase58(),
      metadataUri: metadataResponse.metadataUri
    };
  } catch (error) {
    console.error("Error in launchpumpfuntoken:", error);
    if (error instanceof Error && "logs" in error) {
      console.error("Transaction logs:", error.logs);
    }
    throw error;
  }
}

// src/pumpfun/actions/launchPumpfunToken.ts
var launchPumpfunTokenAction = {
  name: "LAUNCH_PUMPFUN_TOKEN",
  similes: [
    "create pumpfun token",
    "launch token on pumpfun",
    "deploy pumpfun token",
    "create meme token",
    "launch memecoin",
    "create pump token"
  ],
  description: "Launch a new token on Pump.fun with customizable metadata and initial liquidity",
  examples: [
    [
      {
        input: {
          tokenName: "Sample Token",
          tokenTicker: "SMPL",
          description: "A sample token for demonstration",
          imageUrl: "https://example.com/token.png",
          twitter: "@sampletoken",
          telegram: "t.me/sampletoken",
          website: "https://sampletoken.com",
          initialLiquiditySOL: 0.1,
          slippageBps: 10,
          priorityFee: 1e-4
        },
        output: {
          status: "success",
          signature: "2ZE7Rz...",
          mint: "7nxQB...",
          metadataUri: "https://arweave.net/...",
          message: "Successfully launched token on Pump.fun"
        },
        explanation: "Launch a new token with custom metadata and 0.1 SOL initial liquidity"
      }
    ]
  ],
  schema: import_zod19.z.object({
    tokenName: import_zod19.z.string().min(1).max(32).describe("Name of the token"),
    tokenTicker: import_zod19.z.string().min(2).max(10).describe("Ticker symbol of the token"),
    description: import_zod19.z.string().min(1).max(1e3).describe("Description of the token"),
    imageUrl: import_zod19.z.string().url().describe("URL of the token image"),
    twitter: import_zod19.z.string().optional().describe("Twitter handle (optional)"),
    telegram: import_zod19.z.string().optional().describe("Telegram group link (optional)"),
    website: import_zod19.z.string().url().optional().describe("Website URL (optional)"),
    initialLiquiditySOL: import_zod19.z.number().min(1e-4).default(1e-4).describe("Initial liquidity in SOL"),
    slippageBps: import_zod19.z.number().min(1).max(1e3).default(5).describe("Slippage tolerance in basis points"),
    priorityFee: import_zod19.z.number().min(1e-5).default(5e-5).describe("Priority fee in SOL")
  }),
  handler: async (agent, input) => {
    try {
      const { tokenName, tokenTicker, description, imageUrl } = input;
      const result = await launchPumpFunToken(
        agent,
        tokenName,
        tokenTicker,
        description,
        imageUrl,
        input
      );
      return {
        status: "success",
        signature: result.signature,
        mint: result.mint,
        metadataUri: result.metadataUri,
        transaction: result.signedTransaction ?? result.signature,
        message: "Successfully launched token on Pump.fun"
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to launch token: ${error.message}`
      };
    }
  }
};
var launchPumpfunToken_default = launchPumpfunTokenAction;

// src/pyth/actions/pythFetchPrice.ts
var import_zod20 = require("zod");

// src/pyth/tools/pyth_fetch_price.ts
var import_bn = __toESM(require("bn.js"), 1);
async function fetchPythPriceFeedID(tokenSymbol) {
  try {
    const stableHermesServiceUrl = "https://hermes.pyth.network";
    const response = await fetch(
      `${stableHermesServiceUrl}/v2/price_feeds?query=${tokenSymbol}&asset_type=crypto`
    );
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    if (data.length === 0) {
      throw new Error(`No price feed found for ${tokenSymbol}`);
    }
    if (data.length > 1) {
      const filteredData = data.filter(
        (item) => item.attributes.base.toLowerCase() === tokenSymbol.toLowerCase()
      );
      if (filteredData.length === 0) {
        throw new Error(`No price feed found for ${tokenSymbol}`);
      }
      return filteredData[0].id;
    }
    return data[0].id;
  } catch (error) {
    throw new Error(
      `Fetching price feed ID from Pyth failed: ${error.message}`
    );
  }
}
async function fetchPythPrice(feedID) {
  try {
    const stableHermesServiceUrl = "https://hermes.pyth.network";
    const response = await fetch(
      `${stableHermesServiceUrl}/v2/updates/price/latest?ids[]=${feedID}`
    );
    const data = await response.json();
    const parsedData = data.parsed;
    if (parsedData.length === 0) {
      throw new Error(`No price data found for ${feedID}`);
    }
    const price = new import_bn.default(parsedData[0].price.price);
    const exponent = parsedData[0].price.expo;
    if (exponent < 0) {
      const adjustedPrice = price.mul(new import_bn.default(100));
      const divisor = new import_bn.default(10).pow(new import_bn.default(-exponent));
      const scaledPrice2 = adjustedPrice.div(divisor);
      const priceStr = scaledPrice2.toString();
      const formattedPrice = `${priceStr.slice(0, -2)}.${priceStr.slice(-2)}`;
      return formattedPrice.startsWith(".") ? `0${formattedPrice}` : formattedPrice;
    }
    const scaledPrice = price.div(new import_bn.default(10).pow(new import_bn.default(exponent)));
    return scaledPrice.toString();
  } catch (error) {
    throw new Error(`Fetching price from Pyth failed: ${error.message}`);
  }
}

// src/pyth/actions/pythFetchPrice.ts
var pythFetchPriceAction = {
  name: "PYTH_FETCH_PRICE",
  similes: [
    "get pyth price",
    "check pyth price",
    "pyth oracle price",
    "fetch from pyth",
    "pyth price feed",
    "oracle price"
  ],
  description: "Fetch the current price from a Pyth oracle price feed",
  examples: [
    [
      {
        input: {
          tokenSymbol: "SOL"
          // SOL/USD price feed
        },
        output: {
          status: "success",
          price: "23.45",
          message: "Current price: $23.45"
        },
        explanation: "Get the current SOL/USD price from Pyth oracle"
      }
    ]
  ],
  schema: import_zod20.z.object({
    tokenSymbol: import_zod20.z.string().min(1).describe("The token symbol to fetch the price for")
  }),
  handler: async (_agent, input) => {
    try {
      const priceFeedId = await fetchPythPriceFeedID(
        input.tokenSymbol
      );
      const priceStr = await fetchPythPrice(priceFeedId);
      return {
        status: "success",
        price: priceStr,
        message: `Current price: $${priceStr}`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to fetch price from Pyth: ${error.message}`
      };
    }
  }
};
var pythFetchPrice_default = pythFetchPriceAction;

// src/rugcheck/actions/rugcheck.ts
var import_zod21 = require("zod");

// src/rugcheck/tools/rugcheck.ts
var BASE_URL = "https://api.rugcheck.xyz/v1";
async function fetchTokenReportSummary(mint) {
  try {
    const response = await fetch(`${BASE_URL}/tokens/${mint}/report/summary`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error(
      `Error fetching report summary for token ${mint}:`,
      error.message
    );
    throw new Error(`Failed to fetch report summary for token ${mint}.`);
  }
}
async function fetchTokenDetailedReport(mint) {
  try {
    const response = await fetch(`${BASE_URL}/tokens/${mint}/report`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error(
      `Error fetching detailed report for token ${mint}:`,
      error.message
    );
    throw new Error(`Failed to fetch detailed report for token ${mint}.`);
  }
}

// src/rugcheck/actions/rugcheck.ts
var rugcheckAction = {
  name: "RUGCHECK",
  description: "Check if a token is a rug pull",
  similes: [
    "check rug pull",
    "rug pull check",
    "rug pull detector",
    "rug pull scanner",
    "rug pull alert"
  ],
  examples: [
    [
      {
        input: {
          mint: "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN"
        },
        output: {
          status: "success",
          message: "Token is not a rug pull"
        },
        explanation: "Check whether JUP is a rugpull"
      }
    ]
  ],
  schema: import_zod21.z.object({
    mint: import_zod21.z.string().min(1).describe("The token mint address")
  }),
  handler: async (_agent, input) => {
    try {
      const res = await fetchTokenReportSummary(input.mint);
      return {
        status: "success",
        response: res
      };
    } catch (error) {
      return {
        status: "error",
        message: error.message
      };
    }
  }
};
var rugcheck_default = rugcheckAction;

// src/solutiofi/actions/burnTokens.ts
var import_zod22 = require("zod");

// src/solutiofi/tools/solutiofi.ts
var import_sdk = __toESM(require("@solutiofi/sdk"), 1);
var import_solana_agent_kit9 = require("solana-agent-kit");
var solutiofiClient = null;
async function initClient(agent) {
  if (!agent.config?.SOLUTIOFI_API_KEY) {
    throw new Error("SolutioFi API key not found in config");
  }
  if (!solutiofiClient) {
    solutiofiClient = new import_sdk.default({
      apiKey: agent.config?.SOLUTIOFI_API_KEY
    });
    await solutiofiClient.authenticate();
  }
  return solutiofiClient;
}
async function closeAccounts(agent, mints) {
  try {
    const client = await initClient(agent);
    const signaturesOrTxs = [];
    const versionedTxns = await client.close(
      agent.wallet.publicKey.toString(),
      mints
    );
    for (const transaction of versionedTxns) {
      try {
        const { blockhash } = await agent.connection.getLatestBlockhash();
        transaction.message.recentBlockhash = blockhash;
        const signatureOrTx = await (0, import_solana_agent_kit9.signOrSendTX)(agent, transaction);
        signaturesOrTxs.push(signatureOrTx);
      } catch (_error) {
        continue;
      }
    }
    return signaturesOrTxs;
  } catch (e) {
    throw new Error(`Failed to close accounts: ${e}`);
  }
}
async function burnTokens(agent, mints) {
  try {
    const client = await initClient(agent);
    const signaturesOrTxs = [];
    const versionedTxns = await client.burn(
      agent.wallet.publicKey.toString(),
      mints
    );
    for (const transaction of versionedTxns) {
      try {
        const { blockhash } = await agent.connection.getLatestBlockhash();
        transaction.message.recentBlockhash = blockhash;
        const signatureOrTx = await (0, import_solana_agent_kit9.signOrSendTX)(agent, transaction);
        signaturesOrTxs.push(signatureOrTx);
      } catch (_error) {
        continue;
      }
    }
    return signaturesOrTxs;
  } catch (e) {
    throw new Error(`Failed to burn tokens: ${e}`);
  }
}
async function mergeTokens(agent, inputAssets, outputMint, priorityFee) {
  try {
    const client = await initClient(agent);
    const signaturesOrTxs = [];
    const swapData = await client.merge(
      agent.wallet.publicKey.toString(),
      inputAssets,
      outputMint,
      priorityFee
    );
    for (const txn of swapData.transactions) {
      try {
        const { blockhash } = await agent.connection.getLatestBlockhash();
        txn.transaction.message.recentBlockhash = blockhash;
        const signatureOrTx = await (0, import_solana_agent_kit9.signOrSendTX)(agent, txn.transaction);
        signaturesOrTxs.push(signatureOrTx);
      } catch (_error) {
        continue;
      }
    }
    return signaturesOrTxs;
  } catch (e) {
    throw new Error(`Failed to merge tokens: ${e}`);
  }
}
async function spreadToken(agent, inputAsset, targetTokens, priorityFee) {
  try {
    const client = await initClient(agent);
    const signaturesOrTxs = [];
    const swapData = await client.spread(
      agent.wallet.publicKey.toString(),
      inputAsset,
      targetTokens,
      priorityFee
    );
    for (const txn of swapData.transactions) {
      try {
        const { blockhash } = await agent.connection.getLatestBlockhash();
        txn.transaction.message.recentBlockhash = blockhash;
        const signatureOrTx = await (0, import_solana_agent_kit9.signOrSendTX)(agent, txn.transaction);
        signaturesOrTxs.push(signatureOrTx);
      } catch (_error) {
        continue;
      }
    }
    return signaturesOrTxs;
  } catch (e) {
    throw new Error(`Failed to spread token: ${e}`);
  }
}

// src/solutiofi/actions/burnTokens.ts
var burnTokensAction = {
  name: "SOLUTIOFI_BURN_TOKENS",
  description: "Burn tokens using SolutioFi",
  similes: [
    "burn tokens",
    "burn spl tokens",
    "burn spl-token",
    "destroy tokens",
    "burn assets",
    "burn nfts",
    "burn an nft",
    "permanently delete an nft or a token",
    "remove tokens from circulation",
    "delete my tokens",
    "permanently remove my tokens",
    "burn tokens with solutiofi",
    "burn nfts with solutiofi"
  ],
  examples: [
    [
      {
        input: {
          mints: ["tokenMint123", "tokenMint456"]
        },
        output: {
          status: "success",
          message: "Successfully burnt tokens",
          transactions: ["tx_signature"]
        },
        explanation: "Burn specified tokens"
      }
    ]
  ],
  schema: import_zod22.z.object({
    mints: import_zod22.z.array(import_zod22.z.string()).describe("Array of mint addresses to burn")
  }),
  handler: async (agent, input) => {
    try {
      const { mints } = input;
      const transactions = await burnTokens(agent, mints);
      return {
        status: "success",
        transactions,
        message: "Successfully burned tokens"
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to burn tokens: ${error.message}`,
        code: error.code || "BURN_TOKENS_ERROR"
      };
    }
  }
};
var burnTokens_default = burnTokensAction;

// src/solutiofi/actions/closeAccounts.ts
var import_zod23 = require("zod");
var closeAccountsAction = {
  name: "SOLUTIOFI_CLOSE_ACCOUNTS",
  description: "Close specific token accounts using SolutioFi",
  similes: [
    "close token accounts",
    "close accounts with solutiofi",
    "close specific token accounts",
    "close specific spl token account",
    "remove empty accounts",
    "clean up token accounts",
    "close SPL token accounts",
    "delete my empty token accounts",
    "remove unused accounts",
    "disable token accounts",
    "deactivate empty token accounts",
    "clear empty token accounts",
    "reclaim SOL by closing accounts",
    "reclaim rent by closing empty accounts",
    "purge my wallet of empty accounts",
    "I want to close some accounts",
    "help me remove empty token accounts",
    "delete unnecessary accounts",
    "get rid of my empty accounts",
    "close down specific Solana token accounts",
    "remove all zero-balance tokens from my wallet",
    "I want to remove some token accounts"
  ],
  examples: [
    [
      {
        input: {
          mints: ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"]
        },
        output: {
          status: "success",
          message: "Successfully closed accounts",
          transactions: ["tx_signature"]
        },
        explanation: "Close specified token accounts"
      }
    ]
  ],
  schema: import_zod23.z.object({
    mints: import_zod23.z.array(import_zod23.z.string()).describe("Array of mint addresses to close")
  }),
  handler: async (agent, input) => {
    try {
      const { mints } = input;
      const transactions = await closeAccounts(agent, mints);
      return {
        status: "success",
        transactions,
        message: `Successfully closed ${mints.length} accounts`
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to close accounts: ${error.message}`,
        code: error.code || "CLOSE_ACCOUNTS_ERROR"
      };
    }
  }
};
var closeAccounts_default = closeAccountsAction;

// src/solutiofi/actions/mergeTokens.ts
var import_zod24 = require("zod");
var mergeTokensAction = {
  name: "SOLUTIOFI_MERGE_TOKENS",
  description: "Merge multiple tokens into one using SolutioFi",
  similes: [
    "merge tokens",
    "combine tokens",
    "swap tokens",
    "merge tokens with solutiofi",
    "swap multiple tokens for one",
    "convert tokens into a single asset",
    "merge SPL tokens",
    "swap tokens into one",
    "combine assets into one token",
    "convert multiple tokens into one",
    "swap multiple assets into a single token",
    "combine token holdings",
    "exchange tokens for a unified asset",
    "aggregate tokens into one"
  ],
  examples: [
    [
      {
        input: {
          inputAssets: [
            { mint: "mint1", amount: "100" },
            { mint: "mint2", amount: "200" }
          ],
          outputMint: "outputMint123",
          priorityFee: "fast"
        },
        output: {
          status: "success",
          message: "Successfully merged tokens",
          result: { transaction: "tx_signature" }
        },
        explanation: "Merge multiple tokens into one output token"
      }
    ]
  ],
  schema: import_zod24.z.object({
    inputAssets: import_zod24.z.array(
      import_zod24.z.object({
        mint: import_zod24.z.string(),
        amount: import_zod24.z.string()
      })
    ).describe("Array of input assets to merge"),
    outputMint: import_zod24.z.string().describe("Output token mint address"),
    priorityFee: import_zod24.z.enum(["fast", "turbo", "ultra"]).describe("Transaction priority level")
  }),
  handler: async (agent, input) => {
    try {
      const { inputAssets, outputMint, priorityFee } = input;
      const transactions = await mergeTokens(
        agent,
        inputAssets,
        outputMint,
        priorityFee
      );
      return {
        status: "success",
        transactions,
        message: "Successfully merged tokens"
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to merge tokens: ${error.message}`,
        code: error.code || "MERGE_TOKENS_ERROR"
      };
    }
  }
};
var mergeTokens_default = mergeTokensAction;

// src/solutiofi/actions/spreadToken.ts
var import_zod25 = require("zod");
var spreadTokenAction = {
  name: "SOLUTIOFI_SPREAD_TOKEN",
  description: "Split a token into multiple tokens using SolutioFi",
  similes: [
    "spread token",
    "split token",
    "swap token",
    "spread tokens with solutiofi",
    "swap one token for multiple",
    "buy multiple tokens at once",
    "break token into parts",
    "split token into multiple assets",
    "convert one token into many",
    "swap token into different tokens",
    "allocate token to multiple assets",
    "spread token balance across multiple tokens",
    "swap and distribute token",
    "convert token into smaller portions",
    "exchange one token for multiple",
    "redistribute token into other tokens",
    "convert and spread token balance",
    "swap one asset for multiple tokens"
  ],
  examples: [
    [
      {
        input: {
          inputAsset: { mint: "inputMint", amount: "1000" },
          targetTokens: [
            { mint: "targetMint1", percentage: 60 },
            { mint: "targetMint2", percentage: 40 }
          ],
          priorityFee: "fast"
        },
        output: {
          status: "success",
          message: "Successfully spread token",
          result: { transaction: "tx_signature" }
        },
        explanation: "Split one token into multiple target tokens"
      }
    ]
  ],
  schema: import_zod25.z.object({
    inputAsset: import_zod25.z.object({
      mint: import_zod25.z.string(),
      amount: import_zod25.z.string()
    }).describe("Input asset to spread"),
    targetTokens: import_zod25.z.array(
      import_zod25.z.object({
        mint: import_zod25.z.string(),
        percentage: import_zod25.z.number()
      })
    ).describe("Target tokens with allocation percentages"),
    priorityFee: import_zod25.z.enum(["fast", "turbo", "ultra"]).describe("Transaction priority level")
  }),
  handler: async (agent, input) => {
    try {
      const { inputAsset, targetTokens, priorityFee } = input;
      const result = await spreadToken(
        agent,
        inputAsset,
        targetTokens,
        priorityFee
      );
      return {
        status: "success",
        transactions: result,
        message: "Successfully spread token"
      };
    } catch (error) {
      return {
        status: "error",
        message: `Failed to spread token: ${error.message}`,
        code: error.code || "SPREAD_TOKEN_ERROR"
      };
    }
  }
};
var spreadToken_default = spreadTokenAction;

// src/index.ts
var TokenPlugin = {
  name: "token",
  // Combine all tools
  methods: {
    getTokenDataByAddress,
    getTokenAddressFromTicker,
    fetchPrice,
    stakeWithJup,
    trade,
    getJupiterLimitOrderHistory: getLimitOrderHistory,
    createJupiterLimitOrder: createLimitOrder,
    cancelJupiterLimitOrders: cancelLimitOrders,
    getOpenJupiterLimitOrders: getOpenLimitOrders,
    sendCompressedAirdrop,
    closeEmptyTokenAccounts,
    getTPS,
    get_balance,
    getWalletAddress,
    get_balance_other,
    get_token_balance,
    request_faucet_funds,
    transfer,
    swap,
    launchPumpFunToken,
    fetchPythPrice,
    fetchPythPriceFeedID,
    fetchTokenDetailedReport,
    fetchTokenReportSummary,
    burnTokensUsingSolutiofi: burnTokens,
    closeAccountsUsingSolutiofi: closeAccounts,
    mergeTokensUsingSolutiofi: mergeTokens,
    spreadTokenUsingSolutiofi: spreadToken
  },
  // Combine all actions
  actions: [
    getTokenData_default,
    getTokenDataByTicker_default,
    fetchPrice_default,
    stakeWithJup_default,
    trade_default,
    createLimitOrder_default,
    cancelLimitOrders_default,
    getOpenLimitOrders_default,
    getLimitOrderHistory_default,
    compressedAirdrop_default,
    balance_default,
    tokenBalances_default,
    getTPS_default,
    closeEmptyTokenAccounts_default,
    requestFunds_default,
    transfer_default,
    swap_default,
    launchPumpfunToken_default,
    pythFetchPrice_default,
    rugcheck_default,
    burnTokens_default,
    spreadToken_default,
    closeAccounts_default,
    mergeTokens_default,
    walletAddress_default
  ],
  // Initialize function
  initialize: function(agent) {
    for (const [methodName, method] of Object.entries(this.methods)) {
      if (typeof method === "function") {
        this.methods[methodName] = method.bind(null, agent);
      }
    }
  }
};
var index_default = TokenPlugin;
