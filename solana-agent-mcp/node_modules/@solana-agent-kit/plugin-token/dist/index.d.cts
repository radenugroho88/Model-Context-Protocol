import * as solana_agent_kit from 'solana-agent-kit';
import { SolanaAgentKit as SolanaAgentKit$1, PumpFunTokenOptions, TokenCheck } from 'solana-agent-kit';
import * as _solana_web3_js from '@solana/web3.js';
import { PublicKey, VersionedTransaction, Transaction, Connection, SendOptions, TransactionSignature } from '@solana/web3.js';
import { z } from 'zod';

interface JupiterTokenData {
    address: string;
    name: string;
    symbol: string;
    decimals: number;
    tags: string[];
    logoURI: string;
    daily_volume: number;
    freeze_authority: string | null;
    mint_authority: string | null;
    permanent_delegate: string | null;
    extensions: {
        coingeckoId?: string;
    };
}
interface CreateJupiterOrderRequest {
    maker?: string;
    payer?: string;
    inputMint: string;
    outputMint: string;
    params: {
        makingAmount: string;
        takingAmount: string;
        expiredAt?: string | undefined;
        feeBps?: string;
    };
    computeUnitPrice?: string | "auto";
    referral?: string;
    wrapAndUnwrapSol?: boolean;
}
interface OpenJupiterOrderAccount {
    borrowMakingAmount: string;
    createdAt: string;
    expiredAt: string | null;
    makingAmount: string;
    oriMakingAmount: string;
    oriTakingAmount: string;
    takingAmount: string;
    uniqueId: string;
    updatedAt: string;
    feeAccount: string;
    inputMint: string;
    inputMintReserve: string;
    inputTokenProgram: string;
    maker: string;
    outputMint: string;
    outputTokenProgram: string;
    feeBps: number;
    bump: number;
}
interface OpenJupiterOrderResponse {
    account: OpenJupiterOrderAccount;
    publicKey: string;
}
interface CancelJupiterOrderRequest {
    maker?: string;
    computeUnitPrice?: string | "auto";
    orders?: string[];
}
interface JupiterTrade {
    amount: string;
    price: string;
    timestamp: string;
}
interface JupiterOrderHistoryItem {
    userPubkey: string;
    orderKey: string;
    inputMint: string;
    outputMint: string;
    makingAmount: string;
    takingAmount: string;
    remainingMakingAmount: string;
    remainingTakingAmount: string;
    expiredAt: string | null;
    createdAt: string;
    updatedAt: string;
    status: "Open" | "Completed" | "Cancelled";
    openTx: string;
    closeTx: string;
    programVersion: string;
    trades: JupiterTrade[];
}
interface JupiterOrderHistoryResponse {
    orders: JupiterOrderHistoryItem[];
    hasMoreData: boolean;
    page: number;
}

declare function getTokenDataByAddress(mint: PublicKey): Promise<JupiterTokenData | undefined>;
declare function getTokenAddressFromTicker(ticker: string): Promise<string | null>;

/**
 * Fetch the price of a given token quoted in USDC using Jupiter API
 * @param tokenId The token mint address
 * @returns The price of the token quoted in USDC
 */
declare function fetchPrice(tokenId: PublicKey): Promise<string>;

/**
 * Stake SOL with Jup validator
 * @param agent SolanaAgentKit instance
 * @param amount Amount of SOL to stake
 * @returns Transaction signature
 */
declare function stakeWithJup(agent: SolanaAgentKit$1, amount: number): Promise<string | string[] | VersionedTransaction | VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[]>;

/**
 * Swap tokens using Jupiter Exchange
 * @param agent SolanaAgentKit instance
 * @param outputMint Target token mint address
 * @param inputAmount Amount to swap (in token decimals)
 * @param inputMint Source token mint address (defaults to USDC)
 * @param slippageBps Slippage tolerance in basis points (default: 300 = 3%)
 * @returns Transaction signature
 */
declare function trade(agent: SolanaAgentKit$1, outputMint: PublicKey, inputAmount: number, inputMint?: PublicKey, _slippageBps?: number): Promise<string | string[] | VersionedTransaction | VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[]>;

declare function createLimitOrder(agent: SolanaAgentKit$1, params: CreateJupiterOrderRequest): Promise<{
    signature: string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[];
    order: string;
    success: boolean;
}>;

declare function cancelLimitOrders(agent: SolanaAgentKit$1, params: CancelJupiterOrderRequest): Promise<{
    signatures: string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[];
    success: boolean;
}>;

declare function getOpenLimitOrders(agent: SolanaAgentKit$1): Promise<{
    orders: OpenJupiterOrderResponse[];
    success: boolean;
}>;

declare function getLimitOrderHistory(agent: SolanaAgentKit$1): Promise<{
    history: JupiterOrderHistoryResponse;
    success: boolean;
}>;

/**
 * Send airdrop with ZK Compressed Tokens.
 * @param agent             Agent
 * @param mintAddress       SPL Mint address
 * @param amount            Amount to send per recipient
 * @param decimals          Decimals of the token
 * @param recipients        Recipient wallet addresses (no ATAs)
 * @param priorityFeeInLamports   Priority fee in lamports
 */
declare function sendCompressedAirdrop(agent: SolanaAgentKit$1, mintAddress: PublicKey, amount: number, decimals: number, recipients: PublicKey[], priorityFeeInLamports: number): Promise<string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | Transaction | Transaction[]>;

declare function swap(agent: SolanaAgentKit$1, amount: string, fromChain: string, fromToken: string, toChain: string, toToken: string, dstAddr: string, slippageBps?: "auto" | number): Promise<string>;

/**
 * Launch a token on Pump.fun
 * @param agent - SolanaAgentKit instance
 * @param tokenName - Name of the token
 * @param tokenTicker - Ticker of the token
 * @param description - Description of the token
 * @param imageUrl - URL of the token image
 * @param options - Optional token options (twitter, telegram, website, initialLiquiditySOL, slippageBps, priorityFee)
 * @returns - Signature of the transaction, mint address and metadata URI, if successful, else error
 */
declare function launchPumpFunToken(agent: SolanaAgentKit$1, tokenName: string, tokenTicker: string, description: string, imageUrl: string, options?: PumpFunTokenOptions): Promise<{
    signedTransaction: VersionedTransaction;
    mint: string;
    metadataUri: any;
    signature?: undefined;
} | {
    signature: string;
    mint: string;
    metadataUri: any;
    signedTransaction?: undefined;
}>;

/**
 * Fetch the price feed ID for a given token symbol from Pyth
 * @param tokenSymbol Token symbol
 * @returns Price feed ID
 */
declare function fetchPythPriceFeedID(tokenSymbol: string): Promise<string>;
/**
 * Fetch the price of a given price feed from Pyth
 * @param priceFeedID Price feed ID
 * @returns Latest price value from feed
 *
 * You can find priceFeedIDs here: https://www.pyth.network/developers/price-feed-ids#stable
 */
declare function fetchPythPrice(feedID: string): Promise<string>;

/**
 * Fetches a summary report for a specific token.
 * @async
 * @param {string} mint - The mint address of the token.
 * @returns {Promise<TokenCheck>} The token summary report.
 * @throws {Error} If the API call fails.
 */
declare function fetchTokenReportSummary(mint: string): Promise<TokenCheck>;
/**
 * Fetches a detailed report for a specific token.
 * @async
 * @param {string} mint - The mint address of the token.
 * @returns {Promise<TokenCheck>} The detailed token report.
 * @throws {Error} If the API call fails.
 */
declare function fetchTokenDetailedReport(mint: string): Promise<TokenCheck>;

declare function getTPS(agent: SolanaAgentKit$1): Promise<number>;

/**
 * Request SOL from the Solana faucet (devnet/testnet only)
 * @param agent - SolanaAgentKit instance
 * @returns Transaction signature
 * @throws Error if the request fails or times out
 */
declare function request_faucet_funds(agent: SolanaAgentKit$1): Promise<string>;

/**
 * Close Empty SPL Token accounts of the agent
 * @param agent SolanaAgentKit instance
 * @returns transaction signature and total number of accounts closed
 */
declare function closeEmptyTokenAccounts(agent: SolanaAgentKit$1): Promise<{
    signature: string;
    size: number;
    signedTransaction?: undefined;
} | {
    signedTransaction: Transaction;
    size: number;
    signature?: undefined;
}>;

/**
 * Transfer SOL or SPL tokens to a recipient
 * @param agent SolanaAgentKit instance
 * @param to Recipient's public key
 * @param amount Amount to transfer
 * @param mint Optional mint address for SPL tokens
 * @returns Transaction signature
 */
declare function transfer(agent: SolanaAgentKit$1, to: PublicKey, amount: number, mint?: PublicKey): Promise<string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | Transaction | Transaction[]>;

/**
 * Get the balance of SOL or an SPL token for the agent's wallet
 * @param agent - SolanaAgentKit instance
 * @param token_address - Optional SPL token mint address. If not provided, returns SOL balance
 * @returns Promise resolving to the balance as a number (in UI units) or null if account doesn't exist
 */
declare function get_balance(agent: SolanaAgentKit$1, token_address?: PublicKey): Promise<number>;

/**
 * Get the balance of SOL or an SPL token for the specified wallet address (other than the agent's wallet)
 * @param agent - SolanaAgentKit instance
 * @param wallet_address - Public key of the wallet to check balance for
 * @param token_address - Optional SPL token mint address. If not provided, returns SOL balance
 * @returns Promise resolving to the balance as a number (in UI units) or 0 if account doesn't exist
 */
declare function get_balance_other(agent: SolanaAgentKit$1, wallet_address: PublicKey, token_address?: PublicKey): Promise<number>;

/**
 * Get the token balances of a Solana wallet
 * @param agent - SolanaAgentKit instance
 * @param token_address - Optional SPL token mint address. If not provided, returns SOL balance
 * @returns Promise resolving to the balance as an object containing sol balance and token balances with their respective mints, symbols, names and decimals
 */
declare function get_token_balance(agent: SolanaAgentKit$1, walletAddress?: PublicKey): Promise<{
    sol: number;
    tokens: Array<{
        tokenAddress: string;
        name: string;
        symbol: string;
        balance: number;
        decimals: number;
    }>;
}>;

interface Plugin {
    name: string;
    methods: Record<string, any>;
    actions: Action$1[];
    initialize(agent: SolanaAgentKit): void;
}
interface Config {
    signOnly?: boolean;
    OPENAI_API_KEY?: string;
    PERPLEXITY_API_KEY?: string;
    JUPITER_REFERRAL_ACCOUNT?: string;
    JUPITER_FEE_BPS?: number;
    FLASH_PRIVILEGE?: string;
    FLEXLEND_API_KEY?: string;
    HELIUS_API_KEY?: string;
    PRIORITY_LEVEL?: "medium" | "high" | "veryHigh";
    SOLUTIOFI_API_KEY?: string;
    ETHEREUM_PRIVATE_KEY?: string;
    ALLORA_API_KEY?: string;
    ALLORA_API_URL?: string;
    ALLORA_NETWORK?: string;
    ELFA_AI_API_KEY?: string;
    COINGECKO_PRO_API_KEY?: string;
    COINGECKO_DEMO_API_KEY?: string;
    MESSARI_API_KEY?: string;
}
/**
 * Example of an action with input and output
 */
interface ActionExample$1 {
    input: Record<string, any>;
    output: Record<string, any>;
    explanation: string;
}
/**
 * Handler function type for executing the action
 */
type Handler$1 = (agent: SolanaAgentKit, input: Record<string, any>) => Promise<Record<string, any>>;
/**
 * Main Action interface inspired by ELIZA
 * This interface makes it easier to implement actions across different frameworks
 */
interface Action$1 {
    /**
     * Unique name of the action
     */
    name: string;
    /**
     * Alternative names/phrases that can trigger this action
     */
    similes: string[];
    /**
     * Detailed description of what the action does
     */
    description: string;
    /**
     * Array of example inputs and outputs for the action
     * Each inner array represents a group of related examples
     */
    examples: ActionExample$1[][];
    /**
     * Zod schema for input validation
     */
    schema: z.ZodType<any>;
    /**
     * Function that executes the action
     */
    handler: Handler$1;
}

/**
 * Interface representing a Solana wallet implementation

 * Defines the standard interface for interacting with a Solana wallet,
 * including transaction signing, message signing, and connection status.
 *
 * @interface Wallet
 */
interface BaseWallet {
    /**
     * The public key of the connected wallet
     * @type {PublicKey}
     */
    readonly publicKey: PublicKey;
    /**
     * Signs a single transaction
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed
     * @returns {Promise<T>} Promise resolving to the signed transaction
     */
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;
    /**
     * Signs multiple transactions in batch
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T[]} transactions - Array of transactions to be signed
     * @returns {Promise<T[]>} Promise resolving to an array of signed transactions
     */
    signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]>;
    /**
     * Sends a transaction on chain
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed and sent
     */
    sendTransaction?: <T extends Transaction | VersionedTransaction>(transaction: T) => Promise<string>;
    /**
     * Signs and sends a transaction to the network
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed and sent
     * @param {SendOptions} [options] - Optional transaction send configuration
     * @returns {Promise<{signature: TransactionSignature}>} Promise resolving to the transaction signature
     */
    signAndSendTransaction: <T extends Transaction | VersionedTransaction>(transaction: T, options?: SendOptions) => Promise<{
        signature: TransactionSignature;
    }>;
    /**
     * Signs a message
     * @param message - The message to be signed
     */
    signMessage(message: Uint8Array): Promise<Uint8Array>;
}

/**
 * Defines a type that merges all plugin methods into the `methods` object
 */
type PluginMethods<T> = T extends Plugin ? T["methods"] : Record<string, never>;
/**
 * Main class for interacting with Solana blockchain.
 *
 * @example
 * // Define a plugin
 * const tokenPlugin = {
 *    name: "tokenPlugin",
 *    actions: [],
 *    methods: {
 *      transferToken: (to: string, amount: number) => {
 *        console.log(`Transferring ${amount} to ${to}`);
 *      },
 *    },
 *    initialize: (agent: any) => {},
 * };
 *
 * @example
 * // Create SolanaAgentKit instance
 * const agent = new SolanaAgentKit({
 *  signTransaction: async (tx) => {},
 *  signAllTransactions: async (txs) => {},
 *  sendTransaction: async (tx) => {},
 *  publicKey: "SomePublicKey",
 * }, "<rpcUrl>", {});
 *
 * @example
 * // Add plugin
 * const agentWithPlugins = agent.use(tokenPlugin);
 *
 * @example
 * // Use plugin method
 * agentWithPlugins.methods.transferToken("SomePublicKey", 100);
 */
declare class SolanaAgentKit<TPlugins = Record<string, never>> {
    connection: Connection;
    config: Config;
    wallet: BaseWallet;
    private plugins;
    methods: TPlugins;
    actions: Action$1[];
    constructor(wallet: BaseWallet, rpc_url: string, config: Config);
    /**
     * Adds a plugin and registers its methods inside `methods`
     */
    use<P extends Plugin>(plugin: P): SolanaAgentKit<TPlugins & PluginMethods<P>>;
}

declare function getWalletAddress(agent: SolanaAgentKit): string;

interface InputAssetStruct {
    /** The mint address of the asset. */
    mint: string;
    /** The input amount for the transaction. */
    inputAmount: string;
    /** The slippage tolerance for the transaction. */
    slippage: string;
    /** Whether to allow only direct routes for swap. */
    onlyDirectRoutes: boolean;
}
/** Represents target token data for transactions. */
interface TargetTokenStruct {
    /** The mint address of the token. */
    mint: string;
    /** The percentage allocation for the token (1-100%). */
    percentage: number;
}
type PriorityFee = "fast" | "turbo" | "ultra";

/**
 * Close token accounts
 * @param agent SolanaAgentKit instance
 * @param mints Array of mint addresses to close
 */
declare function closeAccounts(agent: SolanaAgentKit$1, mints: string[]): Promise<(string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[])[]>;
/**
 * Burns tokens using SolutioFi
 * @param agent SolanaAgentKit instance
 * @param mints Array of mint addresses for the tokens to burn
 * @returns Array of versioned transactions
 */
declare function burnTokens(agent: SolanaAgentKit$1, mints: string[]): Promise<(string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[])[]>;
/**
 * Merge multiple tokens into one
 * @param agent SolanaAgentKit instance
 * @param inputAssets Array of input assets to merge
 * @param outputMint Output token mint address
 * @param priorityFee Transaction priority level
 */
declare function mergeTokens(agent: SolanaAgentKit$1, inputAssets: InputAssetStruct[], outputMint: string, priorityFee: PriorityFee): Promise<(string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[])[]>;
/**
 * Split a token into multiple tokens
 * @param agent SolanaAgentKit instance
 * @param inputAsset Input asset to spread
 * @param targetTokens Array of target tokens and their allocations
 * @param priorityFee Transaction priority level
 */
declare function spreadToken(agent: SolanaAgentKit$1, inputAsset: InputAssetStruct, targetTokens: TargetTokenStruct[], priorityFee: PriorityFee): Promise<(string | string[] | _solana_web3_js.VersionedTransaction | _solana_web3_js.VersionedTransaction[] | _solana_web3_js.Transaction | _solana_web3_js.Transaction[])[]>;

declare const TokenPlugin: {
    name: string;
    methods: {
        getTokenDataByAddress: typeof getTokenDataByAddress;
        getTokenAddressFromTicker: typeof getTokenAddressFromTicker;
        fetchPrice: typeof fetchPrice;
        stakeWithJup: typeof stakeWithJup;
        trade: typeof trade;
        getJupiterLimitOrderHistory: typeof getLimitOrderHistory;
        createJupiterLimitOrder: typeof createLimitOrder;
        cancelJupiterLimitOrders: typeof cancelLimitOrders;
        getOpenJupiterLimitOrders: typeof getOpenLimitOrders;
        sendCompressedAirdrop: typeof sendCompressedAirdrop;
        closeEmptyTokenAccounts: typeof closeEmptyTokenAccounts;
        getTPS: typeof getTPS;
        get_balance: typeof get_balance;
        getWalletAddress: typeof getWalletAddress;
        get_balance_other: typeof get_balance_other;
        get_token_balance: typeof get_token_balance;
        request_faucet_funds: typeof request_faucet_funds;
        transfer: typeof transfer;
        swap: typeof swap;
        launchPumpFunToken: typeof launchPumpFunToken;
        fetchPythPrice: typeof fetchPythPrice;
        fetchPythPriceFeedID: typeof fetchPythPriceFeedID;
        fetchTokenDetailedReport: typeof fetchTokenDetailedReport;
        fetchTokenReportSummary: typeof fetchTokenReportSummary;
        burnTokensUsingSolutiofi: typeof burnTokens;
        closeAccountsUsingSolutiofi: typeof closeAccounts;
        mergeTokensUsingSolutiofi: typeof mergeTokens;
        spreadTokenUsingSolutiofi: typeof spreadToken;
    };
    actions: solana_agent_kit.Action[];
    initialize: (agent: SolanaAgentKit$1) => void;
};

export { TokenPlugin as default };
