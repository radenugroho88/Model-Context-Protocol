import { TransactionInstruction, Keypair, PublicKey, Transaction, VersionedTransaction, SendOptions, TransactionSignature, Connection, ConfirmOptions } from '@solana/web3.js';
import * as zod from 'zod';
import { z } from 'zod';
import * as _langchain_core_tools from '@langchain/core/tools';
import { CoreTool } from 'ai';

interface Plugin {
    name: string;
    methods: Record<string, any>;
    actions: Action$1[];
    initialize(agent: SolanaAgentKit): void;
}
interface Config {
    signOnly?: boolean;
    OPENAI_API_KEY?: string;
    PERPLEXITY_API_KEY?: string;
    JUPITER_REFERRAL_ACCOUNT?: string;
    JUPITER_FEE_BPS?: number;
    FLASH_PRIVILEGE?: string;
    FLEXLEND_API_KEY?: string;
    HELIUS_API_KEY?: string;
    PRIORITY_LEVEL?: "medium" | "high" | "veryHigh";
    SOLUTIOFI_API_KEY?: string;
    ETHEREUM_PRIVATE_KEY?: string;
    ALLORA_API_KEY?: string;
    ALLORA_API_URL?: string;
    ALLORA_NETWORK?: string;
    ELFA_AI_API_KEY?: string;
    COINGECKO_PRO_API_KEY?: string;
    COINGECKO_DEMO_API_KEY?: string;
    MESSARI_API_KEY?: string;
}
interface PumpFunTokenOptions {
    twitter?: string;
    telegram?: string;
    website?: string;
    initialLiquiditySOL?: number;
    slippageBps?: number;
    priorityFee?: number;
}
interface PumpfunLaunchResponse {
    signature: string;
    mint: string;
    metadataUri?: string;
    error?: string;
}
/**
 * Lulo Account Details response format
 */
interface LuloAccountDetailsResponse {
    totalValue: number;
    interestEarned: number;
    realtimeApy: number;
    settings: {
        owner: string;
        allowedProtocols: string | null;
        homebase: string | null;
        minimumRate: string;
    };
}
interface FetchPriceResponse {
    status: "success" | "error";
    tokenId?: string;
    priceInUSDC?: string;
    message?: string;
    code?: string;
}
interface PythFetchPriceResponse {
    status: "success" | "error";
    tokenSymbol: string;
    priceFeedID?: string;
    price?: string;
    message?: string;
    code?: string;
}
/**
 * Example of an action with input and output
 */
interface ActionExample$1 {
    input: Record<string, any>;
    output: Record<string, any>;
    explanation: string;
}
/**
 * Handler function type for executing the action
 */
type Handler$1 = (agent: SolanaAgentKit, input: Record<string, any>) => Promise<Record<string, any>>;
/**
 * Main Action interface inspired by ELIZA
 * This interface makes it easier to implement actions across different frameworks
 */
interface Action$1 {
    /**
     * Unique name of the action
     */
    name: string;
    /**
     * Alternative names/phrases that can trigger this action
     */
    similes: string[];
    /**
     * Detailed description of what the action does
     */
    description: string;
    /**
     * Array of example inputs and outputs for the action
     * Each inner array represents a group of related examples
     */
    examples: ActionExample$1[][];
    /**
     * Zod schema for input validation
     */
    schema: z.ZodType<any>;
    /**
     * Function that executes the action
     */
    handler: Handler$1;
}
interface TokenCheck {
    tokenProgram: string;
    tokenType: string;
    risks: Array<{
        name: string;
        level: string;
        description: string;
        score: number;
    }>;
    score: number;
}
interface PythPriceFeedIDItem {
    id: string;
    attributes: {
        asset_type: string;
        base: string;
    };
}
interface PythPriceItem {
    binary: {
        data: string[];
        encoding: string;
    };
    parsed: [
        Array<{
            id: string;
            price: {
                price: string;
                conf: string;
                expo: number;
                publish_time: number;
            };
            ema_price: {
                price: string;
                conf: string;
                expo: number;
                publish_time: number;
            };
            metadata: {
                slot: number;
                proof_available_time: number;
                prev_publish_time: number;
            };
        }>
    ];
}
interface HeliusWebhookResponse {
    webhookURL: string;
    webhookID: string;
}
interface HeliusWebhookIdResponse {
    wallet: string;
    webhookURL: string;
    transactionTypes: string[];
    accountAddresses: string[];
    webhookType: string;
}
interface PriorityFeeResponse {
    jsonrpc: string;
    id: string;
    method: string;
    params: Array<{
        transaction: string;
        options: {
            priorityLevel: string;
        };
    }>;
}

declare const feeTiers: {
    min: number;
    mid: number;
    max: number;
};
/**
 * Get priority fees for the current block
 * @param connection - Solana RPC connection
 * @returns Priority fees statistics and instructions for different fee levels
 */
declare function getComputeBudgetInstructions(agent: SolanaAgentKit, instructions: TransactionInstruction[], feeTier: keyof typeof feeTiers): Promise<{
    computeBudgetLimitInstruction: TransactionInstruction;
    computeBudgetPriorityFeeInstructions: TransactionInstruction;
}>;
/**
 * Send a transaction with priority fees
 * @param agent - SolanaAgentKit instance
 * @param tx - Transaction to send
 * @returns Transaction ID
 */
declare function sendTx(agent: SolanaAgentKit, instructions: TransactionInstruction[], otherKeypairs?: Keypair[], feeTier?: keyof typeof feeTiers): Promise<string>;

/**
 * Interface representing a Solana wallet implementation

 * Defines the standard interface for interacting with a Solana wallet,
 * including transaction signing, message signing, and connection status.
 *
 * @interface Wallet
 */
interface BaseWallet {
    /**
     * The public key of the connected wallet
     * @type {PublicKey}
     */
    readonly publicKey: PublicKey;
    /**
     * Signs a single transaction
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed
     * @returns {Promise<T>} Promise resolving to the signed transaction
     */
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;
    /**
     * Signs multiple transactions in batch
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T[]} transactions - Array of transactions to be signed
     * @returns {Promise<T[]>} Promise resolving to an array of signed transactions
     */
    signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]>;
    /**
     * Sends a transaction on chain
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed and sent
     */
    sendTransaction?: <T extends Transaction | VersionedTransaction>(transaction: T) => Promise<string>;
    /**
     * Signs and sends a transaction to the network
     * @template T - Transaction type (Transaction or VersionedTransaction)
     * @param {T} transaction - The transaction to be signed and sent
     * @param {SendOptions} [options] - Optional transaction send configuration
     * @returns {Promise<{signature: TransactionSignature}>} Promise resolving to the transaction signature
     */
    signAndSendTransaction: <T extends Transaction | VersionedTransaction>(transaction: T, options?: SendOptions) => Promise<{
        signature: TransactionSignature;
    }>;
    /**
     * Signs a message
     * @param message - The message to be signed
     */
    signMessage(message: Uint8Array): Promise<Uint8Array>;
}
declare function signOrSendTX(agent: SolanaAgentKit, instructionsOrTransaction: TransactionInstruction[] | Transaction | VersionedTransaction | Transaction[] | VersionedTransaction[], otherKeypairs?: Keypair[], feeTier?: keyof typeof feeTiers): Promise<string | string[] | Transaction | VersionedTransaction | Transaction[] | VersionedTransaction[]>;

/**
 * Defines a type that merges all plugin methods into the `methods` object
 */
type PluginMethods<T> = T extends Plugin ? T["methods"] : Record<string, never>;
/**
 * Main class for interacting with Solana blockchain.
 *
 * @example
 * // Define a plugin
 * const tokenPlugin = {
 *    name: "tokenPlugin",
 *    actions: [],
 *    methods: {
 *      transferToken: (to: string, amount: number) => {
 *        console.log(`Transferring ${amount} to ${to}`);
 *      },
 *    },
 *    initialize: (agent: any) => {},
 * };
 *
 * @example
 * // Create SolanaAgentKit instance
 * const agent = new SolanaAgentKit({
 *  signTransaction: async (tx) => {},
 *  signAllTransactions: async (txs) => {},
 *  sendTransaction: async (tx) => {},
 *  publicKey: "SomePublicKey",
 * }, "<rpcUrl>", {});
 *
 * @example
 * // Add plugin
 * const agentWithPlugins = agent.use(tokenPlugin);
 *
 * @example
 * // Use plugin method
 * agentWithPlugins.methods.transferToken("SomePublicKey", 100);
 */
declare class SolanaAgentKit<TPlugins = Record<string, never>> {
    connection: Connection;
    config: Config;
    wallet: BaseWallet;
    private plugins;
    methods: TPlugins;
    actions: Action$1[];
    constructor(wallet: BaseWallet, rpc_url: string, config: Config);
    /**
     * Adds a plugin and registers its methods inside `methods`
     */
    use<P extends Plugin>(plugin: P): SolanaAgentKit<TPlugins & PluginMethods<P>>;
}

declare function createLangchainTools(solanaAgentKit: SolanaAgentKit, actions: Action$1[]): _langchain_core_tools.DynamicStructuredTool<zod.ZodObject<zod.ZodRawShape, zod.UnknownKeysParam, zod.ZodTypeAny, {
    [x: string]: any;
}, {
    [x: string]: any;
}>, {
    [x: string]: any;
}, {
    [x: string]: any;
}>[];

/**
 * Example of an action with input and output
 */
interface ActionExample {
    input: Record<string, any>;
    output: Record<string, any>;
    explanation: string;
}
/**
 * Handler function type for executing the action
 */
type Handler = (agent: SolanaAgentKit, input: Record<string, any>) => Promise<Record<string, any>>;
/**
 * Main Action interface inspired by ELIZA
 * This interface makes it easier to implement actions across different frameworks
 */
interface Action {
    /**
     * Unique name of the action
     */
    name: string;
    /**
     * Alternative names/phrases that can trigger this action
     */
    similes: string[];
    /**
     * Detailed description of what the action does
     */
    description: string;
    /**
     * Array of example inputs and outputs for the action
     * Each inner array represents a group of related examples
     */
    examples: ActionExample[][];
    /**
     * Zod schema for input validation
     */
    schema: z.ZodType<any>;
    /**
     * Function that executes the action
     */
    handler: Handler;
}

declare function createSolanaTools(solanaAgentKit: SolanaAgentKit, actions: Action[]): Record<string, CoreTool>;

/**
 * Execute an action with the given input
 */
declare function executeAction(action: Action$1, agent: SolanaAgentKit, input: Record<string, any>): Promise<Record<string, any>>;
/**
 * Get examples for an action
 */
declare function getActionExamples(action: Action$1): string;

/**
 * Check if a transaction object is a VersionedTransaction or not
 *
 * @param tx
 * @returns bool
 */
declare const isVersionedTransaction: (tx: Transaction | VersionedTransaction) => tx is VersionedTransaction;
/**
 * A wallet implementation using a Keypair for signing transactions
 */
declare class KeypairWallet implements BaseWallet {
    publicKey: PublicKey;
    private payer;
    rpcUrl: string;
    /**
     * Constructs a KeypairWallet with a given Keypair
     * @param keypair - The Keypair to use for signing transactions
     */
    constructor(keypair: Keypair, rpcUrl: string);
    defaultOptions: ConfirmOptions;
    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;
    signAllTransactions<T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]>;
    sendTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<string>;
    signMessage(message: Uint8Array): Promise<Uint8Array>;
    signAndSendTransaction<T extends Transaction | VersionedTransaction>(transaction: T, options?: SendOptions): Promise<{
        signature: TransactionSignature;
    }>;
}

export { type Action$1 as Action, type ActionExample$1 as ActionExample, type BaseWallet, type Config, type FetchPriceResponse, type Handler$1 as Handler, type HeliusWebhookIdResponse, type HeliusWebhookResponse, KeypairWallet, type LuloAccountDetailsResponse, type Plugin, type PriorityFeeResponse, type PumpFunTokenOptions, type PumpfunLaunchResponse, type PythFetchPriceResponse, type PythPriceFeedIDItem, type PythPriceItem, SolanaAgentKit, type TokenCheck, createLangchainTools, createSolanaTools as createVercelAITools, executeAction, feeTiers, getActionExamples, getComputeBudgetInstructions, isVersionedTransaction, sendTx, signOrSendTX };
