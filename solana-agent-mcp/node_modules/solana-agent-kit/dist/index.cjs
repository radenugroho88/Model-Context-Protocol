"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  KeypairWallet: () => KeypairWallet,
  SolanaAgentKit: () => SolanaAgentKit,
  createLangchainTools: () => createLangchainTools,
  createVercelAITools: () => createSolanaTools,
  executeAction: () => executeAction,
  feeTiers: () => feeTiers,
  getActionExamples: () => getActionExamples,
  getComputeBudgetInstructions: () => getComputeBudgetInstructions,
  isVersionedTransaction: () => isVersionedTransaction,
  sendTx: () => sendTx,
  signOrSendTX: () => signOrSendTX
});
module.exports = __toCommonJS(index_exports);

// src/agent/index.ts
var import_web3 = require("@solana/web3.js");
var SolanaAgentKit = class {
  connection;
  config;
  wallet;
  plugins = /* @__PURE__ */ new Map();
  methods = {};
  actions = [];
  constructor(wallet, rpc_url, config) {
    this.connection = new import_web3.Connection(rpc_url);
    this.wallet = wallet;
    this.config = config;
  }
  /**
   * Adds a plugin and registers its methods inside `methods`
   */
  use(plugin) {
    if (this.plugins.has(plugin.name)) {
      return this;
    }
    plugin.initialize(this);
    for (const [methodName, method] of Object.entries(plugin.methods)) {
      if (this.methods[methodName]) {
        throw new Error(`Method ${methodName} already exists in methods`);
      }
      this.methods[methodName] = method.bind(plugin);
    }
    for (const action of plugin.actions) {
      this.actions.push(action);
    }
    this.plugins.set(plugin.name, plugin);
    return this;
  }
};

// src/langchain/index.ts
var import_tools = require("@langchain/core/tools");

// src/utils/zod.ts
var import_zod = require("zod");
function transformToZodObject(schema) {
  if (schema instanceof import_zod.ZodObject) {
    return schema;
  }
  throw new Error(
    `The provided schema is not a ZodObject: ${JSON.stringify(schema)}`
  );
}

// src/langchain/index.ts
function createLangchainTools(solanaAgentKit, actions) {
  if (actions.length > 128) {
    console.warn(
      `Too many actions provided. Only a maximum of 128 actions allowed. You provided ${actions.length}, the last ${actions.length - 128} will be ignored.`
    );
  }
  const tools = actions.slice(0, 127).map((action) => {
    const toolInstance = (0, import_tools.tool)(
      async (inputs) => JSON.stringify(await action.handler(solanaAgentKit, inputs)),
      {
        name: action.name,
        description: `
      ${action.description}

      Similes: ${action.similes.map(
          (simile) => `
        ${simile}
      `
        )}

      Examples: ${action.examples.map(
          (example) => `
        Input: ${JSON.stringify(example[0].input)}
        Output: ${JSON.stringify(example[0].output)}
        Explanation: ${example[0].explanation}
      `
        )}`,
        // convert action.schema from ZodType to ZodObject
        schema: transformToZodObject(action.schema)
      }
    );
    return toolInstance;
  });
  return tools;
}

// src/vercel-ai/index.ts
var import_ai = require("ai");

// src/utils/actionExecutor.ts
async function executeAction(action, agent, input) {
  try {
    const validatedInput = action.schema.parse(input);
    const result = await action.handler(agent, validatedInput);
    return {
      status: "success",
      ...result
    };
  } catch (error) {
    if (error.errors) {
      return {
        status: "error",
        message: "Validation error",
        details: error.errors,
        code: "VALIDATION_ERROR"
      };
    }
    return {
      status: "error",
      message: error.message,
      code: error.code || "EXECUTION_ERROR"
    };
  }
}
function getActionExamples(action) {
  return action.examples.flat().map((example) => {
    return `Input: ${JSON.stringify(example.input, null, 2)}
Output: ${JSON.stringify(example.output, null, 2)}
Explanation: ${example.explanation}
---`;
  }).join("\n");
}

// src/vercel-ai/index.ts
function createSolanaTools(solanaAgentKit, actions) {
  const tools = {};
  if (actions.length > 128) {
    console.warn(
      `Too many actions provided. Only a maximum of 128 actions allowed. You provided ${actions.length}, the last ${actions.length - 128} will be ignored.`
    );
  }
  for (const [index, action] of actions.slice(0, 127).entries()) {
    tools[index.toString()] = (0, import_ai.tool)({
      id: action.name,
      description: `
      ${action.description}

      Similes: ${action.similes.map(
        (simile) => `
        ${simile}
      `
      )}

      Examples: ${action.examples.map(
        (example) => `
        Input: ${JSON.stringify(example[0].input)}
        Output: ${JSON.stringify(example[0].output)}
        Explanation: ${example[0].explanation}
      `
      )}
      `.slice(0, 1023),
      parameters: action.schema,
      execute: async (params) => await executeAction(action, solanaAgentKit, params)
    });
  }
  return tools;
}

// src/types/wallet.ts
var import_web34 = require("@solana/web3.js");

// src/utils/send_tx.ts
var import_web32 = require("@solana/web3.js");
var import_web33 = require("@solana/web3.js");
var import_bs58 = __toESM(require("bs58"), 1);
var feeTiers = {
  min: 0.01,
  mid: 0.5,
  max: 0.95
};
async function getComputeBudgetInstructions(agent, instructions, feeTier) {
  const { blockhash, lastValidBlockHeight } = await agent.connection.getLatestBlockhash();
  const messageV0 = new import_web32.TransactionMessage({
    payerKey: agent.wallet.publicKey,
    recentBlockhash: blockhash,
    instructions
  }).compileToV0Message();
  const transaction = new import_web32.VersionedTransaction(messageV0);
  const simulatedTx = await agent.connection.simulateTransaction(transaction);
  const estimatedComputeUnits = simulatedTx.value.unitsConsumed;
  const safeComputeUnits = Math.ceil(
    estimatedComputeUnits ? Math.max(estimatedComputeUnits + 1e5, estimatedComputeUnits * 1.2) : 2e5
  );
  const computeBudgetLimitInstruction = import_web33.ComputeBudgetProgram.setComputeUnitLimit({
    units: safeComputeUnits
  });
  let priorityFee;
  if (agent.config?.HELIUS_API_KEY) {
    const legacyTransaction = new import_web32.Transaction();
    legacyTransaction.recentBlockhash = blockhash;
    legacyTransaction.lastValidBlockHeight = lastValidBlockHeight;
    legacyTransaction.feePayer = agent.wallet.publicKey;
    legacyTransaction.add(computeBudgetLimitInstruction, ...instructions);
    const signedTransaction = await agent.wallet.signTransaction(legacyTransaction);
    const response = await fetch(
      `https://mainnet.helius-rpc.com/?api-key=${agent.config?.HELIUS_API_KEY}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [
            {
              transaction: import_bs58.default.encode(
                signedTransaction.serialize()
              ),
              options: {
                priorityLevel: feeTier === "min" ? "Min" : feeTier === "mid" ? "Medium" : "High"
              }
            }
          ]
        })
      }
    );
    const data = await response.json();
    if (data.error) {
      throw new Error("Error fetching priority fee from Helius API");
    }
    priorityFee = data.result.priorityFeeEstimate;
  } else {
    priorityFee = await agent.connection.getRecentPrioritizationFees().then(
      (fees) => fees.sort((a, b) => a.prioritizationFee - b.prioritizationFee)[Math.floor(fees.length * feeTiers[feeTier])].prioritizationFee
    );
  }
  const computeBudgetPriorityFeeInstructions = import_web33.ComputeBudgetProgram.setComputeUnitPrice({
    microLamports: priorityFee
  });
  return {
    computeBudgetLimitInstruction,
    computeBudgetPriorityFeeInstructions
  };
}
async function sendTx(agent, instructions, otherKeypairs, feeTier) {
  const ixComputeBudget = await getComputeBudgetInstructions(
    agent,
    instructions,
    feeTier ?? "mid"
  );
  const allInstructions = [
    ixComputeBudget.computeBudgetLimitInstruction,
    ixComputeBudget.computeBudgetPriorityFeeInstructions,
    ...instructions
  ];
  const { blockhash } = await agent.connection.getLatestBlockhash();
  const messageV0 = new import_web32.TransactionMessage({
    payerKey: agent.wallet.publicKey,
    recentBlockhash: blockhash,
    instructions: allInstructions
  }).compileToV0Message();
  const transaction = new import_web32.VersionedTransaction(messageV0);
  transaction.sign([...otherKeypairs ?? []]);
  const signedTransaction = await agent.wallet.signTransaction(transaction);
  const timeoutMs = 9e4;
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    const transactionStartTime = Date.now();
    const signature = await agent.connection.sendTransaction(
      signedTransaction,
      {
        maxRetries: 0,
        skipPreflight: false
      }
    );
    const statuses = await agent.connection.getSignatureStatuses([signature]);
    if (statuses.value[0]) {
      if (!statuses.value[0].err) {
        return signature;
      }
      throw new Error(
        `Transaction failed: ${statuses.value[0].err.toString()}`
      );
    }
    const elapsedTime = Date.now() - transactionStartTime;
    const remainingTime = Math.max(0, 1e3 - elapsedTime);
    if (remainingTime > 0) {
      await new Promise((resolve) => setTimeout(resolve, remainingTime));
    }
  }
  throw new Error("Transaction timeout");
}

// src/types/wallet.ts
async function signOrSendTX(agent, instructionsOrTransaction, otherKeypairs, feeTier) {
  if (Array.isArray(instructionsOrTransaction) && (instructionsOrTransaction[0] instanceof import_web34.Transaction || instructionsOrTransaction[0] instanceof import_web34.VersionedTransaction)) {
    if (agent.config.signOnly) {
      return await agent.wallet.signAllTransactions(
        instructionsOrTransaction
      );
    }
    const txSigs = [];
    for (const tx of instructionsOrTransaction) {
      if (agent.wallet.signAndSendTransaction) {
        const { signature } = await agent.wallet.signAndSendTransaction(
          tx
        );
        txSigs.push(signature);
      }
      throw new Error(
        "Wallet does not support signAndSendTransaction please implement it manually or use the signOnly option"
      );
    }
    return txSigs;
  }
  if (instructionsOrTransaction instanceof import_web34.Transaction || instructionsOrTransaction instanceof import_web34.VersionedTransaction) {
    if (agent.config.signOnly) {
      return await agent.wallet.signTransaction(instructionsOrTransaction);
    }
    if (!agent.wallet.signAndSendTransaction) {
      throw new Error(
        "Wallet does not support signAndSendTransaction please implement it manually or use the signOnly option"
      );
    }
    return (await agent.wallet.signAndSendTransaction(instructionsOrTransaction)).signature;
  }
  const ixComputeBudget = await getComputeBudgetInstructions(
    agent,
    instructionsOrTransaction,
    feeTier ?? "mid"
  );
  const allInstructions = [
    ixComputeBudget.computeBudgetLimitInstruction,
    ixComputeBudget.computeBudgetPriorityFeeInstructions,
    ...instructionsOrTransaction
  ];
  const { blockhash } = await agent.connection.getLatestBlockhash();
  const messageV0 = new import_web34.TransactionMessage({
    payerKey: agent.wallet.publicKey,
    recentBlockhash: blockhash,
    instructions: allInstructions
  }).compileToV0Message();
  const transaction = new import_web34.VersionedTransaction(messageV0);
  transaction.sign([...otherKeypairs ?? []]);
  const signedTransaction = await agent.wallet.signTransaction(transaction);
  if (agent.config.signOnly) {
    return signedTransaction;
  }
  return sendTx(
    agent,
    instructionsOrTransaction,
    otherKeypairs,
    feeTier
  );
}

// src/utils/keypairWallet.ts
var import_web35 = require("@solana/web3.js");
var import_tweetnacl = __toESM(require("tweetnacl"), 1);
var isVersionedTransaction = (tx) => {
  return "version" in tx;
};
var KeypairWallet = class {
  publicKey;
  payer;
  rpcUrl;
  /**
   * Constructs a KeypairWallet with a given Keypair
   * @param keypair - The Keypair to use for signing transactions
   */
  constructor(keypair, rpcUrl) {
    this.publicKey = keypair.publicKey;
    this.payer = keypair;
    this.rpcUrl = rpcUrl;
  }
  defaultOptions = {
    preflightCommitment: "processed",
    commitment: "processed"
  };
  async signTransaction(transaction) {
    if (isVersionedTransaction(transaction)) {
      transaction.sign([this.payer]);
    } else {
      transaction.partialSign(this.payer);
    }
    return transaction;
  }
  async signAllTransactions(txs) {
    return txs.map((t) => {
      if (isVersionedTransaction(t)) {
        t.sign([this.payer]);
      } else {
        t.partialSign(this.payer);
      }
      return t;
    });
  }
  async sendTransaction(transaction) {
    const connection = new import_web35.Connection(this.rpcUrl);
    if (transaction instanceof import_web35.VersionedTransaction) {
      transaction.sign([this.payer]);
    } else {
      transaction.partialSign(this.payer);
    }
    return await connection.sendRawTransaction(transaction.serialize());
  }
  async signMessage(message) {
    const signature = import_tweetnacl.default.sign.detached(message, this.payer.secretKey);
    return signature;
  }
  async signAndSendTransaction(transaction, options) {
    const connection = new import_web35.Connection(this.rpcUrl);
    if (transaction instanceof import_web35.VersionedTransaction) {
      transaction.sign([this.payer]);
    } else {
      transaction.partialSign(this.payer);
    }
    const signature = await connection.sendRawTransaction(
      transaction.serialize(),
      options
    );
    return { signature };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KeypairWallet,
  SolanaAgentKit,
  createLangchainTools,
  createVercelAITools,
  executeAction,
  feeTiers,
  getActionExamples,
  getComputeBudgetInstructions,
  isVersionedTransaction,
  sendTx,
  signOrSendTX
});
