import * as _solana_web3_js from '@solana/web3.js';
import { PublicKey, Connection, Commitment, Keypair, TransactionInstruction, AddressLookupTableAccount, VersionedTransaction, ConfirmOptions, TransactionSignature, RpcResponseAndContext, SignatureResult, Signer, DataSlice, MemcmpFilter, ConnectionConfig, ParsedTransactionWithMeta, AccountMeta } from '@solana/web3.js';
import { Buffer as Buffer$1 } from 'buffer';
import { Struct } from 'superstruct';
import BN from 'bn.js';
import * as buffer_layout from 'buffer-layout';
import { Layout } from '@coral-xyz/borsh';

/**
 * bignumber with <254-bit max size. Anchor serialization doesn't support native
 * bigint yet, so we wrap BN. This wrapper has simple base10 encoding which is
 * needed for zk circuit compat, in addition to the base58 encoding that users
 * are used to from working with the web3.js PublicKey type.
 */
type BN254 = BN;
declare const bn: (number: string | number | BN | Buffer$1 | Uint8Array | number[], base?: number | "hex" | undefined, endian?: BN.Endianness | undefined) => BN;
/** Create a bigint instance with <254-bit max size and base58 capabilities */
declare const createBN254: (number: string | number | BN | Buffer$1 | Uint8Array | number[], base?: number | "hex" | "base58" | undefined) => BN254;
/** Convert <254-bit bigint to Base58 string.  */
declare function encodeBN254toBase58(bigintNumber: BN): string;

declare function deriveAddressSeed(seeds: Uint8Array[], programId: PublicKey): Uint8Array;
/**
 * Derive an address for a compressed account from a seed and an address Merkle
 * tree public key.
 *
 * @param seed                     Seed to derive the address from
 * @param addressMerkleTreePubkey  Merkle tree public key. Defaults to
 *                                 defaultTestStateTreeAccounts().addressTree
 * @returns                        Derived address
 */
declare function deriveAddress(seed: Uint8Array, addressMerkleTreePubkey?: PublicKey): PublicKey;
interface NewAddressParams {
    /**
     * Seed for the compressed account. Must be seed used to derive
     * newAccountAddress
     */
    seed: Uint8Array;
    /**
     * Recent state root index of the address tree. The expiry is tied to the
     * validity proof.
     */
    addressMerkleTreeRootIndex: number;
    /**
     * Address tree pubkey. Must be base pubkey used to derive new address
     */
    addressMerkleTreePubkey: PublicKey;
    /**
     * Address space queue pubkey. Associated with the state tree.
     */
    addressQueuePubkey: PublicKey;
}
interface NewAddressParamsPacked {
    /**
     * Seed for the compressed account. Must be seed used to derive
     * newAccountAddress
     */
    seed: number[];
    /**
     * Recent state root index of the address tree. The expiry is tied to the
     * validity proof.
     */
    addressMerkleTreeRootIndex: number;
    /**
     * Index of the address merkle tree account in the remaining accounts array
     */
    addressMerkleTreeAccountIndex: number;
    /**
     * Index of the address queue account in the remaining accounts array
     */
    addressQueueAccountIndex: number;
}
/**
 * Packs new address params for instruction data in TypeScript clients
 *
 * @param newAddressParams      New address params
 * @param remainingAccounts     Remaining accounts
 * @returns                     Packed new address params
 */
declare function packNewAddressParams(newAddressParams: NewAddressParams[], remainingAccounts: PublicKey[]): {
    newAddressParamsPacked: NewAddressParamsPacked[];
    remainingAccounts: PublicKey[];
};

declare function airdropSol({ connection, lamports, recipientPublicKey, }: {
    connection: Connection;
    lamports: number;
    recipientPublicKey: PublicKey;
}): Promise<string>;
declare function confirmTransaction(connection: Connection, signature: string, confirmation?: Commitment): Promise<_solana_web3_js.RpcResponseAndContext<_solana_web3_js.SignatureResult>>;

declare function byteArrayToKeypair(byteArray: number[]): Keypair;
/**
 * @internal
 * convert BN to hex with '0x' prefix
 */
declare function toHex(bn: BN): string;
declare const toArray: <T>(value: T | T[]) => T[];
declare const bufToDecStr: (buf: Buffer$1) => string;
declare function isSmallerThanBn254FieldSizeBe(bytes: Buffer$1): boolean;
declare const toCamelCase: (object: any) => any;
/**
/**
 * Hash the provided `bytes` with Keccak256 and ensure the result fits in the
 * BN254 prime field by repeatedly hashing the inputs with various "bump seeds"
 * and truncating the resulting hash to 31 bytes.
 *
 * @deprecated Use `hashvToBn254FieldSizeBe` instead.
 */
declare function hashToBn254FieldSizeBe(bytes: Buffer$1): [Buffer$1, number] | null;
/**
 * Hash the provided `bytes` with Keccak256 and ensure that the result fits in
 * the BN254 prime field by truncating the resulting hash to 31 bytes.
 *
 * @param bytes Input bytes
 *
 * @returns     Hash digest
 */
declare function hashvToBn254FieldSizeBe(bytes: Uint8Array[]): Uint8Array;
/** Mutates array in place */
declare function pushUniqueItems<T>(items: T[], map: T[]): void;

interface GnarkProofJson {
    ar: string[];
    bs: string[][];
    krs: string[];
}
type ProofABC = {
    a: Uint8Array;
    b: Uint8Array;
    c: Uint8Array;
};
declare const placeholderValidityProof: () => {
    a: number[];
    b: number[];
    c: number[];
};
declare const checkValidityProofShape: (proof: CompressedProof) => void;
declare function proofFromJsonStruct(json: GnarkProofJson): ProofABC;
declare function negateAndCompressProof(proof: ProofABC): CompressedProof;

/** pipe function */
declare function pipe<T, R>(initialFunction: (arg: T) => R, ...functions: ((arg: R) => R)[]): (initialValue: T) => R;

/**
 * Builds a versioned Transaction from instructions.
 *
 * @param instructions          instructions to include
 * @param payerPublicKey        fee payer public key
 * @param blockhash             blockhash to use
 * @param lookupTableAccounts   lookup table accounts to include
 *
 * @return VersionedTransaction
 */
declare function buildTx(instructions: TransactionInstruction[], payerPublicKey: PublicKey, blockhash: string, lookupTableAccounts?: AddressLookupTableAccount[]): VersionedTransaction;
/**
 * Sends a versioned transaction and confirms it.
 *
 * @param rpc               connection to use
 * @param tx                versioned transaction to send
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 *
 * @return TransactionSignature
 */
declare function sendAndConfirmTx(rpc: Rpc, tx: VersionedTransaction, confirmOptions?: ConfirmOptions, blockHashCtx?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<TransactionSignature>;
/**
 * Confirms a transaction with a given txId.
 *
 * @param rpc               connection to use
 * @param txId              transaction signature to confirm
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 * @return SignatureResult
 */
declare function confirmTx(rpc: Rpc, txId: string, confirmOptions?: ConfirmOptions, blockHashCtx?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<RpcResponseAndContext<SignatureResult>>;
/**
 * Builds a versioned Transaction from instructions and signs it.
 *
 * @param instructions          instructions to include in the transaction
 * @param payer                 payer of the transaction
 * @param blockhash             recent blockhash to use in the transaction
 * @param additionalSigners     non-feepayer signers to include in the
 *                              transaction
 * @param lookupTableAccounts   lookup table accounts to include in the
 *                              transaction
 */
declare function buildAndSignTx(instructions: TransactionInstruction[], payer: Signer, blockhash: string, additionalSigners?: Signer[], lookupTableAccounts?: AddressLookupTableAccount[]): VersionedTransaction;

declare function sleep(ms: number): Promise<void>;

declare const validateSufficientBalance: (balance: BN) => void;
declare const validateSameOwner: (compressedAccounts: CompressedAccount[] | CompressedAccountWithMerkleContext[]) => void;
declare const validateNumbersForProof: (hashesLength: number, newAddressesLength: number) => void;
declare const validateNumbersForInclusionProof: (hashesLength: number) => void;
declare const validateNumbersForNonInclusionProof: (newAddressesLength: number) => void;
declare const validateNumbers: (length: number, allowedNumbers: number[], type: string) => void;

/**
 * @param targetLamports - Target priority fee in lamports
 * @param computeUnits - Expected compute units used by the transaction
 * @returns microLamports per compute unit (use in
 * `ComputeBudgetProgram.setComputeUnitPrice`)
 */
declare function calculateComputeUnitPrice(targetLamports: number, computeUnits: number): number;

/**
 * Create two lookup tables storing all public state tree and queue addresses
 * returns lookup table addresses and txId
 *
 * @internal
 * @param connection - Connection to the Solana network
 * @param payer - Keypair of the payer
 * @param authority - Keypair of the authority
 * @param recentSlot - Slot of the recent block
 */
declare function createStateTreeLookupTable({ connection, payer, authority, recentSlot, }: {
    connection: Connection;
    payer: Keypair;
    authority: Keypair;
    recentSlot: number;
}): Promise<{
    address: PublicKey;
    txId: string;
}>;
/**
 * Extend state tree lookup table with new state tree and queue addresses
 * @internal
 * @param connection - Connection to the Solana network
 * @param tableAddress - Address of the lookup table to extend
 * @param newStateTreeAddresses - Addresses of the new state trees to add
 * @param newQueueAddresses - Addresses of the new queues to add
 * @param newCpiContextAddresses - Addresses of the new cpi contexts to add
 * @param payer - Keypair of the payer
 * @param authority - Keypair of the authority
 */
declare function extendStateTreeLookupTable({ connection, tableAddress, newStateTreeAddresses, newQueueAddresses, newCpiContextAddresses, payer, authority, }: {
    connection: Connection;
    tableAddress: PublicKey;
    newStateTreeAddresses: PublicKey[];
    newQueueAddresses: PublicKey[];
    newCpiContextAddresses: PublicKey[];
    payer: Keypair;
    authority: Keypair;
}): Promise<{
    tableAddress: PublicKey;
    txId: string;
}>;
/**
 * Adds state tree address to lookup table. Acts as nullifier lookup for rolled
 * over state trees.
 * @internal
 * @param connection - Connection to the Solana network
 * @param stateTreeAddress - Address of the state tree to nullify
 * @param nullifyTableAddress - Address of the nullifier lookup table to store
 * address in
 * @param stateTreeLookupTableAddress - lookup table storing all state tree
 * addresses
 * @param payer - Keypair of the payer
 * @param authority - Keypair of the authority
 */
declare function nullifyLookupTable({ connection, fullStateTreeAddress, nullifyTableAddress, stateTreeLookupTableAddress, payer, authority, }: {
    connection: Connection;
    fullStateTreeAddress: PublicKey;
    nullifyTableAddress: PublicKey;
    stateTreeLookupTableAddress: PublicKey;
    payer: Keypair;
    authority: Keypair;
}): Promise<{
    txId: string;
}>;
/**
 *  Get most recent , active state tree data
 * we store in lookup table for each public state tree
 */
declare function getLightStateTreeInfo({ connection, stateTreeLookupTableAddress, nullifyTableAddress, }: {
    connection: Connection;
    stateTreeLookupTableAddress: PublicKey;
    nullifyTableAddress: PublicKey;
}): Promise<ActiveTreeBundle[]>;

declare enum TreeType {
    /**
     * v1 state merkle tree
     */
    State = 0,
    /**
     * v1 address merkle tree
     */
    Address = 1,
    /**
     * v2 state merkle tree
     */
    BatchedState = 2,
    /**
     * v2 address merkle tree
     */
    BatchedAddress = 3
}
type ActiveTreeBundle = {
    tree: PublicKey;
    queue: PublicKey | null;
    cpiContext: PublicKey | null;
    treeType: TreeType;
};
interface PackedCompressedAccountWithMerkleContext {
    compressedAccount: CompressedAccount;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    readOnly: boolean;
}
interface PackedMerkleContext {
    merkleTreePubkeyIndex: number;
    nullifierQueuePubkeyIndex: number;
    leafIndex: number;
    queueIndex: null | QueueIndex;
}
interface QueueIndex {
    queueId: number;
    index: number;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
interface CompressedAccount {
    /** Public key of program or user that owns the account */
    owner: PublicKey;
    /** Lamports attached to the account */
    lamports: BN;
    /**
     * TODO: use PublicKey. Optional unique account ID that is persistent across
     * transactions.
     */
    address: number[] | null;
    /** Optional data attached to the account */
    data: CompressedAccountData | null;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
interface OutputCompressedAccountWithPackedContext {
    compressedAccount: CompressedAccount;
    merkleTreeIndex: number;
}
interface CompressedAccountData {
    discriminator: number[];
    data: Buffer$1;
    dataHash: number[];
}
interface MerkleTreeSequenceNumber {
    pubkey: PublicKey;
    seq: BN;
}
interface PublicTransactionEvent {
    inputCompressedAccountHashes: number[][];
    outputCompressedAccountHashes: number[][];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    outputLeafIndices: number[];
    sequenceNumbers: MerkleTreeSequenceNumber[];
    relayFee: BN | null;
    isCompress: boolean;
    compressOrDecompressLamports: BN | null;
    pubkeyArray: PublicKey[];
    message: Uint8Array | null;
}
interface InstructionDataInvoke {
    proof: CompressedProof | null;
    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    relayFee: BN | null;
    newAddressParams: NewAddressParamsPacked[];
    compressOrDecompressLamports: BN | null;
    isCompress: boolean;
}
interface InstructionDataInvokeCpi {
    proof: CompressedProof | null;
    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    relayFee: BN | null;
    newAddressParams: NewAddressParamsPacked[];
    compressOrDecompressLamports: BN | null;
    isCompress: boolean;
    compressedCpiContext: CompressedCpiContext | null;
}
interface CompressedCpiContext {
    set_context: boolean;
    first_set_context: boolean;
    cpi_context_account_index: number;
}
interface CompressedProof {
    a: number[];
    b: number[];
    c: number[];
}
interface InputTokenDataWithContext {
    amount: BN;
    delegateIndex: number | null;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    lamports: BN | null;
    tlv: Buffer$1 | null;
}
type TokenData$1 = {
    mint: PublicKey;
    owner: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: number;
    tlv: Buffer$1 | null;
};

type CompressedAccountWithMerkleContext = CompressedAccount & MerkleContext & {
    readOnly: boolean;
};
/**
 * Context for compressed account inserted into a state Merkle tree
 * */
type MerkleContext = {
    /** State Merkle tree */
    merkleTree: PublicKey;
    /** The state nullfier queue belonging to merkleTree */
    nullifierQueue: PublicKey;
    /** Poseidon hash of the utxo preimage. Is a leaf in state merkle tree  */
    hash: number[];
    /** 'hash' position within the Merkle tree */
    leafIndex: number;
};
type MerkleContextWithMerkleProof = MerkleContext & {
    /** Recent valid 'hash' proof path, expires after n slots */
    merkleProof: BN254[];
    /** Index of state root the merkleproof is valid for, expires after n slots */
    rootIndex: number;
    /** Current root */
    root: BN254;
};
declare const createCompressedAccount: (owner: PublicKey, lamports?: BN, data?: CompressedAccountData, address?: number[]) => CompressedAccount;
declare const createCompressedAccountWithMerkleContext: (merkleContext: MerkleContext, owner: PublicKey, lamports?: BN, data?: CompressedAccountData, address?: number[]) => CompressedAccountWithMerkleContext;
declare const createMerkleContext: (merkleTree: PublicKey, nullifierQueue: PublicKey, hash: number[], leafIndex: number) => MerkleContext;

interface LatestNonVotingSignatures {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
            error: string | null;
        }[];
    };
}
interface GetCompressedAccountsByOwnerConfig {
    filters?: GetCompressedAccountsFilter[];
    dataSlice?: DataSlice;
    cursor?: string;
    limit?: BN;
}
interface CompressedMintTokenHolders {
    balance: BN;
    owner: PublicKey;
}
interface LatestNonVotingSignaturesPaginated {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
        }[];
        cursor: string | null;
    };
}
interface SignatureWithMetadata {
    blockTime: number;
    signature: string;
    slot: number;
}
interface HashWithTree {
    hash: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
interface AddressWithTree {
    address: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
interface CompressedTransaction {
    compressionInfo: {
        closedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData$1 | null;
        }[];
        openedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData$1 | null;
        }[];
        preTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
        postTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
    };
    transaction: any;
}
interface HexBatchInputsForProver {
    'input-compressed-accounts': HexInputsForProver[];
}
interface HexInputsForProver {
    root: string;
    pathIndex: number;
    pathElements: string[];
    leaf: string;
}
type CompressedProofWithContext = {
    compressedProof: CompressedProof;
    roots: BN[];
    rootIndices: number[];
    leafIndices: number[];
    leaves: BN[];
    merkleTrees: PublicKey[];
    nullifierQueues: PublicKey[];
};
interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {
    mint?: PublicKey;
    cursor?: string;
    limit?: BN;
}
type TokenBalance = {
    balance: BN;
    mint: PublicKey;
};
/**
 * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.
 *
 * **Limit** is the maximum number of results to return per page.
 */
interface PaginatedOptions {
    cursor?: string;
    limit?: BN;
}
/**
 * Note, DataSizeFilter is currently not available.
 */
type GetCompressedAccountsFilter = MemcmpFilter;
type GetCompressedAccountConfig = {
    encoding?: string;
};
type GetCompressedAccountsConfig = {
    dataSlice: DataSlice;
    filters?: GetCompressedAccountsFilter[];
};
interface ParsedTokenAccount {
    compressedAccount: CompressedAccountWithMerkleContext;
    parsed: TokenData$1;
}
type WithContext<T> = {
    /** context */
    context: {
        slot: number;
    };
    /** response value */
    value: T;
};
type WithCursor<T> = {
    /** context */
    cursor: string | null;
    /** response value */
    items: T;
};
/**
 * @internal
 */
declare function createRpcResult<T, U>(result: Struct<T, U>): Struct<RpcResult<T>, null>;
/**
 * @internal
 */
declare function jsonRpcResult<T, U>(schema: Struct<T, U>): Struct<RpcResult<T>, null>;
type WithRpcContext<T> = {
    context: {
        slot: number;
    };
    value: T;
};
/**
 * @internal
 */
declare function jsonRpcResultAndContext<T, U>(value: Struct<T, U>): Struct<RpcResult<WithRpcContext<T>>, null>;
/**
 * @internal
 */
declare const CompressedAccountResult: Struct<{
    lamports: BN;
    data: {
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null;
    address: number[] | null;
    hash: BN;
    owner: PublicKey;
    leafIndex: number;
    tree: PublicKey;
    seq: BN | null;
    slotCreated: BN;
}, {
    address: Struct<number[] | null, null>;
    hash: Struct<BN, null>;
    data: Struct<{
        data: string;
        dataHash: BN;
        discriminator: BN;
    } | null, {
        data: Struct<string, null>;
        dataHash: Struct<BN, null>;
        discriminator: Struct<BN, null>;
    }>;
    lamports: Struct<BN, null>;
    owner: Struct<PublicKey, null>;
    leafIndex: Struct<number, null>;
    tree: Struct<PublicKey, null>;
    seq: Struct<BN | null, null>;
    slotCreated: Struct<BN, null>;
}>;
declare const TokenDataResult: Struct<{
    owner: PublicKey;
    mint: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: string;
}, {
    mint: Struct<PublicKey, null>;
    owner: Struct<PublicKey, null>;
    amount: Struct<BN, null>;
    delegate: Struct<PublicKey | null, null>;
    state: Struct<string, null>;
}>;
/**
 * @internal
 */
declare const CompressedTokenAccountResult: Struct<{
    tokenData: {
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    };
    account: {
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    };
}, {
    tokenData: Struct<{
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    }, {
        mint: Struct<PublicKey, null>;
        owner: Struct<PublicKey, null>;
        amount: Struct<BN, null>;
        delegate: Struct<PublicKey | null, null>;
        state: Struct<string, null>;
    }>;
    account: Struct<{
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>;
}>;
/**
 * @internal
 */
declare const MultipleCompressedAccountsResult: Struct<{
    items: {
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }[];
}, {
    items: Struct<{
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }[], Struct<{
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
}>;
/**
 * @internal
 */
declare const CompressedAccountsByOwnerResult: Struct<{
    items: {
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }[], Struct<{
        lamports: BN;
        data: {
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null;
        address: number[] | null;
        hash: BN;
        owner: PublicKey;
        leafIndex: number;
        tree: PublicKey;
        seq: BN | null;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            dataHash: BN;
            discriminator: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const CompressedTokenAccountsByOwnerOrDelegateResult: Struct<{
    items: {
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            lamports: BN;
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            tree: PublicKey;
            seq: BN | null;
            slotCreated: BN;
        };
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            lamports: BN;
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            tree: PublicKey;
            seq: BN | null;
            slotCreated: BN;
        };
    }[], Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            lamports: BN;
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            tree: PublicKey;
            seq: BN | null;
            slotCreated: BN;
        };
    }, {
        tokenData: Struct<{
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        }, {
            mint: Struct<PublicKey, null>;
            owner: Struct<PublicKey, null>;
            amount: Struct<BN, null>;
            delegate: Struct<PublicKey | null, null>;
            state: Struct<string, null>;
        }>;
        account: Struct<{
            lamports: BN;
            data: {
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null;
            address: number[] | null;
            hash: BN;
            owner: PublicKey;
            leafIndex: number;
            tree: PublicKey;
            seq: BN | null;
            slotCreated: BN;
        }, {
            address: Struct<number[] | null, null>;
            hash: Struct<BN, null>;
            data: Struct<{
                data: string;
                dataHash: BN;
                discriminator: BN;
            } | null, {
                data: Struct<string, null>;
                dataHash: Struct<BN, null>;
                discriminator: Struct<BN, null>;
            }>;
            lamports: Struct<BN, null>;
            owner: Struct<PublicKey, null>;
            leafIndex: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            seq: Struct<BN | null, null>;
            slotCreated: Struct<BN, null>;
        }>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const SlotResult: Struct<number, null>;
/**
 * @internal
 */
declare const HealthResult: Struct<string, null>;
/**
 * @internal
 */
declare const LatestNonVotingSignaturesResult: Struct<{
    items: {
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }[];
}, {
    items: Struct<{
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
        error: Struct<string | null, null>;
    }>>;
}>;
/**
 * @internal
 */
declare const LatestNonVotingSignaturesResultPaginated: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const MerkeProofResult: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>;
/**
 * @internal
 */
declare const NewAddressProofResult: Struct<{
    root: BN;
    address: BN;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
    nextIndex: number;
    lowerRangeAddress: BN;
    higherRangeAddress: BN;
    lowElementLeafIndex: number;
}, {
    address: Struct<BN, null>;
    nextIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
    lowerRangeAddress: Struct<BN, null>;
    higherRangeAddress: Struct<BN, null>;
    lowElementLeafIndex: Struct<number, null>;
}>;
/**
 * @internal
 */
declare const ValidityProofResult: Struct<{
    compressedProof: {
        a: number[];
        b: number[];
        c: number[];
    };
    leafIndices: number[];
    leaves: BN[];
    rootIndices: number[];
    roots: BN[];
    merkleTrees: PublicKey[];
}, {
    compressedProof: Struct<{
        a: number[];
        b: number[];
        c: number[];
    }, {
        a: Struct<number[], Struct<number, null>>;
        b: Struct<number[], Struct<number, null>>;
        c: Struct<number[], Struct<number, null>>;
    }>;
    leafIndices: Struct<number[], Struct<number, null>>;
    leaves: Struct<BN[], Struct<BN, null>>;
    rootIndices: Struct<number[], Struct<number, null>>;
    roots: Struct<BN[], Struct<BN, null>>;
    merkleTrees: Struct<PublicKey[], Struct<PublicKey, null>>;
}>;
/**
 * @internal
 */
declare const MultipleMerkleProofsResult: Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}[], Struct<{
    root: BN;
    hash: BN;
    leafIndex: number;
    merkleTree: PublicKey;
    proof: BN[];
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>>;
/**
 * @internal
 */
declare const BalanceResult: Struct<{
    amount: BN;
}, {
    amount: Struct<BN, null>;
}>;
declare const NativeBalanceResult: Struct<BN, null>;
declare const TokenBalanceResult: Struct<{
    mint: PublicKey;
    balance: BN;
}, {
    balance: Struct<BN, null>;
    mint: Struct<PublicKey, null>;
}>;
declare const TokenBalanceListResult: Struct<{
    cursor: string | null;
    tokenBalances: {
        mint: PublicKey;
        balance: BN;
    }[];
}, {
    tokenBalances: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const TokenBalanceListResultV2: Struct<{
    items: {
        mint: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const CompressedMintTokenHoldersResult: Struct<{
    items: {
        owner: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    cursor: Struct<string | null, null>;
    items: Struct<{
        owner: PublicKey;
        balance: BN;
    }[], Struct<{
        owner: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
    }>>;
}>;
declare const AccountProofResult: Struct<{
    root: number[];
    hash: number[];
    proof: number[][];
}, {
    hash: Struct<number[], Struct<number, null>>;
    root: Struct<number[], Struct<number, null>>;
    proof: Struct<number[][], Struct<number[], Struct<number, null>>>;
}>;
declare const toUnixTimestamp: (blockTime: string) => number;
declare const SignatureListResult: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
}>;
declare const SignatureListWithCursorResult: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const CompressedTransactionResult: Struct<{
    compressionInfo: {
        closedAccounts: {
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    };
    transaction?: any;
}, {
    compressionInfo: Struct<{
        closedAccounts: {
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    }, {
        closedAccounts: Struct<{
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
        openedAccounts: Struct<{
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                lamports: BN;
                data: {
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null;
                address: number[] | null;
                hash: BN;
                owner: PublicKey;
                leafIndex: number;
                tree: PublicKey;
                seq: BN | null;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    dataHash: BN;
                    discriminator: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
    }>;
    transaction: Struct<any, null>;
}>;
interface CompressionApiInterface {
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    getValidityProof(hashes: BN254[], newAddresses: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<CompressedProofWithContext>;
    getValidityProofAndRpcContext(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    getCompressedTokenAccountsByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    getIndexerHealth(): Promise<string>;
    getIndexerSlot(): Promise<number>;
}
type RpcResultSuccess<T> = {
    jsonrpc: '2.0';
    id: string;
    result: T;
};
type RpcResultError = {
    jsonrpc: '2.0';
    id: string;
    error: {
        code: unknown;
        message: string;
        data?: any;
    };
};
type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;

interface TestRpcConfig {
    /**
     * Address of the state tree to index. Default: public default test state
     * tree.
     */
    merkleTreeAddress?: PublicKey;
    /**
     * Nullifier queue associated with merkleTreeAddress
     */
    nullifierQueueAddress?: PublicKey;
    /**
     * Depth of state tree. Defaults to the public default test state tree depth
     */
    depth?: number;
    /**
     * Log proof generation time
     */
    log?: boolean;
    /**
     * Address of the address tree to index. Default: public default test
     * address tree.
     */
    addressTreeAddress?: PublicKey;
    /**
     * Address queue associated with addressTreeAddress
     */
    addressQueueAddress?: PublicKey;
}
type ClientSubscriptionId = number;
interface LightWasm {
    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;
    poseidonHash(input: string[] | BN[]): Uint8Array;
    poseidonHashString(input: string[] | BN[]): string;
    poseidonHashBN(input: string[] | BN[]): BN;
}
/**
 * Returns a mock RPC instance for use in unit tests.
 *
 * @param lightWasm               Wasm hasher instance.
 * @param endpoint                RPC endpoint URL. Defaults to
 *                                'http://127.0.0.1:8899'.
 * @param proverEndpoint          Prover server endpoint URL. Defaults to
 *                                'http://localhost:3001'.
 * @param merkleTreeAddress       Address of the merkle tree to index. Defaults
 *                                to the public default test state tree.
 * @param nullifierQueueAddress   Optional address of the associated nullifier
 *                                queue.
 * @param depth                   Depth of the merkle tree.
 * @param log                     Log proof generation time.
 */
declare function getTestRpc(lightWasm: LightWasm, endpoint?: string, compressionApiEndpoint?: string, proverEndpoint?: string, merkleTreeAddress?: PublicKey, nullifierQueueAddress?: PublicKey, depth?: number, log?: boolean): Promise<TestRpc>;
/**
 * Simple mock rpc for unit tests that simulates the compression rpc interface.
 * Fetches, parses events and builds merkletree on-demand, i.e. it does not persist state.
 * Constraints:
 * - Can only index 1 merkletree
 * - Can only index up to 1000 transactions
 *
 * For advanced testing use photon: https://github.com/helius-labs/photon
 */
declare class TestRpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    merkleTreeAddress: PublicKey;
    nullifierQueueAddress: PublicKey;
    addressTreeAddress: PublicKey;
    addressQueueAddress: PublicKey;
    lightWasm: LightWasm;
    depth: number;
    log: boolean;
    activeStateTreeInfo: ActiveTreeBundle[] | null;
    /**
     * Establish a Compression-compatible JSON RPC mock-connection
     *
     * @param endpoint                  endpoint to the solana cluster (use for
     *                                  localnet only)
     * @param hasher                    light wasm hasher instance
     * @param compressionApiEndpoint    Endpoint to the compression server.
     * @param proverEndpoint            Endpoint to the prover server. defaults
     *                                  to endpoint
     * @param connectionConfig          Optional connection config
     * @param testRpcConfig             Config for the mock rpc
     */
    constructor(endpoint: string, hasher: LightWasm, compressionApiEndpoint: string, proverEndpoint: string, connectionConfig?: ConnectionConfig, testRpcConfig?: TestRpcConfig);
    /**
     * Manually set state tree addresses
     */
    setStateTreeInfo(info: ActiveTreeBundle[]): void;
    /**
     * Returns local test state trees.
     */
    getCachedActiveStateTreeInfo(): Promise<ActiveTreeBundle[]>;
    /**
     * Returns local test state trees.
     */
    getLatestActiveStateTreeInfo(): Promise<ActiveTreeBundle[]>;
    /**
     * Fetch the compressed account for the specified account hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(_slot: number): Promise<boolean>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, _config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(_cursor?: string, _limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch the latest non-voting signatures on the cluster. Results are
     * not paginated.
     */
    getLatestNonVotingSignatures(_limit?: number): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint.
     */
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<{
        balance: BN;
        mint: PublicKey;
    }[]>>;
    /**
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Uses context.
     */
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(_hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(_signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed
     * block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(_address: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    getCompressedMintTokenHolders(_mint: PublicKey, _options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Note: Use RPC class for forested trees. TestRpc is only for custom
     * testing purposes.
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * @deprecated This method is not available for TestRpc. Please use
     * {@link getValidityProof} instead.
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
}

declare class IndexedElement {
    index: number;
    value: BN;
    nextIndex: number;
    constructor(index: number, value: BN, nextIndex: number);
    equals(other: IndexedElement): boolean;
    compareTo(other: IndexedElement): number;
    hash(lightWasm: LightWasm, nextValue: BN): Uint8Array;
}
declare class IndexedElementBundle {
    newLowElement: IndexedElement;
    newElement: IndexedElement;
    newElementNextValue: BN;
    constructor(newLowElement: IndexedElement, newElement: IndexedElement, newElementNextValue: BN);
}
/**
 * This indexed array implementation mirrors the rust implementation of the
 * indexed merkle tree. It stores the elements of the indexed merkle tree.
 */
declare class IndexedArray {
    elements: Array<IndexedElement>;
    currentNodeIndex: number;
    highestElementIndex: number;
    constructor(elements: Array<IndexedElement>, currentNodeIndex: number, highestElementIndex: number);
    static default(): IndexedArray;
    get(index: number): IndexedElement | undefined;
    length(): number;
    isEmpty(): boolean;
    findElement(value: BN): IndexedElement | undefined;
    init(): IndexedElementBundle;
    /**
     * Finds the index of the low element for the given `value` which should not be part of the array.
     * Low element is the greatest element which still has a lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElementIndex(value: BN): number | undefined;
    /**
     * Returns the low element for the given value and the next value for that low element.
     * Low element is the greatest element which still has lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElement(value: BN): [IndexedElement | undefined, BN | undefined];
    /**
     * Returns the hash of the given element. That hash consists of:
     * - The value of the given element.
     * - The `nextIndex` of the given element.
     * - The value of the element pointed by `nextIndex`.
     */
    hashElement(lightWasm: LightWasm, index: number): Uint8Array | undefined;
    /**
     * Appends a new element with the given value to the indexed array.
     * It finds the low element index and uses it to append the new element correctly.
     * @param value The value of the new element to append.
     * @returns The new element and its low element after insertion.
     */
    append(value: BN): IndexedElementBundle;
    /**
     * Appends a new element with the given value to the indexed array using a specific low element index.
     * This method ensures the new element is placed correctly relative to the low element.
     * @param lowElementIndex The index of the low element.
     * @param value The value of the new element to append.
     * @returns The new element and its updated low element.
     */
    appendWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Finds the lowest element in the array.
     * @returns The lowest element or undefined if the array is empty.
     */
    lowest(): IndexedElement | undefined;
    /**
     * Creates a new element with the specified value and updates the low element index accordingly.
     * @param lowElementIndex The index of the low element.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElementWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Creates a new element with the specified value by first finding the appropriate low element index.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElement(value: BN): IndexedElementBundle;
}

declare const DEFAULT_ZERO = "0";
/**
 * @callback hashFunction
 * @param left Left leaf
 * @param right Right leaf
 */
/**
 * Merkle tree
 */
declare class MerkleTree {
    /**
     * Constructor
     * @param {number} levels Number of levels in the tree
     * @param {Array} [elements] Initial elements
     * @param {Object} options
     * @param {hashFunction} [options.hashFunction] Function used to hash 2 leaves
     * @param [options.zeroElement] Value for non-existent leaves
     */
    levels: number;
    capacity: number;
    zeroElement: string;
    _zeros: string[];
    _layers: string[][];
    _lightWasm: LightWasm;
    constructor(levels: number, lightWasm: LightWasm, elements?: string[], { zeroElement }?: {
        zeroElement?: string | undefined;
    });
    _rebuild(): void;
    /**
     * Get tree root
     * @returns {*}
     */
    root(): string;
    /**
     * Insert new element into the tree
     * @param element Element to insert
     */
    insert(element: string): void;
    /**
     * Insert multiple elements into the tree. Tree will be fully rebuilt during this operation.
     * @param {Array} elements Elements to insert
     */
    bulkInsert(elements: string[]): void;
    /**
     * Change an element in the tree
     * @param {number} index Index of element to change
     * @param element Updated element value
     */
    update(index: number, element: string): void;
    /**
     * Get merkle path to a leaf
     * @param {number} index Leaf index to generate path for
     * @returns {{pathElements: number[], pathIndex: number[]}} An object containing adjacent elements and left-right index
     */
    path(index: number): {
        pathElements: string[];
        pathIndices: number[];
    };
    /**
     * Find an element in the tree
     * @param element An element to find
     * @param comparator A function that checks leaf value equality
     * @returns {number} Index if element is found, otherwise -1
     */
    indexOf(element: string, comparator?: ((element: string, el: string) => boolean) | null): number;
    /**
     * Returns a copy of non-zero tree elements
     * @returns {Object[]}
     */
    elements(): string[];
    /**
     * Serialize entire tree state including intermediate layers into a plain object
     * Deserializing it back will not require to recompute any hashes
     * Elements are not converted to a plain type, this is responsibility of the caller
     */
    serialize(): {
        levels: number;
        _zeros: string[];
        _layers: string[][];
    };
    /**
     * Deserialize data into a MerkleTree instance
     * Make sure to provide the same hashFunction as was used in the source tree,
     * otherwise the tree state will be invalid
     *
     * @param data
     * @param hashFunction
     * @returns {MerkleTree}
     */
    static deserialize(data: any, hashFunction: (left: string, right: string) => string): any;
}

type Deserializer<T> = (data: Buffer$1, tx: ParsedTransactionWithMeta) => T;
/**
 * @internal
 * Returns newest first.
 *
 * */
declare function getParsedEvents(rpc: Rpc): Promise<PublicTransactionEvent[]>;
declare const parseEvents: <T>(indexerEventsTransactions: (ParsedTransactionWithMeta | null)[], deserializeFn: Deserializer<T>) => NonNullable<T>[];
declare const parsePublicTransactionEventWithIdl: (data: Buffer$1) => PublicTransactionEvent | null;
declare function parseLightTransaction(dataVec: Uint8Array[], accountKeys: PublicKey[][]): PublicTransactionEvent | null | undefined;

type TokenData = {
    mint: PublicKey;
    owner: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: number;
    tlv: Buffer | null;
};
declare const TokenDataLayout: Layout<TokenData>;
type EventWithParsedTokenTlvData = {
    inputCompressedAccountHashes: number[][];
    outputCompressedAccounts: ParsedTokenAccount[];
};
/**
 * Manually parse the compressed token layout for a given compressed account.
 * @param compressedAccount - The compressed account
 * @returns The parsed token data
 */
declare function parseTokenLayoutWithIdl(compressedAccount: CompressedAccount, programId?: PublicKey): TokenData | null;
/**
 * Retrieves all compressed token accounts for a given mint and owner.
 *
 * Note: This function is intended for testing purposes only. For production, use rpc.getCompressedTokenAccounts.
 *
 * @param events    Public transaction events
 * @param owner     PublicKey of the token owner
 * @param mint      PublicKey of the token mint
 */
declare function getCompressedTokenAccounts(events: PublicTransactionEvent[]): Promise<ParsedTokenAccount[]>;
/** @internal */
declare function getCompressedTokenAccountsByOwnerTest(rpc: Rpc, owner: PublicKey, mint: PublicKey): Promise<WithCursor<ParsedTokenAccount[]>>;
declare function getCompressedTokenAccountsByDelegateTest(rpc: Rpc, delegate: PublicKey, mint: PublicKey): Promise<WithCursor<ParsedTokenAccount[]>>;
declare function getCompressedTokenAccountByHashTest(rpc: Rpc, hash: BN): Promise<ParsedTokenAccount>;

declare const ALICE: Keypair;
declare const BOB: Keypair;
declare const CHARLIE: Keypair;
declare const DAVE: Keypair;
/**
 * Deep comparison of two objects. Handles BN comparison correctly.
 *
 * @param ref - The reference object to compare.
 * @param val - The value object to compare.
 * @returns True if the objects are deeply equal, false otherwise.
 */
declare function deepEqual(ref: any, val: any): boolean;
/**
 * Create a new account and airdrop lamports to it
 *
 * @param rpc       connection to use
 * @param lamports  amount of lamports to airdrop
 * @param counter   counter to use for generating the keypair.
 *                  If undefined or >255, generates random keypair.
 */
declare function newAccountWithLamports(rpc: Rpc, lamports?: number, counter?: number | undefined): Promise<Signer>;
declare function getConnection(): Connection;
/**
 * For use in tests.
 * Generate a unique keypair by passing in a counter <255. If no counter
 * is supplied, it uses and increments a global counter.
 * if counter > 255, generates random keypair
 */
declare function getTestKeypair(counter?: number | undefined): Keypair;

/** @internal */
declare function parseAccountData({ discriminator, data, dataHash, }: {
    discriminator: BN;
    data: string;
    dataHash: BN;
}): {
    discriminator: number[];
    data: Buffer$1;
    dataHash: number[];
};
/**
 * Establish a Compression-compatible JSON RPC connection
 *
 * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or
 *                                      Connection object
 * @param compressionApiEndpoint        Endpoint to the compression server
 * @param proverEndpoint                Endpoint to the prover server. defaults
 *                                      to endpoint
 * @param connectionConfig              Optional connection config
 */
declare function createRpc(endpointOrWeb3JsConnection?: string | Connection, compressionApiEndpoint?: string, proverEndpoint?: string, config?: ConnectionConfig): Rpc;
/**
 * Helper function to preprocess the response to wrap numbers as strings
 * @param {string} text - The JSON string to preprocess
 * @returns {string} - The preprocessed JSON string with numbers wrapped as strings
 */
declare function wrapBigNumbersAsStrings(text: string): string;
/** @internal */
declare const rpcRequest: (rpcEndpoint: string, method: string, params?: any, convertToCamelCase?: boolean, debug?: boolean) => Promise<any>;
/** @internal */
declare const proverRequest: (proverEndpoint: string, method: "inclusion" | "new-address" | "combined", params?: any, log?: boolean, publicInputHash?: BN | undefined) => Promise<CompressedProof>;
type NonInclusionMerkleProofInputs = {
    root: BN;
    value: BN;
    leaf_lower_range_value: BN;
    leaf_higher_range_value: BN;
    nextIndex: BN;
    merkle_proof_hashed_indexed_element_leaf: BN[];
    index_hashed_indexed_element_leaf: BN;
};
type MerkleContextWithNewAddressProof = {
    root: BN;
    rootIndex: number;
    value: BN;
    leafLowerRangeValue: BN;
    leafHigherRangeValue: BN;
    nextIndex: BN;
    merkleProofHashedIndexedElementLeaf: BN[];
    indexHashedIndexedElementLeaf: BN;
    merkleTree: PublicKey;
    nullifierQueue: PublicKey;
};
type NonInclusionJsonStruct = {
    root: string;
    value: string;
    pathIndex: number;
    pathElements: string[];
    leafLowerRangeValue: string;
    leafHigherRangeValue: string;
    nextIndex: number;
};
declare function convertMerkleProofsWithContextToHex(merkleProofsWithContext: MerkleContextWithMerkleProof[]): HexInputsForProver[];
declare function convertNonInclusionMerkleProofInputsToHex(nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[]): NonInclusionJsonStruct[];
declare function getPublicInputHash(accountProofs: MerkleContextWithMerkleProof[], accountHashes: BN254[], newAddressProofs: MerkleContextWithNewAddressProof[], lightWasm: LightWasm): BN;
/**
 * Get the queue for a given tree
 *
 * @param info - The active state tree addresses
 * @param tree - The tree to get the queue for
 * @returns The queue for the given tree, or undefined if not found
 */
declare function getQueueForTree(info: ActiveTreeBundle[], tree: PublicKey): PublicKey;
/**
 * Get the tree for a given queue
 *
 * @param info - The active state tree addresses
 * @param queue - The queue to get the tree for
 * @returns The tree for the given queue, or undefined if not found
 */
declare function getTreeForQueue(info: ActiveTreeBundle[], queue: PublicKey): PublicKey;
/**
 * Get a random tree and queue from the active state tree addresses.
 *
 * Prevents write lock contention on state trees.
 *
 * @param info - The active state tree addresses
 * @returns A random tree and queue
 */
declare function pickRandomTreeAndQueue(info: ActiveTreeBundle[]): {
    tree: PublicKey;
    queue: PublicKey;
};
/**
 *
 */
declare class Rpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    activeStateTreeInfo: ActiveTreeBundle[] | null;
    constructor(endpoint: string, compressionApiEndpoint: string, proverEndpoint: string, config?: ConnectionConfig);
    /**
     * Manually set state tree addresses
     */
    setStateTreeInfo(info: ActiveTreeBundle[]): void;
    /**
     * Get the active state tree addresses from the cluster.
     * If not already cached, fetches from the cluster.
     */
    getCachedActiveStateTreeInfo(): Promise<ActiveTreeBundle[]>;
    /**
     * Fetch the latest state tree addresses from the cluster.
     */
    getLatestActiveStateTreeInfo(): Promise<ActiveTreeBundle[]>;
    /**
     * Fetch the compressed account for the specified account address or hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account address or hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig | undefined): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.
     *
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Returns without context.
     */
    getCompressedTokenBalancesByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    /**
     * Fetch the compressed token balances owned by the specified public
     * key. Paginated. Can filter by mint. Returns with context.
     */
    getCompressedTokenBalancesByOwnerV2(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed compression signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(slot: number): Promise<boolean>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch all the compressed token holders for a given mint. Paginated.
     */
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch all non-voting signatures
     */
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in
     * respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * @deprecated use {@link getValidityProofV0} instead.
     *
     *
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.
     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.
     * @returns             validity proof with context
     */
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses. Returns with context slot.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses. Optionally specify the
     *                      tree and queue for each address. Default to public
     *                      state tree/queue.
     * @returns             validity proof with context
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
}

/**
 * Compress lamports to a solana address
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
declare function compress(rpc: Rpc, payer: Signer, lamports: number | BN, toAddress: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Create compressed account with address
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
declare function createAccount(rpc: Rpc, payer: Signer, seeds: Uint8Array[], programId: PublicKey, addressTree?: PublicKey, addressQueue?: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
/**
 * Create compressed account with address and lamports
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param lamports          Number of compressed lamports to initialize the
 *                          account with
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
declare function createAccountWithLamports(rpc: Rpc, payer: Signer, seeds: Uint8Array[], lamports: number | BN, programId: PublicKey, addressTree?: PublicKey, addressQueue?: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Decompress lamports into a solana account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
declare function decompress(rpc: Rpc, payer: Signer, lamports: number | BN, recipient: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/** @internal remove signer from signers if part of signers */
declare function dedupeSigner(signer: Signer, signers: Signer[]): Signer[];

/**
 * Transfer compressed lamports from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of transaction fees
 * @param lamports       Number of lamports to transfer
 * @param owner          Owner of the compressed lamports
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed lamports should be
 *                       inserted into. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 * @param config         Configuration for fetching compressed accounts
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function transfer(rpc: Rpc, payer: Signer, lamports: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * @internal Finds the index of a PublicKey in an array, or adds it if not
 * present
 * */
declare function getIndexOrAdd(accountsArray: PublicKey[], key: PublicKey): number;
/**
 * @internal
 * Pads output state trees with the 0th state tree of the input state.
 *
 * @param outputStateMerkleTrees            Optional output state trees to be
 *                                          inserted into the output state.
 *                                          Defaults to the 0th state tree of
 *                                          the input state. Gets padded to the
 *                                          length of outputCompressedAccounts.
 * @param numberOfOutputCompressedAccounts  The number of output compressed
 *                                          accounts.
 * @param inputCompressedAccountsWithMerkleContext The input compressed accounts
 *                                          with merkle context.
 *
 * @returns Padded output state trees.
 */
declare function padOutputStateMerkleTrees(outputStateMerkleTrees: PublicKey[] | PublicKey | undefined, numberOfOutputCompressedAccounts: number, inputCompressedAccountsWithMerkleContext: CompressedAccountWithMerkleContext[]): PublicKey[];
declare function toAccountMetas(remainingAccounts: PublicKey[]): AccountMeta[];
/**
 * Packs Compressed Accounts.
 *
 * Replaces PublicKey with index pointer to remaining accounts.
 *
 *
 * @param inputCompressedAccounts           Ix input state to be consumed
 * @param inputStateRootIndices             The recent state root indices of the
 *                                          input state. The expiry is tied to
 *                                          the proof.
 * @param outputCompressedAccounts          Ix output state to be created
 * @param outputStateMerkleTrees            Optional output state trees to be
 *                                          inserted into the output state.
 *                                          Defaults to the 0th state tree of
 *                                          the input state. Gets padded to the
 *                                          length of outputCompressedAccounts.
 *
 * @param remainingAccounts                 Optional existing array of accounts
 *                                          to append to.
 **/
declare function packCompressedAccounts(inputCompressedAccounts: CompressedAccountWithMerkleContext[], inputStateRootIndices: number[], outputCompressedAccounts: CompressedAccount[], outputStateMerkleTrees?: PublicKey[] | PublicKey, remainingAccounts?: PublicKey[]): {
    packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[];
    packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    remainingAccounts: PublicKey[];
};

declare const sumUpLamports: (accounts: CompressedAccountWithMerkleContext[]) => BN;
/**
 * Create compressed account system transaction params
 */
type CreateAccountWithSeedParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * Address params for the new compressed account
     */
    newAddressParams: NewAddressParams;
    newAddress: number[];
    /**
     * Recent validity proof proving that there's no existing compressed account
     * registered with newAccountAddress
     */
    recentValidityProof: CompressedProof;
    /**
     * State tree pubkey. Defaults to a public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Public key of the program to assign as the owner of the created account
     */
    programId?: PublicKey;
    /**
     * Optional input accounts to transfer lamports from into the new compressed
     * account.
     */
    inputCompressedAccounts?: CompressedAccountWithMerkleContext[];
    /**
     * Optional input state root indices of 'inputCompressedAccounts'. The
     * expiry is tied to the 'recentValidityProof'.
     */
    inputStateRootIndices?: number[];
    /**
     * Optional lamports to transfer into the new compressed account.
     */
    lamports?: number | BN;
};
/**
 * Defines the parameters for the transfer method
 */
type TransferParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to transfer.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type CompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * address that the lamports are attached to. also defaults to the recipient owner
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to compress.
     */
    lamports: number | BN;
    /**
     * The state tree that the tx output should be inserted into. Defaults to a
     * public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type DecompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address of uncompressed lamports
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to decompress.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTree?: PublicKey;
};
declare class LightSystemProgram$1 {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    /**
     * @internal
     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY
     *
     */
    static deriveCompressedSolPda(): PublicKey;
    static createTransferOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], toAddress: PublicKey, lamports: number | BN): CompressedAccount[];
    static createDecompressOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], lamports: number | BN): CompressedAccount[];
    /**
     * No data by default
     */
    static createNewAddressOutputState(address: number[], owner: PublicKey, lamports?: BN | number, inputCompressedAccounts?: CompressedAccountWithMerkleContext[]): CompressedAccount[];
    /**
     * Creates instruction to create compressed account with PDA.
     * Cannot write data.
     *
     * TODO: support transfer of lamports to the new account.
     */
    static createAccount({ payer, newAddressParams, newAddress, recentValidityProof, outputStateTree, inputCompressedAccounts, inputStateRootIndices, lamports, }: CreateAccountWithSeedParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static transfer({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTrees, }: TransferParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static compress({ payer, toAddress, lamports, outputStateTree, }: CompressParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static decompress({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTree, }: DecompressParams): Promise<TransactionInstruction>;
}
/**
 * Selects the minimal number of compressed SOL accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
declare function selectMinCompressedSolAccountsForTransfer(accounts: CompressedAccountWithMerkleContext[], transferLamports: BN | number): [selectedAccounts: CompressedAccountWithMerkleContext[], total: BN];

declare const CompressedAccountLayout: buffer_layout.Layout<unknown>;
declare const MerkleContextLayout: buffer_layout.Layout<unknown>;
declare const NewAddressParamsLayout: buffer_layout.Layout<unknown>;
declare const InstructionDataInvokeLayout: Layout<InstructionDataInvoke>;
declare function encodeInstructionDataInvoke(data: InstructionDataInvoke): Buffer$1;
declare const InstructionDataInvokeCpiLayout: Layout<InstructionDataInvokeCpi>;
declare function decodeInstructionDataInvoke(buffer: Buffer$1): InstructionDataInvoke;
declare function decodeInstructionDataInvokeCpi(buffer: Buffer$1): InstructionDataInvokeCpi;
type invokeAccountsLayoutParams = {
    feePayer: PublicKey;
    authority: PublicKey;
    registeredProgramPda: PublicKey;
    noopProgram: PublicKey;
    accountCompressionAuthority: PublicKey;
    accountCompressionProgram: PublicKey;
    solPoolPda: PublicKey | null;
    decompressionRecipient: PublicKey | null;
    systemProgram: PublicKey;
};
declare const invokeAccountsLayout: (accounts: invokeAccountsLayoutParams) => AccountMeta[];
declare const PublicTransactionEventLayout: Layout<PublicTransactionEvent>;
declare function encodePublicTransactionEvent(data: PublicTransactionEvent): Buffer$1;
declare function decodePublicTransactionEvent(buffer: Buffer$1): PublicTransactionEvent;
declare const AppendNullifyCreateAddressInputsMetaLayout: buffer_layout.Layout<unknown>;
declare const AppendLeavesInputLayout: buffer_layout.Layout<unknown>;
declare const InsertNullifierInputLayout: buffer_layout.Layout<unknown>;
declare const InsertAddressInputLayout: buffer_layout.Layout<unknown>;
declare const MerkleTreeSequenceNumberLayout: buffer_layout.Layout<unknown>;
declare function deserializeAppendNullifyCreateAddressInputsIndexer(buffer: Buffer$1): {
    meta: unknown;
    leaves: unknown[];
    nullifiers: unknown[];
    addresses: unknown[];
    sequence_numbers: unknown[];
    output_leaf_indices: number[];
};
declare function convertToPublicTransactionEvent(decoded: any, remainingAccounts: PublicKey[], invokeData: InstructionDataInvoke): PublicTransactionEvent;

declare const FIELD_SIZE: BN;
declare const HIGHEST_ADDRESS_PLUS_ONE: BN;
declare const COMPUTE_BUDGET_PATTERN: number[];
declare const INVOKE_DISCRIMINATOR: Buffer$1;
declare const INVOKE_CPI_DISCRIMINATOR: Buffer$1;
declare const INSERT_INTO_QUEUES_DISCRIMINATOR: Buffer$1;
declare const noopProgram = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
declare const lightProgram = "SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7";
declare const accountCompressionProgram = "compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq";
declare const getRegisteredProgramPda: () => PublicKey;
declare const getAccountCompressionAuthority: () => PublicKey;
declare const defaultStaticAccounts: () => PublicKey[];
declare const defaultStaticAccountsStruct: () => {
    registeredProgramPda: PublicKey;
    noopProgram: PublicKey;
    accountCompressionProgram: PublicKey;
    accountCompressionAuthority: PublicKey;
    cpiSignatureAccount: null;
};
type StateTreeLUTPair = {
    stateTreeLookupTable: PublicKey;
    nullifyTable: PublicKey;
};
/**
 * Returns the Default Public State Tree LUTs for Devnet and Mainnet-Beta.
 */
declare const defaultStateTreeLookupTables: () => {
    mainnet: StateTreeLUTPair[];
    devnet: StateTreeLUTPair[];
};
/**
 * @internal
 */
declare const isLocalTest: (url: string) => boolean;
/**
 * @internal
 */
declare const localTestActiveStateTreeInfo: () => ActiveTreeBundle[];
/**
 * Use only with Localnet testing.
 * For public networks, fetch via {@link defaultStateTreeLookupTables} and {@link getLightStateTreeInfo}.
 */
declare const defaultTestStateTreeAccounts: () => {
    nullifierQueue: PublicKey;
    merkleTree: PublicKey;
    merkleTreeHeight: number;
    addressTree: PublicKey;
    addressQueue: PublicKey;
};
/**
 * @internal testing only
 */
declare const defaultTestStateTreeAccounts2: () => {
    nullifierQueue2: PublicKey;
    merkleTree2: PublicKey;
};
declare const stateTreeLookupTableMainnet = "7i86eQs3GSqHjN47WdWLTCGMW6gde1q96G2EVnUyK2st";
declare const nullifiedStateTreeLookupTableMainnet = "H9QD4u1fG7KmkAzn2tDXhheushxFe1EcrjGGyEFXeMqT";
declare const stateTreeLookupTableDevnet = "8n8rH2bFRVA6cSGNDpgqcKHCndbFCT1bXxAQG89ejVsh";
declare const nullifiedStateTreeLookupTableDevnet = "5dhaJLBjnVBQFErr8oiCJmcVsx3Zj6xDekGB2zULPsnP";
declare const nullifierQueuePubkey = "nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148";
declare const cpiContextPubkey = "cpi1uHzrEhBG733DoEJNgHCyRS3XmmyVNZx5fonubE4";
declare const merkletreePubkey = "smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT";
declare const addressTree = "amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2";
declare const addressQueue = "aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F";
declare const merkleTree2Pubkey = "smt2rJAFdyJJupwMKAqTNAJwvjhmiZ4JYGZmbVRw1Ho";
declare const nullifierQueue2Pubkey = "nfq2hgS7NYemXsFaFUCe3EMXSDSfnZnAe27jC6aPP1X";
declare const cpiContext2Pubkey = "cpi2cdhkH5roePvcudTgUL8ppEBfTay1desGh8G8QxK";
declare const confirmConfig: ConfirmOptions;
declare const DEFAULT_MERKLE_TREE_HEIGHT = 26;
declare const DEFAULT_MERKLE_TREE_ROOTS = 2800;
/** Threshold (per asset) at which new in-UTXOs get merged, in order to reduce UTXO pool size */
declare const UTXO_MERGE_THRESHOLD = 20;
declare const UTXO_MERGE_MAXIMUM = 10;
/**
 * Treshold after which the currently used transaction Merkle tree is switched
 * to the next one
 */
declare const TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD: BN;
/**
 * Fee to provide continous funding for the state Merkle tree.
 * Once the state Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next state Merkle tree with the same parameters.
 *
 * Is charged per output compressed account.
 */
declare const STATE_MERKLE_TREE_ROLLOVER_FEE: BN;
/**
 * Fee to provide continous funding for the address queue and address Merkle tree.
 * Once the address Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next address queue and address tree with the same parameters.
 *
 * Is charged per newly created address.
 */
declare const ADDRESS_QUEUE_ROLLOVER_FEE: BN;
/**
 * Is charged if the transaction nullifies at least one compressed account.
 */
declare const STATE_MERKLE_TREE_NETWORK_FEE: BN;
/**
 * Is charged if the transaction creates at least one address.
 */
declare const ADDRESS_TREE_NETWORK_FEE: BN;

declare enum UtxoErrorCode {
    NEGATIVE_LAMPORTS = "NEGATIVE_LAMPORTS",
    NOT_U64 = "NOT_U64",
    BLINDING_EXCEEDS_FIELD_SIZE = "BLINDING_EXCEEDS_FIELD_SIZE"
}
declare enum SelectInUtxosErrorCode {
    FAILED_TO_FIND_UTXO_COMBINATION = "FAILED_TO_FIND_UTXO_COMBINATION",
    INVALID_NUMBER_OF_IN_UTXOS = "INVALID_NUMBER_OF_IN_UTXOS"
}
declare enum CreateUtxoErrorCode {
    OWNER_UNDEFINED = "OWNER_UNDEFINED",
    INVALID_OUTPUT_UTXO_LENGTH = "INVALID_OUTPUT_UTXO_LENGTH",
    UTXO_DATA_UNDEFINED = "UTXO_DATA_UNDEFINED"
}
declare enum RpcErrorCode {
    CONNECTION_UNDEFINED = "CONNECTION_UNDEFINED",
    RPC_PUBKEY_UNDEFINED = "RPC_PUBKEY_UNDEFINED",
    RPC_METHOD_NOT_IMPLEMENTED = "RPC_METHOD_NOT_IMPLEMENTED",
    RPC_INVALID = "RPC_INVALID"
}
declare enum LookupTableErrorCode {
    LOOK_UP_TABLE_UNDEFINED = "LOOK_UP_TABLE_UNDEFINED",
    LOOK_UP_TABLE_NOT_INITIALIZED = "LOOK_UP_TABLE_NOT_INITIALIZED"
}
declare enum HashErrorCode {
    NO_POSEIDON_HASHER_PROVIDED = "NO_POSEIDON_HASHER_PROVIDED"
}
declare enum ProofErrorCode {
    INVALID_PROOF = "INVALID_PROOF",
    PROOF_INPUT_UNDEFINED = "PROOF_INPUT_UNDEFINED",
    PROOF_GENERATION_FAILED = "PROOF_GENERATION_FAILED"
}
declare enum MerkleTreeErrorCode {
    MERKLE_TREE_NOT_INITIALIZED = "MERKLE_TREE_NOT_INITIALIZED",
    SOL_MERKLE_TREE_UNDEFINED = "SOL_MERKLE_TREE_UNDEFINED",
    MERKLE_TREE_UNDEFINED = "MERKLE_TREE_UNDEFINED",
    INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE = "INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE",
    MERKLE_TREE_INDEX_UNDEFINED = "MERKLE_TREE_INDEX_UNDEFINED",
    MERKLE_TREE_SET_SPACE_UNDEFINED = "MERKLE_TREE_SET_SPACE_UNDEFINED"
}
declare enum UtilsErrorCode {
    ACCOUNT_NAME_UNDEFINED_IN_IDL = "ACCOUNT_NAME_UNDEFINED_IN_IDL",
    PROPERTY_UNDEFINED = "PROPERTY_UNDEFINED",
    LOOK_UP_TABLE_CREATION_FAILED = "LOOK_UP_TABLE_CREATION_FAILED",
    UNSUPPORTED_ARCHITECTURE = "UNSUPPORTED_ARCHITECTURE",
    UNSUPPORTED_PLATFORM = "UNSUPPORTED_PLATFORM",
    ACCOUNTS_UNDEFINED = "ACCOUNTS_UNDEFINED",
    INVALID_NUMBER = "INVALID_NUMBER"
}
declare class MetaError extends Error {
    code: string;
    functionName: string;
    codeMessage?: string;
    constructor(code: string, functionName: string, codeMessage?: string);
}
declare class UtxoError extends MetaError {
}
declare class SelectInUtxosError extends MetaError {
}
declare class CreateUtxoError extends MetaError {
}
declare class RpcError extends MetaError {
}
declare class LookupTableError extends MetaError {
}
declare class HashError extends MetaError {
}
declare class ProofError extends MetaError {
}
declare class MerkleTreeError extends MetaError {
}
declare class UtilsError extends MetaError {
}

type LightSystemProgram = {
    version: '1.2.0';
    name: 'light_system_program';
    constants: [
        {
            name: 'SOL_POOL_PDA_SEED';
            type: 'bytes';
            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]';
        }
    ];
    instructions: [
        {
            name: 'initCpiContextAccount';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'associatedMerkleTree';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'invoke';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                    docs: [
                        'This pda is used to invoke the account compression program.'
                    ];
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['Merkle trees.'];
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol."
                    ];
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.'
                    ];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'invokeCpi';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'invokingProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'invokeCpiWithReadOnly';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'invokingProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                    docs: [
                        'This pda is used to invoke the account compression program.'
                    ];
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['Merkle trees.'];
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol."
                    ];
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.'
                    ];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'InstructionDataInvoke';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'InstructionDataInvokeCpi';
                    };
                },
                {
                    name: 'inputs3';
                    type: {
                        defined: 'PublicTransactionEvent';
                    };
                }
            ];
        }
    ];
    accounts: [
        {
            name: 'cpiContextAccount';
            docs: [
                'Collects instruction data without executing a compressed transaction.',
                'Signer checks are performed on instruction data.',
                'Collected instruction data is combined with the instruction data of the executing cpi,',
                'and executed as a single transaction.',
                'This enables to use input compressed accounts that are owned by multiple programs,',
                'with one zero-knowledge proof.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'feePayer';
                        type: 'publicKey';
                    },
                    {
                        name: 'associatedMerkleTree';
                        type: 'publicKey';
                    },
                    {
                        name: 'context';
                        type: {
                            vec: {
                                defined: 'InstructionDataInvokeCpi';
                            };
                        };
                    }
                ];
            };
        }
    ];
    types: [
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'queueIndex';
                        type: {
                            option: {
                                defined: 'QueueIndex';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'SumCheckFailed';
            msg: 'Sum check failed';
        },
        {
            code: 6001;
            name: 'SignerCheckFailed';
            msg: 'Signer check failed';
        },
        {
            code: 6002;
            name: 'CpiSignerCheckFailed';
            msg: 'Cpi signer check failed';
        },
        {
            code: 6003;
            name: 'ComputeInputSumFailed';
            msg: 'Computing input sum failed.';
        },
        {
            code: 6004;
            name: 'ComputeOutputSumFailed';
            msg: 'Computing output sum failed.';
        },
        {
            code: 6005;
            name: 'ComputeRpcSumFailed';
            msg: 'Computing rpc sum failed.';
        },
        {
            code: 6006;
            name: 'InvalidAddress';
            msg: 'InvalidAddress';
        },
        {
            code: 6007;
            name: 'DeriveAddressError';
            msg: 'DeriveAddressError';
        },
        {
            code: 6008;
            name: 'CompressedSolPdaUndefinedForCompressSol';
            msg: 'CompressedSolPdaUndefinedForCompressSol';
        },
        {
            code: 6009;
            name: 'DeCompressLamportsUndefinedForCompressSol';
            msg: 'DeCompressLamportsUndefinedForCompressSol';
        },
        {
            code: 6010;
            name: 'CompressedSolPdaUndefinedForDecompressSol';
            msg: 'CompressedSolPdaUndefinedForDecompressSol';
        },
        {
            code: 6011;
            name: 'DeCompressLamportsUndefinedForDecompressSol';
            msg: 'DeCompressLamportsUndefinedForDecompressSol';
        },
        {
            code: 6012;
            name: 'DecompressRecipientUndefinedForDecompressSol';
            msg: 'DecompressRecipientUndefinedForDecompressSol';
        },
        {
            code: 6013;
            name: 'WriteAccessCheckFailed';
            msg: 'WriteAccessCheckFailed';
        },
        {
            code: 6014;
            name: 'InvokingProgramNotProvided';
            msg: 'InvokingProgramNotProvided';
        },
        {
            code: 6015;
            name: 'InvalidCapacity';
            msg: 'InvalidCapacity';
        },
        {
            code: 6016;
            name: 'InvalidMerkleTreeOwner';
            msg: 'InvalidMerkleTreeOwner';
        },
        {
            code: 6017;
            name: 'ProofIsNone';
            msg: 'ProofIsNone';
        },
        {
            code: 6018;
            name: 'ProofIsSome';
            msg: 'Proof is some but no input compressed accounts or new addresses provided.';
        },
        {
            code: 6019;
            name: 'EmptyInputs';
            msg: 'EmptyInputs';
        },
        {
            code: 6020;
            name: 'CpiContextAccountUndefined';
            msg: 'CpiContextAccountUndefined';
        },
        {
            code: 6021;
            name: 'CpiContextEmpty';
            msg: 'CpiContextEmpty';
        },
        {
            code: 6022;
            name: 'CpiContextMissing';
            msg: 'CpiContextMissing';
        },
        {
            code: 6023;
            name: 'DecompressionRecipientDefined';
            msg: 'DecompressionRecipientDefined';
        },
        {
            code: 6024;
            name: 'SolPoolPdaDefined';
            msg: 'SolPoolPdaDefined';
        },
        {
            code: 6025;
            name: 'AppendStateFailed';
            msg: 'AppendStateFailed';
        },
        {
            code: 6026;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6027;
            name: 'CpiContextFeePayerMismatch';
            msg: 'CpiContextFeePayerMismatch';
        },
        {
            code: 6028;
            name: 'CpiContextAssociatedMerkleTreeMismatch';
            msg: 'CpiContextAssociatedMerkleTreeMismatch';
        },
        {
            code: 6029;
            name: 'NoInputs';
            msg: 'NoInputs';
        },
        {
            code: 6030;
            name: 'InputMerkleTreeIndicesNotInOrder';
            msg: 'Input merkle tree indices are not in ascending order.';
        },
        {
            code: 6031;
            name: 'OutputMerkleTreeIndicesNotInOrder';
            msg: 'Output merkle tree indices are not in ascending order.';
        },
        {
            code: 6032;
            name: 'OutputMerkleTreeNotUnique';
        },
        {
            code: 6033;
            name: 'DataFieldUndefined';
        },
        {
            code: 6034;
            name: 'ReadOnlyAddressAlreadyExists';
        },
        {
            code: 6035;
            name: 'ReadOnlyAccountDoesNotExist';
        },
        {
            code: 6036;
            name: 'HashChainInputsLenghtInconsistent';
        },
        {
            code: 6037;
            name: 'InvalidAddressTreeHeight';
        },
        {
            code: 6038;
            name: 'InvalidStateTreeHeight';
        }
    ];
};
declare const IDL: LightSystemProgram;

export { ADDRESS_QUEUE_ROLLOVER_FEE, ADDRESS_TREE_NETWORK_FEE, ALICE, AccountProofResult, type ActiveTreeBundle, type AddressWithTree, AppendLeavesInputLayout, AppendNullifyCreateAddressInputsMetaLayout, type BN254, BOB, BalanceResult, CHARLIE, COMPUTE_BUDGET_PATTERN, type ClientSubscriptionId, type CompressedAccount, type CompressedAccountData, CompressedAccountLayout, CompressedAccountResult, type CompressedAccountWithMerkleContext, CompressedAccountsByOwnerResult, type CompressedCpiContext, type CompressedMintTokenHolders, CompressedMintTokenHoldersResult, type CompressedProof, type CompressedProofWithContext, CompressedTokenAccountResult, CompressedTokenAccountsByOwnerOrDelegateResult, type CompressedTransaction, CompressedTransactionResult, type CompressionApiInterface, CreateUtxoError, CreateUtxoErrorCode, DAVE, DEFAULT_MERKLE_TREE_HEIGHT, DEFAULT_MERKLE_TREE_ROOTS, DEFAULT_ZERO, type EventWithParsedTokenTlvData, FIELD_SIZE, type GetCompressedAccountConfig, type GetCompressedAccountsByOwnerConfig, type GetCompressedAccountsConfig, type GetCompressedAccountsFilter, type GetCompressedTokenAccountsByOwnerOrDelegateOptions, HIGHEST_ADDRESS_PLUS_ONE, HashError, HashErrorCode, type HashWithTree, HealthResult, type HexBatchInputsForProver, type HexInputsForProver, IDL, INSERT_INTO_QUEUES_DISCRIMINATOR, INVOKE_CPI_DISCRIMINATOR, INVOKE_DISCRIMINATOR, IndexedArray, IndexedElement, IndexedElementBundle, type InputTokenDataWithContext, InsertAddressInputLayout, InsertNullifierInputLayout, type InstructionDataInvoke, type InstructionDataInvokeCpi, InstructionDataInvokeCpiLayout, InstructionDataInvokeLayout, type LatestNonVotingSignatures, type LatestNonVotingSignaturesPaginated, LatestNonVotingSignaturesResult, LatestNonVotingSignaturesResultPaginated, LightSystemProgram$1 as LightSystemProgram, type LightSystemProgram as LightSystemProgramIDL, type LightWasm, LookupTableError, LookupTableErrorCode, MerkeProofResult, type MerkleContext, MerkleContextLayout, type MerkleContextWithMerkleProof, type MerkleContextWithNewAddressProof, MerkleTree, MerkleTreeError, MerkleTreeErrorCode, type MerkleTreeSequenceNumber, MerkleTreeSequenceNumberLayout, MultipleCompressedAccountsResult, MultipleMerkleProofsResult, NativeBalanceResult, type NewAddressParams, NewAddressParamsLayout, type NewAddressParamsPacked, NewAddressProofResult, type NonInclusionJsonStruct, type NonInclusionMerkleProofInputs, type OutputCompressedAccountWithPackedContext, type PackedCompressedAccountWithMerkleContext, type PackedMerkleContext, type PaginatedOptions, type ParsedTokenAccount, ProofError, ProofErrorCode, type PublicTransactionEvent, PublicTransactionEventLayout, type QueueIndex, Rpc, RpcError, RpcErrorCode, type RpcResult, type RpcResultError, type RpcResultSuccess, STATE_MERKLE_TREE_NETWORK_FEE, STATE_MERKLE_TREE_ROLLOVER_FEE, SelectInUtxosError, SelectInUtxosErrorCode, SignatureListResult, SignatureListWithCursorResult, type SignatureWithMetadata, SlotResult, type StateTreeLUTPair, TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD, TestRpc, type TestRpcConfig, type TokenBalance, TokenBalanceListResult, TokenBalanceListResultV2, TokenBalanceResult, type TokenData$1 as TokenData, TokenDataLayout, TokenDataResult, TreeType, UTXO_MERGE_MAXIMUM, UTXO_MERGE_THRESHOLD, UtilsError, UtilsErrorCode, UtxoError, UtxoErrorCode, ValidityProofResult, type WithContext, type WithCursor, type WithRpcContext, accountCompressionProgram, addressQueue, addressTree, airdropSol, bn, bufToDecStr, buildAndSignTx, buildTx, byteArrayToKeypair, calculateComputeUnitPrice, checkValidityProofShape, compress, confirmConfig, confirmTransaction, confirmTx, convertMerkleProofsWithContextToHex, convertNonInclusionMerkleProofInputsToHex, convertToPublicTransactionEvent, cpiContext2Pubkey, cpiContextPubkey, createAccount, createAccountWithLamports, createBN254, createCompressedAccount, createCompressedAccountWithMerkleContext, createMerkleContext, createRpc, createRpcResult, createStateTreeLookupTable, decodeInstructionDataInvoke, decodeInstructionDataInvokeCpi, decodePublicTransactionEvent, decompress, dedupeSigner, deepEqual, defaultStateTreeLookupTables, defaultStaticAccounts, defaultStaticAccountsStruct, defaultTestStateTreeAccounts, defaultTestStateTreeAccounts2, deriveAddress, deriveAddressSeed, deserializeAppendNullifyCreateAddressInputsIndexer, encodeBN254toBase58, encodeInstructionDataInvoke, encodePublicTransactionEvent, extendStateTreeLookupTable, getAccountCompressionAuthority, getCompressedTokenAccountByHashTest, getCompressedTokenAccounts, getCompressedTokenAccountsByDelegateTest, getCompressedTokenAccountsByOwnerTest, getConnection, getIndexOrAdd, getLightStateTreeInfo, getParsedEvents, getPublicInputHash, getQueueForTree, getRegisteredProgramPda, getTestKeypair, getTestRpc, getTreeForQueue, hashToBn254FieldSizeBe, hashvToBn254FieldSizeBe, invokeAccountsLayout, type invokeAccountsLayoutParams, isLocalTest, isSmallerThanBn254FieldSizeBe, jsonRpcResult, jsonRpcResultAndContext, lightProgram, localTestActiveStateTreeInfo, merkleTree2Pubkey, merkletreePubkey, negateAndCompressProof, newAccountWithLamports, noopProgram, nullifiedStateTreeLookupTableDevnet, nullifiedStateTreeLookupTableMainnet, nullifierQueue2Pubkey, nullifierQueuePubkey, nullifyLookupTable, packCompressedAccounts, packNewAddressParams, padOutputStateMerkleTrees, parseAccountData, parseEvents, parseLightTransaction, parsePublicTransactionEventWithIdl, parseTokenLayoutWithIdl, pickRandomTreeAndQueue, pipe, placeholderValidityProof, proofFromJsonStruct, proverRequest, pushUniqueItems, rpcRequest, selectMinCompressedSolAccountsForTransfer, sendAndConfirmTx, sleep, stateTreeLookupTableDevnet, stateTreeLookupTableMainnet, sumUpLamports, toAccountMetas, toArray, toCamelCase, toHex, toUnixTimestamp, transfer, validateNumbers, validateNumbersForInclusionProof, validateNumbersForNonInclusionProof, validateNumbersForProof, validateSameOwner, validateSufficientBalance, wrapBigNumbersAsStrings };
