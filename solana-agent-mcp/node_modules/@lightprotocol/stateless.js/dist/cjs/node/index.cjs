"use strict";var e=require("@solana/web3.js"),t=require("buffer"),r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var o={exports:{}};!function(e,t){function r(e,t){if(!e)throw new Error(t||"Assertion failed")}function n(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}function s(e,t,r){if(s.isBN(e))return e;this.negative=0,this.words=null,this.length=0,this.red=null,null!==e&&("le"!==t&&"be"!==t||(r=t,t=10),this._init(e||0,t||10,r||"be"))}var i;"object"==typeof o?o.exports=s:t.BN=s,s.BN=s,s.wordSize=26;try{i="undefined"!=typeof window&&void 0!==window.Buffer?window.Buffer:require("buffer").Buffer}catch(e){}function a(e,t){var n=e.charCodeAt(t);return n>=48&&n<=57?n-48:n>=65&&n<=70?n-55:n>=97&&n<=102?n-87:void r(0,"Invalid character in "+e)}function u(e,t,r){var n=a(e,r);return r-1>=t&&(n|=a(e,r-1)<<4),n}function l(e,t,n,o){for(var s=0,i=0,a=Math.min(e.length,n),u=t;u<a;u++){var l=e.charCodeAt(u)-48;s*=o,i=l>=49?l-49+10:l>=17?l-17+10:l,r(l>=0&&i<o,"Invalid character"),s+=i}return s}function c(e,t){e.words=t.words,e.length=t.length,e.negative=t.negative,e.red=t.red}if(s.isBN=function(e){return e instanceof s?1:null!==e&&"object"==typeof e&&e.constructor.wordSize===s.wordSize&&Array.isArray(e.words)},s.max=function(e,t){return e.cmp(t)>0?e:t},s.min=function(e,t){return e.cmp(t)<0?e:t},s.prototype._init=function(e,t,n){if("number"==typeof e)return this._initNumber(e,t,n);if("object"==typeof e)return this._initArray(e,t,n);"hex"===t&&(t=16),r(t===(0|t)&&t>=2&&t<=36);var o=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&(o++,this.negative=1),o<e.length&&(16===t?this._parseHex(e,o,n):(this._parseBase(e,t,o),"le"===n&&this._initArray(this.toArray(),t,n)))},s.prototype._initNumber=function(e,t,n){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(r(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===n&&this._initArray(this.toArray(),t,n)},s.prototype._initArray=function(e,t,n){if(r("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var o=0;o<this.length;o++)this.words[o]=0;var s,i,a=0;if("be"===n)for(o=e.length-1,s=0;o>=0;o-=3)i=e[o]|e[o-1]<<8|e[o-2]<<16,this.words[s]|=i<<a&67108863,this.words[s+1]=i>>>26-a&67108863,(a+=24)>=26&&(a-=26,s++);else if("le"===n)for(o=0,s=0;o<e.length;o+=3)i=e[o]|e[o+1]<<8|e[o+2]<<16,this.words[s]|=i<<a&67108863,this.words[s+1]=i>>>26-a&67108863,(a+=24)>=26&&(a-=26,s++);return this._strip()},s.prototype._parseHex=function(e,t,r){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var n=0;n<this.length;n++)this.words[n]=0;var o,s=0,i=0;if("be"===r)for(n=e.length-1;n>=t;n-=2)o=u(e,t,n)<<s,this.words[i]|=67108863&o,s>=18?(s-=18,i+=1,this.words[i]|=o>>>26):s+=8;else for(n=(e.length-t)%2==0?t+1:t;n<e.length;n+=2)o=u(e,t,n)<<s,this.words[i]|=67108863&o,s>=18?(s-=18,i+=1,this.words[i]|=o>>>26):s+=8;this._strip()},s.prototype._parseBase=function(e,t,r){this.words=[0],this.length=1;for(var n=0,o=1;o<=67108863;o*=t)n++;n--,o=o/t|0;for(var s=e.length-r,i=s%n,a=Math.min(s,s-i)+r,u=0,c=r;c<a;c+=n)u=l(e,c,c+n,t),this.imuln(o),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);if(0!==i){var d=1;for(u=l(e,c,e.length,t),c=0;c<i;c++)d*=t;this.imuln(d),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u)}this._strip()},s.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},s.prototype._move=function(e){c(e,this)},s.prototype.clone=function(){var e=new s(null);return this.copy(e),e},s.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},s.prototype._strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},s.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},"undefined"!=typeof Symbol&&"function"==typeof Symbol.for)try{s.prototype[Symbol.for("nodejs.util.inspect.custom")]=d}catch(e){s.prototype.inspect=d}else s.prototype.inspect=d;function d(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var h=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],p=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],m=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function f(e,t,r){r.negative=t.negative^e.negative;var n=e.length+t.length|0;r.length=n,n=n-1|0;var o=0|e.words[0],s=0|t.words[0],i=o*s,a=67108863&i,u=i/67108864|0;r.words[0]=a;for(var l=1;l<n;l++){for(var c=u>>>26,d=67108863&u,h=Math.min(l,t.length-1),p=Math.max(0,l-e.length+1);p<=h;p++){var m=l-p|0;c+=(i=(o=0|e.words[m])*(s=0|t.words[p])+d)/67108864|0,d=67108863&i}r.words[l]=0|d,u=0|c}return 0!==u?r.words[l]=0|u:r.length--,r._strip()}s.prototype.toString=function(e,t){var n;if(t=0|t||1,16===(e=e||10)||"hex"===e){n="";for(var o=0,s=0,i=0;i<this.length;i++){var a=this.words[i],u=(16777215&(a<<o|s)).toString(16);s=a>>>24-o&16777215,(o+=2)>=26&&(o-=26,i--),n=0!==s||i!==this.length-1?h[6-u.length]+u+n:u+n}for(0!==s&&(n=s.toString(16)+n);n.length%t!=0;)n="0"+n;return 0!==this.negative&&(n="-"+n),n}if(e===(0|e)&&e>=2&&e<=36){var l=p[e],c=m[e];n="";var d=this.clone();for(d.negative=0;!d.isZero();){var f=d.modrn(c).toString(e);n=(d=d.idivn(c)).isZero()?f+n:h[l-f.length]+f+n}for(this.isZero()&&(n="0"+n);n.length%t!=0;)n="0"+n;return 0!==this.negative&&(n="-"+n),n}r(0,"Base should be between 2 and 36")},s.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:this.length>2&&r(0,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},s.prototype.toJSON=function(){return this.toString(16,2)},i&&(s.prototype.toBuffer=function(e,t){return this.toArrayLike(i,e,t)}),s.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},s.prototype.toArrayLike=function(e,t,n){this._strip();var o=this.byteLength(),s=n||Math.max(1,o);r(o<=s,"byte array longer than desired length"),r(s>0,"Requested array length <= 0");var i=function(e,t){return e.allocUnsafe?e.allocUnsafe(t):new e(t)}(e,s);return this["_toArrayLike"+("le"===t?"LE":"BE")](i,o),i},s.prototype._toArrayLikeLE=function(e){for(var t=0,r=0,n=0,o=0;n<this.length;n++){var s=this.words[n]<<o|r;e[t++]=255&s,t<e.length&&(e[t++]=s>>8&255),t<e.length&&(e[t++]=s>>16&255),6===o?(t<e.length&&(e[t++]=s>>24&255),r=0,o=0):(r=s>>>24,o+=2)}if(t<e.length)for(e[t++]=r;t<e.length;)e[t++]=0},s.prototype._toArrayLikeBE=function(e){for(var t=e.length-1,r=0,n=0,o=0;n<this.length;n++){var s=this.words[n]<<o|r;e[t--]=255&s,t>=0&&(e[t--]=s>>8&255),t>=0&&(e[t--]=s>>16&255),6===o?(t>=0&&(e[t--]=s>>24&255),r=0,o=0):(r=s>>>24,o+=2)}if(t>=0)for(e[t--]=r;t>=0;)e[t--]=0},Math.clz32?s.prototype._countBits=function(e){return 32-Math.clz32(e)}:s.prototype._countBits=function(e){var t=e,r=0;return t>=4096&&(r+=13,t>>>=13),t>=64&&(r+=7,t>>>=7),t>=8&&(r+=4,t>>>=4),t>=2&&(r+=2,t>>>=2),r+t},s.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0==(8191&t)&&(r+=13,t>>>=13),0==(127&t)&&(r+=7,t>>>=7),0==(15&t)&&(r+=4,t>>>=4),0==(3&t)&&(r+=2,t>>>=2),0==(1&t)&&r++,r},s.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},s.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},s.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},s.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},s.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},s.prototype.isNeg=function(){return 0!==this.negative},s.prototype.neg=function(){return this.clone().ineg()},s.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},s.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this._strip()},s.prototype.ior=function(e){return r(0==(this.negative|e.negative)),this.iuor(e)},s.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},s.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},s.prototype.iuand=function(e){var t;t=this.length>e.length?e:this;for(var r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this._strip()},s.prototype.iand=function(e){return r(0==(this.negative|e.negative)),this.iuand(e)},s.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},s.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},s.prototype.iuxor=function(e){var t,r;this.length>e.length?(t=this,r=e):(t=e,r=this);for(var n=0;n<r.length;n++)this.words[n]=t.words[n]^r.words[n];if(this!==t)for(;n<t.length;n++)this.words[n]=t.words[n];return this.length=t.length,this._strip()},s.prototype.ixor=function(e){return r(0==(this.negative|e.negative)),this.iuxor(e)},s.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},s.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},s.prototype.inotn=function(e){r("number"==typeof e&&e>=0);var t=0|Math.ceil(e/26),n=e%26;this._expand(t),n>0&&t--;for(var o=0;o<t;o++)this.words[o]=67108863&~this.words[o];return n>0&&(this.words[o]=~this.words[o]&67108863>>26-n),this._strip()},s.prototype.notn=function(e){return this.clone().inotn(e)},s.prototype.setn=function(e,t){r("number"==typeof e&&e>=0);var n=e/26|0,o=e%26;return this._expand(n+1),this.words[n]=t?this.words[n]|1<<o:this.words[n]&~(1<<o),this._strip()},s.prototype.iadd=function(e){var t,r,n;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();this.length>e.length?(r=this,n=e):(r=e,n=this);for(var o=0,s=0;s<n.length;s++)t=(0|r.words[s])+(0|n.words[s])+o,this.words[s]=67108863&t,o=t>>>26;for(;0!==o&&s<r.length;s++)t=(0|r.words[s])+o,this.words[s]=67108863&t,o=t>>>26;if(this.length=r.length,0!==o)this.words[this.length]=o,this.length++;else if(r!==this)for(;s<r.length;s++)this.words[s]=r.words[s];return this},s.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},s.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r,n,o=this.cmp(e);if(0===o)return this.negative=0,this.length=1,this.words[0]=0,this;o>0?(r=this,n=e):(r=e,n=this);for(var s=0,i=0;i<n.length;i++)s=(t=(0|r.words[i])-(0|n.words[i])+s)>>26,this.words[i]=67108863&t;for(;0!==s&&i<r.length;i++)s=(t=(0|r.words[i])+s)>>26,this.words[i]=67108863&t;if(0===s&&i<r.length&&r!==this)for(;i<r.length;i++)this.words[i]=r.words[i];return this.length=Math.max(this.length,i),r!==this&&(this.negative=1),this._strip()},s.prototype.sub=function(e){return this.clone().isub(e)};var g=function(e,t,r){var n,o,s,i=e.words,a=t.words,u=r.words,l=0,c=0|i[0],d=8191&c,h=c>>>13,p=0|i[1],m=8191&p,f=p>>>13,g=0|i[2],y=8191&g,w=g>>>13,v=0|i[3],b=8191&v,x=v>>>13,E=0|i[4],M=8191&E,A=E>>>13,I=0|i[5],T=8191&I,S=I>>>13,k=0|i[6],C=8191&k,_=k>>>13,P=0|i[7],N=8191&P,L=P>>>13,O=0|i[8],B=8191&O,R=O>>>13,D=0|i[9],U=8191&D,F=D>>>13,q=0|a[0],K=8191&q,V=q>>>13,H=0|a[1],$=8191&H,j=H>>>13,Q=0|a[2],z=8191&Q,W=Q>>>13,J=0|a[3],Z=8191&J,G=J>>>13,X=0|a[4],Y=8191&X,ee=X>>>13,te=0|a[5],re=8191&te,ne=te>>>13,oe=0|a[6],se=8191&oe,ie=oe>>>13,ae=0|a[7],ue=8191&ae,le=ae>>>13,ce=0|a[8],de=8191&ce,he=ce>>>13,pe=0|a[9],me=8191&pe,fe=pe>>>13;r.negative=e.negative^t.negative,r.length=19;var ge=(l+(n=Math.imul(d,K))|0)+((8191&(o=(o=Math.imul(d,V))+Math.imul(h,K)|0))<<13)|0;l=((s=Math.imul(h,V))+(o>>>13)|0)+(ge>>>26)|0,ge&=67108863,n=Math.imul(m,K),o=(o=Math.imul(m,V))+Math.imul(f,K)|0,s=Math.imul(f,V);var ye=(l+(n=n+Math.imul(d,$)|0)|0)+((8191&(o=(o=o+Math.imul(d,j)|0)+Math.imul(h,$)|0))<<13)|0;l=((s=s+Math.imul(h,j)|0)+(o>>>13)|0)+(ye>>>26)|0,ye&=67108863,n=Math.imul(y,K),o=(o=Math.imul(y,V))+Math.imul(w,K)|0,s=Math.imul(w,V),n=n+Math.imul(m,$)|0,o=(o=o+Math.imul(m,j)|0)+Math.imul(f,$)|0,s=s+Math.imul(f,j)|0;var we=(l+(n=n+Math.imul(d,z)|0)|0)+((8191&(o=(o=o+Math.imul(d,W)|0)+Math.imul(h,z)|0))<<13)|0;l=((s=s+Math.imul(h,W)|0)+(o>>>13)|0)+(we>>>26)|0,we&=67108863,n=Math.imul(b,K),o=(o=Math.imul(b,V))+Math.imul(x,K)|0,s=Math.imul(x,V),n=n+Math.imul(y,$)|0,o=(o=o+Math.imul(y,j)|0)+Math.imul(w,$)|0,s=s+Math.imul(w,j)|0,n=n+Math.imul(m,z)|0,o=(o=o+Math.imul(m,W)|0)+Math.imul(f,z)|0,s=s+Math.imul(f,W)|0;var ve=(l+(n=n+Math.imul(d,Z)|0)|0)+((8191&(o=(o=o+Math.imul(d,G)|0)+Math.imul(h,Z)|0))<<13)|0;l=((s=s+Math.imul(h,G)|0)+(o>>>13)|0)+(ve>>>26)|0,ve&=67108863,n=Math.imul(M,K),o=(o=Math.imul(M,V))+Math.imul(A,K)|0,s=Math.imul(A,V),n=n+Math.imul(b,$)|0,o=(o=o+Math.imul(b,j)|0)+Math.imul(x,$)|0,s=s+Math.imul(x,j)|0,n=n+Math.imul(y,z)|0,o=(o=o+Math.imul(y,W)|0)+Math.imul(w,z)|0,s=s+Math.imul(w,W)|0,n=n+Math.imul(m,Z)|0,o=(o=o+Math.imul(m,G)|0)+Math.imul(f,Z)|0,s=s+Math.imul(f,G)|0;var be=(l+(n=n+Math.imul(d,Y)|0)|0)+((8191&(o=(o=o+Math.imul(d,ee)|0)+Math.imul(h,Y)|0))<<13)|0;l=((s=s+Math.imul(h,ee)|0)+(o>>>13)|0)+(be>>>26)|0,be&=67108863,n=Math.imul(T,K),o=(o=Math.imul(T,V))+Math.imul(S,K)|0,s=Math.imul(S,V),n=n+Math.imul(M,$)|0,o=(o=o+Math.imul(M,j)|0)+Math.imul(A,$)|0,s=s+Math.imul(A,j)|0,n=n+Math.imul(b,z)|0,o=(o=o+Math.imul(b,W)|0)+Math.imul(x,z)|0,s=s+Math.imul(x,W)|0,n=n+Math.imul(y,Z)|0,o=(o=o+Math.imul(y,G)|0)+Math.imul(w,Z)|0,s=s+Math.imul(w,G)|0,n=n+Math.imul(m,Y)|0,o=(o=o+Math.imul(m,ee)|0)+Math.imul(f,Y)|0,s=s+Math.imul(f,ee)|0;var xe=(l+(n=n+Math.imul(d,re)|0)|0)+((8191&(o=(o=o+Math.imul(d,ne)|0)+Math.imul(h,re)|0))<<13)|0;l=((s=s+Math.imul(h,ne)|0)+(o>>>13)|0)+(xe>>>26)|0,xe&=67108863,n=Math.imul(C,K),o=(o=Math.imul(C,V))+Math.imul(_,K)|0,s=Math.imul(_,V),n=n+Math.imul(T,$)|0,o=(o=o+Math.imul(T,j)|0)+Math.imul(S,$)|0,s=s+Math.imul(S,j)|0,n=n+Math.imul(M,z)|0,o=(o=o+Math.imul(M,W)|0)+Math.imul(A,z)|0,s=s+Math.imul(A,W)|0,n=n+Math.imul(b,Z)|0,o=(o=o+Math.imul(b,G)|0)+Math.imul(x,Z)|0,s=s+Math.imul(x,G)|0,n=n+Math.imul(y,Y)|0,o=(o=o+Math.imul(y,ee)|0)+Math.imul(w,Y)|0,s=s+Math.imul(w,ee)|0,n=n+Math.imul(m,re)|0,o=(o=o+Math.imul(m,ne)|0)+Math.imul(f,re)|0,s=s+Math.imul(f,ne)|0;var Ee=(l+(n=n+Math.imul(d,se)|0)|0)+((8191&(o=(o=o+Math.imul(d,ie)|0)+Math.imul(h,se)|0))<<13)|0;l=((s=s+Math.imul(h,ie)|0)+(o>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,n=Math.imul(N,K),o=(o=Math.imul(N,V))+Math.imul(L,K)|0,s=Math.imul(L,V),n=n+Math.imul(C,$)|0,o=(o=o+Math.imul(C,j)|0)+Math.imul(_,$)|0,s=s+Math.imul(_,j)|0,n=n+Math.imul(T,z)|0,o=(o=o+Math.imul(T,W)|0)+Math.imul(S,z)|0,s=s+Math.imul(S,W)|0,n=n+Math.imul(M,Z)|0,o=(o=o+Math.imul(M,G)|0)+Math.imul(A,Z)|0,s=s+Math.imul(A,G)|0,n=n+Math.imul(b,Y)|0,o=(o=o+Math.imul(b,ee)|0)+Math.imul(x,Y)|0,s=s+Math.imul(x,ee)|0,n=n+Math.imul(y,re)|0,o=(o=o+Math.imul(y,ne)|0)+Math.imul(w,re)|0,s=s+Math.imul(w,ne)|0,n=n+Math.imul(m,se)|0,o=(o=o+Math.imul(m,ie)|0)+Math.imul(f,se)|0,s=s+Math.imul(f,ie)|0;var Me=(l+(n=n+Math.imul(d,ue)|0)|0)+((8191&(o=(o=o+Math.imul(d,le)|0)+Math.imul(h,ue)|0))<<13)|0;l=((s=s+Math.imul(h,le)|0)+(o>>>13)|0)+(Me>>>26)|0,Me&=67108863,n=Math.imul(B,K),o=(o=Math.imul(B,V))+Math.imul(R,K)|0,s=Math.imul(R,V),n=n+Math.imul(N,$)|0,o=(o=o+Math.imul(N,j)|0)+Math.imul(L,$)|0,s=s+Math.imul(L,j)|0,n=n+Math.imul(C,z)|0,o=(o=o+Math.imul(C,W)|0)+Math.imul(_,z)|0,s=s+Math.imul(_,W)|0,n=n+Math.imul(T,Z)|0,o=(o=o+Math.imul(T,G)|0)+Math.imul(S,Z)|0,s=s+Math.imul(S,G)|0,n=n+Math.imul(M,Y)|0,o=(o=o+Math.imul(M,ee)|0)+Math.imul(A,Y)|0,s=s+Math.imul(A,ee)|0,n=n+Math.imul(b,re)|0,o=(o=o+Math.imul(b,ne)|0)+Math.imul(x,re)|0,s=s+Math.imul(x,ne)|0,n=n+Math.imul(y,se)|0,o=(o=o+Math.imul(y,ie)|0)+Math.imul(w,se)|0,s=s+Math.imul(w,ie)|0,n=n+Math.imul(m,ue)|0,o=(o=o+Math.imul(m,le)|0)+Math.imul(f,ue)|0,s=s+Math.imul(f,le)|0;var Ae=(l+(n=n+Math.imul(d,de)|0)|0)+((8191&(o=(o=o+Math.imul(d,he)|0)+Math.imul(h,de)|0))<<13)|0;l=((s=s+Math.imul(h,he)|0)+(o>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,n=Math.imul(U,K),o=(o=Math.imul(U,V))+Math.imul(F,K)|0,s=Math.imul(F,V),n=n+Math.imul(B,$)|0,o=(o=o+Math.imul(B,j)|0)+Math.imul(R,$)|0,s=s+Math.imul(R,j)|0,n=n+Math.imul(N,z)|0,o=(o=o+Math.imul(N,W)|0)+Math.imul(L,z)|0,s=s+Math.imul(L,W)|0,n=n+Math.imul(C,Z)|0,o=(o=o+Math.imul(C,G)|0)+Math.imul(_,Z)|0,s=s+Math.imul(_,G)|0,n=n+Math.imul(T,Y)|0,o=(o=o+Math.imul(T,ee)|0)+Math.imul(S,Y)|0,s=s+Math.imul(S,ee)|0,n=n+Math.imul(M,re)|0,o=(o=o+Math.imul(M,ne)|0)+Math.imul(A,re)|0,s=s+Math.imul(A,ne)|0,n=n+Math.imul(b,se)|0,o=(o=o+Math.imul(b,ie)|0)+Math.imul(x,se)|0,s=s+Math.imul(x,ie)|0,n=n+Math.imul(y,ue)|0,o=(o=o+Math.imul(y,le)|0)+Math.imul(w,ue)|0,s=s+Math.imul(w,le)|0,n=n+Math.imul(m,de)|0,o=(o=o+Math.imul(m,he)|0)+Math.imul(f,de)|0,s=s+Math.imul(f,he)|0;var Ie=(l+(n=n+Math.imul(d,me)|0)|0)+((8191&(o=(o=o+Math.imul(d,fe)|0)+Math.imul(h,me)|0))<<13)|0;l=((s=s+Math.imul(h,fe)|0)+(o>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,n=Math.imul(U,$),o=(o=Math.imul(U,j))+Math.imul(F,$)|0,s=Math.imul(F,j),n=n+Math.imul(B,z)|0,o=(o=o+Math.imul(B,W)|0)+Math.imul(R,z)|0,s=s+Math.imul(R,W)|0,n=n+Math.imul(N,Z)|0,o=(o=o+Math.imul(N,G)|0)+Math.imul(L,Z)|0,s=s+Math.imul(L,G)|0,n=n+Math.imul(C,Y)|0,o=(o=o+Math.imul(C,ee)|0)+Math.imul(_,Y)|0,s=s+Math.imul(_,ee)|0,n=n+Math.imul(T,re)|0,o=(o=o+Math.imul(T,ne)|0)+Math.imul(S,re)|0,s=s+Math.imul(S,ne)|0,n=n+Math.imul(M,se)|0,o=(o=o+Math.imul(M,ie)|0)+Math.imul(A,se)|0,s=s+Math.imul(A,ie)|0,n=n+Math.imul(b,ue)|0,o=(o=o+Math.imul(b,le)|0)+Math.imul(x,ue)|0,s=s+Math.imul(x,le)|0,n=n+Math.imul(y,de)|0,o=(o=o+Math.imul(y,he)|0)+Math.imul(w,de)|0,s=s+Math.imul(w,he)|0;var Te=(l+(n=n+Math.imul(m,me)|0)|0)+((8191&(o=(o=o+Math.imul(m,fe)|0)+Math.imul(f,me)|0))<<13)|0;l=((s=s+Math.imul(f,fe)|0)+(o>>>13)|0)+(Te>>>26)|0,Te&=67108863,n=Math.imul(U,z),o=(o=Math.imul(U,W))+Math.imul(F,z)|0,s=Math.imul(F,W),n=n+Math.imul(B,Z)|0,o=(o=o+Math.imul(B,G)|0)+Math.imul(R,Z)|0,s=s+Math.imul(R,G)|0,n=n+Math.imul(N,Y)|0,o=(o=o+Math.imul(N,ee)|0)+Math.imul(L,Y)|0,s=s+Math.imul(L,ee)|0,n=n+Math.imul(C,re)|0,o=(o=o+Math.imul(C,ne)|0)+Math.imul(_,re)|0,s=s+Math.imul(_,ne)|0,n=n+Math.imul(T,se)|0,o=(o=o+Math.imul(T,ie)|0)+Math.imul(S,se)|0,s=s+Math.imul(S,ie)|0,n=n+Math.imul(M,ue)|0,o=(o=o+Math.imul(M,le)|0)+Math.imul(A,ue)|0,s=s+Math.imul(A,le)|0,n=n+Math.imul(b,de)|0,o=(o=o+Math.imul(b,he)|0)+Math.imul(x,de)|0,s=s+Math.imul(x,he)|0;var Se=(l+(n=n+Math.imul(y,me)|0)|0)+((8191&(o=(o=o+Math.imul(y,fe)|0)+Math.imul(w,me)|0))<<13)|0;l=((s=s+Math.imul(w,fe)|0)+(o>>>13)|0)+(Se>>>26)|0,Se&=67108863,n=Math.imul(U,Z),o=(o=Math.imul(U,G))+Math.imul(F,Z)|0,s=Math.imul(F,G),n=n+Math.imul(B,Y)|0,o=(o=o+Math.imul(B,ee)|0)+Math.imul(R,Y)|0,s=s+Math.imul(R,ee)|0,n=n+Math.imul(N,re)|0,o=(o=o+Math.imul(N,ne)|0)+Math.imul(L,re)|0,s=s+Math.imul(L,ne)|0,n=n+Math.imul(C,se)|0,o=(o=o+Math.imul(C,ie)|0)+Math.imul(_,se)|0,s=s+Math.imul(_,ie)|0,n=n+Math.imul(T,ue)|0,o=(o=o+Math.imul(T,le)|0)+Math.imul(S,ue)|0,s=s+Math.imul(S,le)|0,n=n+Math.imul(M,de)|0,o=(o=o+Math.imul(M,he)|0)+Math.imul(A,de)|0,s=s+Math.imul(A,he)|0;var ke=(l+(n=n+Math.imul(b,me)|0)|0)+((8191&(o=(o=o+Math.imul(b,fe)|0)+Math.imul(x,me)|0))<<13)|0;l=((s=s+Math.imul(x,fe)|0)+(o>>>13)|0)+(ke>>>26)|0,ke&=67108863,n=Math.imul(U,Y),o=(o=Math.imul(U,ee))+Math.imul(F,Y)|0,s=Math.imul(F,ee),n=n+Math.imul(B,re)|0,o=(o=o+Math.imul(B,ne)|0)+Math.imul(R,re)|0,s=s+Math.imul(R,ne)|0,n=n+Math.imul(N,se)|0,o=(o=o+Math.imul(N,ie)|0)+Math.imul(L,se)|0,s=s+Math.imul(L,ie)|0,n=n+Math.imul(C,ue)|0,o=(o=o+Math.imul(C,le)|0)+Math.imul(_,ue)|0,s=s+Math.imul(_,le)|0,n=n+Math.imul(T,de)|0,o=(o=o+Math.imul(T,he)|0)+Math.imul(S,de)|0,s=s+Math.imul(S,he)|0;var Ce=(l+(n=n+Math.imul(M,me)|0)|0)+((8191&(o=(o=o+Math.imul(M,fe)|0)+Math.imul(A,me)|0))<<13)|0;l=((s=s+Math.imul(A,fe)|0)+(o>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,n=Math.imul(U,re),o=(o=Math.imul(U,ne))+Math.imul(F,re)|0,s=Math.imul(F,ne),n=n+Math.imul(B,se)|0,o=(o=o+Math.imul(B,ie)|0)+Math.imul(R,se)|0,s=s+Math.imul(R,ie)|0,n=n+Math.imul(N,ue)|0,o=(o=o+Math.imul(N,le)|0)+Math.imul(L,ue)|0,s=s+Math.imul(L,le)|0,n=n+Math.imul(C,de)|0,o=(o=o+Math.imul(C,he)|0)+Math.imul(_,de)|0,s=s+Math.imul(_,he)|0;var _e=(l+(n=n+Math.imul(T,me)|0)|0)+((8191&(o=(o=o+Math.imul(T,fe)|0)+Math.imul(S,me)|0))<<13)|0;l=((s=s+Math.imul(S,fe)|0)+(o>>>13)|0)+(_e>>>26)|0,_e&=67108863,n=Math.imul(U,se),o=(o=Math.imul(U,ie))+Math.imul(F,se)|0,s=Math.imul(F,ie),n=n+Math.imul(B,ue)|0,o=(o=o+Math.imul(B,le)|0)+Math.imul(R,ue)|0,s=s+Math.imul(R,le)|0,n=n+Math.imul(N,de)|0,o=(o=o+Math.imul(N,he)|0)+Math.imul(L,de)|0,s=s+Math.imul(L,he)|0;var Pe=(l+(n=n+Math.imul(C,me)|0)|0)+((8191&(o=(o=o+Math.imul(C,fe)|0)+Math.imul(_,me)|0))<<13)|0;l=((s=s+Math.imul(_,fe)|0)+(o>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,n=Math.imul(U,ue),o=(o=Math.imul(U,le))+Math.imul(F,ue)|0,s=Math.imul(F,le),n=n+Math.imul(B,de)|0,o=(o=o+Math.imul(B,he)|0)+Math.imul(R,de)|0,s=s+Math.imul(R,he)|0;var Ne=(l+(n=n+Math.imul(N,me)|0)|0)+((8191&(o=(o=o+Math.imul(N,fe)|0)+Math.imul(L,me)|0))<<13)|0;l=((s=s+Math.imul(L,fe)|0)+(o>>>13)|0)+(Ne>>>26)|0,Ne&=67108863,n=Math.imul(U,de),o=(o=Math.imul(U,he))+Math.imul(F,de)|0,s=Math.imul(F,he);var Le=(l+(n=n+Math.imul(B,me)|0)|0)+((8191&(o=(o=o+Math.imul(B,fe)|0)+Math.imul(R,me)|0))<<13)|0;l=((s=s+Math.imul(R,fe)|0)+(o>>>13)|0)+(Le>>>26)|0,Le&=67108863;var Oe=(l+(n=Math.imul(U,me))|0)+((8191&(o=(o=Math.imul(U,fe))+Math.imul(F,me)|0))<<13)|0;return l=((s=Math.imul(F,fe))+(o>>>13)|0)+(Oe>>>26)|0,Oe&=67108863,u[0]=ge,u[1]=ye,u[2]=we,u[3]=ve,u[4]=be,u[5]=xe,u[6]=Ee,u[7]=Me,u[8]=Ae,u[9]=Ie,u[10]=Te,u[11]=Se,u[12]=ke,u[13]=Ce,u[14]=_e,u[15]=Pe,u[16]=Ne,u[17]=Le,u[18]=Oe,0!==l&&(u[19]=l,r.length++),r};function y(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var n=0,o=0,s=0;s<r.length-1;s++){var i=o;o=0;for(var a=67108863&n,u=Math.min(s,t.length-1),l=Math.max(0,s-e.length+1);l<=u;l++){var c=s-l,d=(0|e.words[c])*(0|t.words[l]),h=67108863&d;a=67108863&(h=h+a|0),o+=(i=(i=i+(d/67108864|0)|0)+(h>>>26)|0)>>>26,i&=67108863}r.words[s]=a,n=i,i=o}return 0!==n?r.words[s]=n:r.length--,r._strip()}function w(e,t,r){return y(e,t,r)}Math.imul||(g=f),s.prototype.mulTo=function(e,t){var r=this.length+e.length;return 10===this.length&&10===e.length?g(this,e,t):r<63?f(this,e,t):r<1024?y(this,e,t):w(this,e,t)},s.prototype.mul=function(e){var t=new s(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},s.prototype.mulf=function(e){var t=new s(null);return t.words=new Array(this.length+e.length),w(this,e,t)},s.prototype.imul=function(e){return this.clone().mulTo(e,this)},s.prototype.imuln=function(e){var t=e<0;t&&(e=-e),r("number"==typeof e),r(e<67108864);for(var n=0,o=0;o<this.length;o++){var s=(0|this.words[o])*e,i=(67108863&s)+(67108863&n);n>>=26,n+=s/67108864|0,n+=i>>>26,this.words[o]=67108863&i}return 0!==n&&(this.words[o]=n,this.length++),t?this.ineg():this},s.prototype.muln=function(e){return this.clone().imuln(e)},s.prototype.sqr=function(){return this.mul(this)},s.prototype.isqr=function(){return this.imul(this.clone())},s.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),r=0;r<t.length;r++){var n=r/26|0,o=r%26;t[r]=e.words[n]>>>o&1}return t}(e);if(0===t.length)return new s(1);for(var r=this,n=0;n<t.length&&0===t[n];n++,r=r.sqr());if(++n<t.length)for(var o=r.sqr();n<t.length;n++,o=o.sqr())0!==t[n]&&(r=r.mul(o));return r},s.prototype.iushln=function(e){r("number"==typeof e&&e>=0);var t,n=e%26,o=(e-n)/26,s=67108863>>>26-n<<26-n;if(0!==n){var i=0;for(t=0;t<this.length;t++){var a=this.words[t]&s,u=(0|this.words[t])-a<<n;this.words[t]=u|i,i=a>>>26-n}i&&(this.words[t]=i,this.length++)}if(0!==o){for(t=this.length-1;t>=0;t--)this.words[t+o]=this.words[t];for(t=0;t<o;t++)this.words[t]=0;this.length+=o}return this._strip()},s.prototype.ishln=function(e){return r(0===this.negative),this.iushln(e)},s.prototype.iushrn=function(e,t,n){var o;r("number"==typeof e&&e>=0),o=t?(t-t%26)/26:0;var s=e%26,i=Math.min((e-s)/26,this.length),a=67108863^67108863>>>s<<s,u=n;if(o-=i,o=Math.max(0,o),u){for(var l=0;l<i;l++)u.words[l]=this.words[l];u.length=i}if(0===i);else if(this.length>i)for(this.length-=i,l=0;l<this.length;l++)this.words[l]=this.words[l+i];else this.words[0]=0,this.length=1;var c=0;for(l=this.length-1;l>=0&&(0!==c||l>=o);l--){var d=0|this.words[l];this.words[l]=c<<26-s|d>>>s,c=d&a}return u&&0!==c&&(u.words[u.length++]=c),0===this.length&&(this.words[0]=0,this.length=1),this._strip()},s.prototype.ishrn=function(e,t,n){return r(0===this.negative),this.iushrn(e,t,n)},s.prototype.shln=function(e){return this.clone().ishln(e)},s.prototype.ushln=function(e){return this.clone().iushln(e)},s.prototype.shrn=function(e){return this.clone().ishrn(e)},s.prototype.ushrn=function(e){return this.clone().iushrn(e)},s.prototype.testn=function(e){r("number"==typeof e&&e>=0);var t=e%26,n=(e-t)/26,o=1<<t;return this.length<=n?0:!!(this.words[n]&o)},s.prototype.imaskn=function(e){r("number"==typeof e&&e>=0);var t=e%26,n=(e-t)/26;if(r(0===this.negative,"imaskn works only with positive numbers"),this.length<=n)return this;if(0!==t&&n++,this.length=Math.min(n,this.length),0!==t){var o=67108863^67108863>>>t<<t;this.words[this.length-1]&=o}return this._strip()},s.prototype.maskn=function(e){return this.clone().imaskn(e)},s.prototype.iaddn=function(e){return r("number"==typeof e),r(e<67108864),e<0?this.isubn(-e):0!==this.negative?1===this.length&&(0|this.words[0])<=e?(this.words[0]=e-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(e),this.negative=1,this):this._iaddn(e)},s.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&this.words[t]>=67108864;t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},s.prototype.isubn=function(e){if(r("number"==typeof e),r(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,this.words[t+1]-=1;return this._strip()},s.prototype.addn=function(e){return this.clone().iaddn(e)},s.prototype.subn=function(e){return this.clone().isubn(e)},s.prototype.iabs=function(){return this.negative=0,this},s.prototype.abs=function(){return this.clone().iabs()},s.prototype._ishlnsubmul=function(e,t,n){var o,s,i=e.length+n;this._expand(i);var a=0;for(o=0;o<e.length;o++){s=(0|this.words[o+n])+a;var u=(0|e.words[o])*t;a=((s-=67108863&u)>>26)-(u/67108864|0),this.words[o+n]=67108863&s}for(;o<this.length-n;o++)a=(s=(0|this.words[o+n])+a)>>26,this.words[o+n]=67108863&s;if(0===a)return this._strip();for(r(-1===a),a=0,o=0;o<this.length;o++)a=(s=-(0|this.words[o])+a)>>26,this.words[o]=67108863&s;return this.negative=1,this._strip()},s.prototype._wordDiv=function(e,t){var r=(this.length,e.length),n=this.clone(),o=e,i=0|o.words[o.length-1];0!=(r=26-this._countBits(i))&&(o=o.ushln(r),n.iushln(r),i=0|o.words[o.length-1]);var a,u=n.length-o.length;if("mod"!==t){(a=new s(null)).length=u+1,a.words=new Array(a.length);for(var l=0;l<a.length;l++)a.words[l]=0}var c=n.clone()._ishlnsubmul(o,1,u);0===c.negative&&(n=c,a&&(a.words[u]=1));for(var d=u-1;d>=0;d--){var h=67108864*(0|n.words[o.length+d])+(0|n.words[o.length+d-1]);for(h=Math.min(h/i|0,67108863),n._ishlnsubmul(o,h,d);0!==n.negative;)h--,n.negative=0,n._ishlnsubmul(o,1,d),n.isZero()||(n.negative^=1);a&&(a.words[d]=h)}return a&&a._strip(),n._strip(),"div"!==t&&0!==r&&n.iushrn(r),{div:a||null,mod:n}},s.prototype.divmod=function(e,t,n){return r(!e.isZero()),this.isZero()?{div:new s(0),mod:new s(0)}:0!==this.negative&&0===e.negative?(a=this.neg().divmod(e,t),"mod"!==t&&(o=a.div.neg()),"div"!==t&&(i=a.mod.neg(),n&&0!==i.negative&&i.iadd(e)),{div:o,mod:i}):0===this.negative&&0!==e.negative?(a=this.divmod(e.neg(),t),"mod"!==t&&(o=a.div.neg()),{div:o,mod:a.mod}):0!=(this.negative&e.negative)?(a=this.neg().divmod(e.neg(),t),"div"!==t&&(i=a.mod.neg(),n&&0!==i.negative&&i.isub(e)),{div:a.div,mod:i}):e.length>this.length||this.cmp(e)<0?{div:new s(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new s(this.modrn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new s(this.modrn(e.words[0]))}:this._wordDiv(e,t);var o,i,a},s.prototype.div=function(e){return this.divmod(e,"div",0).div},s.prototype.mod=function(e){return this.divmod(e,"mod",0).mod},s.prototype.umod=function(e){return this.divmod(e,"mod",1).mod},s.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,n=e.ushrn(1),o=e.andln(1),s=r.cmp(n);return s<0||1===o&&0===s?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},s.prototype.modrn=function(e){var t=e<0;t&&(e=-e),r(e<=67108863);for(var n=(1<<26)%e,o=0,s=this.length-1;s>=0;s--)o=(n*o+(0|this.words[s]))%e;return t?-o:o},s.prototype.modn=function(e){return this.modrn(e)},s.prototype.idivn=function(e){var t=e<0;t&&(e=-e),r(e<=67108863);for(var n=0,o=this.length-1;o>=0;o--){var s=(0|this.words[o])+67108864*n;this.words[o]=s/e|0,n=s%e}return this._strip(),t?this.ineg():this},s.prototype.divn=function(e){return this.clone().idivn(e)},s.prototype.egcd=function(e){r(0===e.negative),r(!e.isZero());var t=this,n=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var o=new s(1),i=new s(0),a=new s(0),u=new s(1),l=0;t.isEven()&&n.isEven();)t.iushrn(1),n.iushrn(1),++l;for(var c=n.clone(),d=t.clone();!t.isZero();){for(var h=0,p=1;0==(t.words[0]&p)&&h<26;++h,p<<=1);if(h>0)for(t.iushrn(h);h-- >0;)(o.isOdd()||i.isOdd())&&(o.iadd(c),i.isub(d)),o.iushrn(1),i.iushrn(1);for(var m=0,f=1;0==(n.words[0]&f)&&m<26;++m,f<<=1);if(m>0)for(n.iushrn(m);m-- >0;)(a.isOdd()||u.isOdd())&&(a.iadd(c),u.isub(d)),a.iushrn(1),u.iushrn(1);t.cmp(n)>=0?(t.isub(n),o.isub(a),i.isub(u)):(n.isub(t),a.isub(o),u.isub(i))}return{a:a,b:u,gcd:n.iushln(l)}},s.prototype._invmp=function(e){r(0===e.negative),r(!e.isZero());var t=this,n=e.clone();t=0!==t.negative?t.umod(e):t.clone();for(var o,i=new s(1),a=new s(0),u=n.clone();t.cmpn(1)>0&&n.cmpn(1)>0;){for(var l=0,c=1;0==(t.words[0]&c)&&l<26;++l,c<<=1);if(l>0)for(t.iushrn(l);l-- >0;)i.isOdd()&&i.iadd(u),i.iushrn(1);for(var d=0,h=1;0==(n.words[0]&h)&&d<26;++d,h<<=1);if(d>0)for(n.iushrn(d);d-- >0;)a.isOdd()&&a.iadd(u),a.iushrn(1);t.cmp(n)>=0?(t.isub(n),i.isub(a)):(n.isub(t),a.isub(i))}return(o=0===t.cmpn(1)?i:a).cmpn(0)<0&&o.iadd(e),o},s.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0,r.negative=0;for(var n=0;t.isEven()&&r.isEven();n++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var o=t.cmp(r);if(o<0){var s=t;t=r,r=s}else if(0===o||0===r.cmpn(1))break;t.isub(r)}return r.iushln(n)},s.prototype.invm=function(e){return this.egcd(e).a.umod(e)},s.prototype.isEven=function(){return 0==(1&this.words[0])},s.prototype.isOdd=function(){return 1==(1&this.words[0])},s.prototype.andln=function(e){return this.words[0]&e},s.prototype.bincn=function(e){r("number"==typeof e);var t=e%26,n=(e-t)/26,o=1<<t;if(this.length<=n)return this._expand(n+1),this.words[n]|=o,this;for(var s=o,i=n;0!==s&&i<this.length;i++){var a=0|this.words[i];s=(a+=s)>>>26,a&=67108863,this.words[i]=a}return 0!==s&&(this.words[i]=s,this.length++),this},s.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},s.prototype.cmpn=function(e){var t,n=e<0;if(0!==this.negative&&!n)return-1;if(0===this.negative&&n)return 1;if(this._strip(),this.length>1)t=1;else{n&&(e=-e),r(e<=67108863,"Number is too big");var o=0|this.words[0];t=o===e?0:o<e?-1:1}return 0!==this.negative?0|-t:t},s.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},s.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,r=this.length-1;r>=0;r--){var n=0|this.words[r],o=0|e.words[r];if(n!==o){n<o?t=-1:n>o&&(t=1);break}}return t},s.prototype.gtn=function(e){return 1===this.cmpn(e)},s.prototype.gt=function(e){return 1===this.cmp(e)},s.prototype.gten=function(e){return this.cmpn(e)>=0},s.prototype.gte=function(e){return this.cmp(e)>=0},s.prototype.ltn=function(e){return-1===this.cmpn(e)},s.prototype.lt=function(e){return-1===this.cmp(e)},s.prototype.lten=function(e){return this.cmpn(e)<=0},s.prototype.lte=function(e){return this.cmp(e)<=0},s.prototype.eqn=function(e){return 0===this.cmpn(e)},s.prototype.eq=function(e){return 0===this.cmp(e)},s.red=function(e){return new I(e)},s.prototype.toRed=function(e){return r(!this.red,"Already a number in reduction context"),r(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},s.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},s.prototype._forceRed=function(e){return this.red=e,this},s.prototype.forceRed=function(e){return r(!this.red,"Already a number in reduction context"),this._forceRed(e)},s.prototype.redAdd=function(e){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},s.prototype.redIAdd=function(e){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},s.prototype.redSub=function(e){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},s.prototype.redISub=function(e){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},s.prototype.redShl=function(e){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},s.prototype.redMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},s.prototype.redIMul=function(e){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},s.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},s.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},s.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},s.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},s.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},s.prototype.redPow=function(e){return r(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var v={k256:null,p224:null,p192:null,p25519:null};function b(e,t){this.name=e,this.p=new s(t,16),this.n=this.p.bitLength(),this.k=new s(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function x(){b.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function E(){b.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function M(){b.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function A(){b.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function I(e){if("string"==typeof e){var t=s._prime(e);this.m=t.p,this.prime=t}else r(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null}function T(e){I.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new s(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}b.prototype._tmp=function(){var e=new s(null);return e.words=new Array(Math.ceil(this.n/13)),e},b.prototype.ireduce=function(e){var t,r=e;do{this.split(r,this.tmp),t=(r=(r=this.imulK(r)).iadd(this.tmp)).bitLength()}while(t>this.n);var n=t<this.n?-1:r.ucmp(this.p);return 0===n?(r.words[0]=0,r.length=1):n>0?r.isub(this.p):void 0!==r.strip?r.strip():r._strip(),r},b.prototype.split=function(e,t){e.iushrn(this.n,0,t)},b.prototype.imulK=function(e){return e.imul(this.k)},n(x,b),x.prototype.split=function(e,t){for(var r=4194303,n=Math.min(e.length,9),o=0;o<n;o++)t.words[o]=e.words[o];if(t.length=n,e.length<=9)return e.words[0]=0,void(e.length=1);var s=e.words[9];for(t.words[t.length++]=s&r,o=10;o<e.length;o++){var i=0|e.words[o];e.words[o-10]=(i&r)<<4|s>>>22,s=i}s>>>=22,e.words[o-10]=s,0===s&&e.length>10?e.length-=10:e.length-=9},x.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var n=0|e.words[r];t+=977*n,e.words[r]=67108863&t,t=64*n+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},n(E,b),n(M,b),n(A,b),A.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var n=19*(0|e.words[r])+t,o=67108863&n;n>>>=26,e.words[r]=o,t=n}return 0!==t&&(e.words[e.length++]=t),e},s._prime=function(e){if(v[e])return v[e];var t;if("k256"===e)t=new x;else if("p224"===e)t=new E;else if("p192"===e)t=new M;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new A}return v[e]=t,t},I.prototype._verify1=function(e){r(0===e.negative,"red works only with positives"),r(e.red,"red works only with red numbers")},I.prototype._verify2=function(e,t){r(0==(e.negative|t.negative),"red works only with positives"),r(e.red&&e.red===t.red,"red works only with red numbers")},I.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):(c(e,e.umod(this.m)._forceRed(this)),e)},I.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},I.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return r.cmp(this.m)>=0&&r.isub(this.m),r._forceRed(this)},I.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return r.cmp(this.m)>=0&&r.isub(this.m),r},I.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},I.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},I.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},I.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},I.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},I.prototype.isqr=function(e){return this.imul(e,e.clone())},I.prototype.sqr=function(e){return this.mul(e,e)},I.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(r(t%2==1),3===t){var n=this.m.add(new s(1)).iushrn(2);return this.pow(e,n)}for(var o=this.m.subn(1),i=0;!o.isZero()&&0===o.andln(1);)i++,o.iushrn(1);r(!o.isZero());var a=new s(1).toRed(this),u=a.redNeg(),l=this.m.subn(1).iushrn(1),c=this.m.bitLength();for(c=new s(2*c*c).toRed(this);0!==this.pow(c,l).cmp(u);)c.redIAdd(u);for(var d=this.pow(c,o),h=this.pow(e,o.addn(1).iushrn(1)),p=this.pow(e,o),m=i;0!==p.cmp(a);){for(var f=p,g=0;0!==f.cmp(a);g++)f=f.redSqr();r(g<m);var y=this.pow(d,new s(1).iushln(m-g-1));h=h.redMul(y),d=y.redSqr(),p=p.redMul(d),m=g}return h},I.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},I.prototype.pow=function(e,t){if(t.isZero())return new s(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=new Array(16);r[0]=new s(1).toRed(this),r[1]=e;for(var n=2;n<r.length;n++)r[n]=this.mul(r[n-1],e);var o=r[0],i=0,a=0,u=t.bitLength()%26;for(0===u&&(u=26),n=t.length-1;n>=0;n--){for(var l=t.words[n],c=u-1;c>=0;c--){var d=l>>c&1;o!==r[0]&&(o=this.sqr(o)),0!==d||0!==i?(i<<=1,i|=d,(4==++a||0===n&&0===c)&&(o=this.mul(o,r[i]),a=0,i=0)):a=0}u=26}return o},I.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},I.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},s.mont=function(e){return new T(e)},n(T,I),T.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},T.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},T.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),o=r.isub(n).iushrn(this.shift),s=o;return o.cmp(this.m)>=0?s=o.isub(this.m):o.cmpn(0)<0&&(s=o.iadd(this.m)),s._forceRed(this)},T.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new s(0)._forceRed(this);var r=e.mul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),o=r.isub(n).iushrn(this.shift),i=o;return o.cmp(this.m)>=0?i=o.isub(this.m):o.cmpn(0)<0&&(i=o.iadd(this.m)),i._forceRed(this)},T.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(0,r);var s,i=o.exports,a=n(i);exports.TreeType=void 0,(s=exports.TreeType||(exports.TreeType={}))[s.State=0]="State",s[s.Address=1]="Address",s[s.BatchedState=2]="BatchedState",s[s.BatchedAddress=3]="BatchedAddress";const u=new a("21888242871839275222246405745257275088548364400416034343698204186575808495617"),l=new a("452312848583266388373324160190187140051835877600158453279131187530910662655"),c=[2,64,66,15,0],d=t.Buffer.from([26,16,169,7,21,202,242,25]),h=t.Buffer.from([49,212,191,129,39,194,43,196]),p=t.Buffer.from([180,143,159,153,35,46,248,163]),m="noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV",f="SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7",g="compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq",y=()=>new e.PublicKey("35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh"),w=()=>e.PublicKey.findProgramAddressSync([t.Buffer.from("cpi_authority")],new e.PublicKey(f))[0],v=()=>({registeredProgramPda:new e.PublicKey(y()),noopProgram:new e.PublicKey(m),accountCompressionProgram:new e.PublicKey(g),accountCompressionAuthority:new e.PublicKey(w()),cpiSignatureAccount:null}),b=()=>({mainnet:[{stateTreeLookupTable:new e.PublicKey(A),nullifyTable:new e.PublicKey(I)}],devnet:[{stateTreeLookupTable:new e.PublicKey(T),nullifyTable:new e.PublicKey(S)}]}),x=e=>e.includes("localhost")||e.includes("127.0.0.1"),E=()=>[{tree:new e.PublicKey(_),queue:new e.PublicKey(k),cpiContext:new e.PublicKey(C),treeType:exports.TreeType.State},{tree:new e.PublicKey(L),queue:new e.PublicKey(O),cpiContext:new e.PublicKey(B),treeType:exports.TreeType.State}],M=()=>({nullifierQueue:new e.PublicKey(k),merkleTree:new e.PublicKey(_),merkleTreeHeight:R,addressTree:new e.PublicKey(P),addressQueue:new e.PublicKey(N)}),A="7i86eQs3GSqHjN47WdWLTCGMW6gde1q96G2EVnUyK2st",I="H9QD4u1fG7KmkAzn2tDXhheushxFe1EcrjGGyEFXeMqT",T="8n8rH2bFRVA6cSGNDpgqcKHCndbFCT1bXxAQG89ejVsh",S="5dhaJLBjnVBQFErr8oiCJmcVsx3Zj6xDekGB2zULPsnP",k="nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148",C="cpi1uHzrEhBG733DoEJNgHCyRS3XmmyVNZx5fonubE4",_="smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT",P="amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2",N="aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F",L="smt2rJAFdyJJupwMKAqTNAJwvjhmiZ4JYGZmbVRw1Ho",O="nfq2hgS7NYemXsFaFUCe3EMXSDSfnZnAe27jC6aPP1X",B="cpi2cdhkH5roePvcudTgUL8ppEBfTay1desGh8G8QxK",R=26,D=new a(Math.floor(2**R*.95)),U=new a(300),F=new a(392),q=new a(5e3),K=new a(5e3);var V=function(e){const t=new Uint8Array(256);for(let e=0;e<t.length;e++)t[e]=255;for(let r=0;r<58;r++){const n=e.charAt(r),o=n.charCodeAt(0);if(255!==t[o])throw new TypeError(n+" is ambiguous");t[o]=r}const r=e.charAt(0),n=Math.log(58)/Math.log(256),o=Math.log(256)/Math.log(58);function s(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;let o=0,s=0,i=0;for(;e[o]===r;)s++,o++;const a=(e.length-o)*n+1>>>0,u=new Uint8Array(a);for(;e[o];){let r=t[e.charCodeAt(o)];if(255===r)return;let n=0;for(let e=a-1;(0!==r||n<i)&&-1!==e;e--,n++)r+=58*u[e]>>>0,u[e]=r%256>>>0,r=r/256>>>0;if(0!==r)throw new Error("Non-zero carry");i=n,o++}let l=a-i;for(;l!==a&&0===u[l];)l++;const c=new Uint8Array(s+(a-l));let d=s;for(;l!==a;)c[d++]=u[l++];return c}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";let n=0,s=0,i=0;const a=t.length;for(;i!==a&&0===t[i];)i++,n++;const u=(a-i)*o+1>>>0,l=new Uint8Array(u);for(;i!==a;){let e=t[i],r=0;for(let t=u-1;(0!==e||r<s)&&-1!==t;t--,r++)e+=256*l[t]>>>0,l[t]=e%58>>>0,e=e/58>>>0;if(0!==e)throw new Error("Non-zero carry");s=r,i++}let c=u-s;for(;c!==u&&0===l[c];)c++;let d=r.repeat(n);for(;c<u;++c)d+=e.charAt(l[c]);return d},decodeUnsafe:s,decode:function(e){const t=s(e);if(t)return t;throw new Error("Non-base58 character")}}}("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const H=(e,t,r)=>new a(e,t,r),$=(e,t)=>{if("base58"===t){if("string"!=typeof e)throw new Error("Must be a base58 string");return $(V.decode(e))}return function(e){if(e.gte(u))throw new Error("Value is too large. Max <254 bits");return e}(new a(e,t))};function j(e){const r=$(e).toArrayLike(t.Buffer,void 0,32);return V.encode(r)}const Q=(e,t,r,n)=>({owner:e,lamports:null!=t?t:H(0),address:null!=n?n:null,data:null!=r?r:null}),z=(e,t,r,n,o)=>Object.assign(Object.assign(Object.assign({},Q(t,r,n,o)),e),{readOnly:0}),W=(e,t,r,n)=>({merkleTree:e,nullifierQueue:t,hash:r,leafIndex:n});function J(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Z(e,...t){if(!((r=e)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function G(e,t=1){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}const X=BigInt(2**32-1),Y=BigInt(32);function ee(e,t=0){return t?{h:Number(e&X),l:Number(e>>Y&X)}:{h:0|Number(e>>Y&X),l:0|Number(e&X)}}function te(e,t=0){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:s,l:i}=ee(e[o],t);[r[o],n[o]]=[s,i]}return[r,n]}const re=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];function ne(e){for(let r=0;r<e.length;r++)e[r]=(t=e[r])<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;var t}function oe(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Z(e),e}class se{clone(){return this._cloneInto()}}const ie=[],ae=[],ue=[],le=BigInt(0),ce=BigInt(1),de=BigInt(2),he=BigInt(7),pe=BigInt(256),me=BigInt(113);for(let e=0,t=ce,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],ie.push(2*(5*n+r)),ae.push((e+1)*(e+2)/2%64);let o=le;for(let e=0;e<7;e++)t=(t<<ce^(t>>he)*me)%pe,t&de&&(o^=ce<<(ce<<BigInt(e))-ce);ue.push(o)}const[fe,ge]=te(ue,1),ye=(e,t,r)=>r>32?((e,t,r)=>t<<r-32|e>>>64-r)(e,t,r):((e,t,r)=>e<<r|t>>>32-r)(e,t,r),we=(e,t,r)=>r>32?((e,t,r)=>e<<r-32|t>>>64-r)(e,t,r):((e,t,r)=>t<<r|e>>>32-r)(e,t,r);class ve extends se{constructor(e,t,r,n=0,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=o,this.pos=0,this.posOut=0,this.finished=0,this.destroyed=0,J(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){re||ne(this.state32),function(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const n=(t+8)%10,o=(t+2)%10,s=r[o],i=r[o+1],a=ye(s,i,1)^r[n],u=we(s,i,1)^r[n+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=u}let t=e[2],o=e[3];for(let r=0;r<24;r++){const n=ae[r],s=ye(t,o,n),i=we(t,o,n),a=ie[r];t=e[a],o=e[a+1],e[a]=s,e[a+1]=i}for(let t=0;t<50;t+=10){for(let n=0;n<10;n++)r[n]=e[t+n];for(let n=0;n<10;n++)e[t+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=fe[n],e[1]^=ge[n]}r.fill(0)}(this.state32,this.rounds),re||ne(this.state32),this.posOut=0,this.pos=0}update(e){G(this);const{blockLen:t,state:r}=this,n=(e=oe(e)).length;for(let o=0;o<n;){const s=Math.min(t-this.pos,n-o);for(let t=0;t<s;t++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=1;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,0!=(128&t)&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){G(this,0),Z(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,o=e.length;n<o;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,o-n);e.set(t.subarray(this.posOut,this.posOut+s),n),this.posOut+=s,n+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return J(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(function(e,t){Z(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=1,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:o,enableXOF:s}=this;return e||(e=new ve(t,r,n,s,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=n,e.enableXOF=s,e.destroyed=this.destroyed,e}}const be=(()=>function(e){const t=t=>e().update(oe(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}((()=>new ve(136,1,32))))(),xe=e=>"object"==typeof e&&null!==e,Ee=e=>xe(e)&&!(e instanceof RegExp)&&!(e instanceof Error)&&!(e instanceof Date),Me=Symbol("mapObjectSkip"),Ae=(e,t,r,n=new WeakMap)=>{if(r={deep:0,target:{},...r},n.has(e))return n.get(e);n.set(e,r.target);const{target:o}=r;delete r.target;const s=e=>e.map((e=>Ee(e)?Ae(e,t,r,n):e));if(Array.isArray(e))return s(e);for(const[i,a]of Object.entries(e)){const u=t(i,a,e);if(u===Me)continue;let[l,c,{shouldRecurse:d=1}={}]=u;"__proto__"!==l&&(r.deep&&d&&Ee(c)&&(c=Array.isArray(c)?s(c):Ae(c,t,r,n)),o[l]=c)}return o};function Ie(e,t,r){if(!xe(e))throw new TypeError(`Expected an object, got \`${e}\` (${typeof e})`);return Ae(e,t,r)}const Te=/[\p{Lu}]/u,Se=/[\p{Ll}]/u,ke=/^[\p{Lu}](?![\p{Lu}])/gu,Ce=/([\p{Alpha}\p{N}_]|$)/u,_e=/[_.\- ]+/,Pe=new RegExp("^"+_e.source),Ne=new RegExp(_e.source+Ce.source,"gu"),Le=new RegExp("\\d+"+Ce.source,"gu");class Oe extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if("function"==typeof this.onEviction)for(const[t,r]of e)this.onEviction(t,r.value)}_deleteIfExpired(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()?("function"==typeof this.onEviction&&this.onEviction(e,t.value),this.delete(e)):0}_getOrDeleteIfExpired(e,t){if(0==this._deleteIfExpired(e,t))return t.value}_getItemValue(e,t){return t.expiry?this._getOrDeleteIfExpired(e,t):t.value}_peek(e,t){const r=t.get(e);return this._getItemValue(e,r)}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,t){this.oldCache.delete(e),this._set(e,t)}*_entriesAscending(){for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||0==this._deleteIfExpired(t,r)&&(yield e)}for(const e of this.cache){const[t,r]=e;0==this._deleteIfExpired(t,r)&&(yield e)}}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this._getItemValue(e,t)}if(this.oldCache.has(e)){const t=this.oldCache.get(e);if(0==this._deleteIfExpired(e,t))return this._moveToRecent(e,t),t.value}}set(e,t,{maxAge:r=this.maxAge}={}){const n="number"==typeof r&&r!==Number.POSITIVE_INFINITY?Date.now()+r:void 0;return this.cache.has(e)?this.cache.set(e,{value:t,expiry:n}):this._set(e,{value:t,expiry:n}),this}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):this.oldCache.has(e)?!this._deleteIfExpired(e,this.oldCache.get(e)):0}peek(e){return this.cache.has(e)?this._peek(e,this.cache):this.oldCache.has(e)?this._peek(e,this.oldCache):void 0}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this._entriesAscending()],r=t.length-e;r<0?(this.cache=new Map(t),this.oldCache=new Map,this._size=t.length):(r>0&&this._emitEvictions(t.slice(0,r)),this.oldCache=new Map(t.slice(r)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[t,r]=e;0==this._deleteIfExpired(t,r)&&(yield[t,r.value])}for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||0==this._deleteIfExpired(t,r)&&(yield[t,r.value])}}*entriesDescending(){let e=[...this.cache];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,o]=r;0==this._deleteIfExpired(n,o)&&(yield[n,o.value])}e=[...this.oldCache];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,o]=r;this.cache.has(n)||0==this._deleteIfExpired(n,o)&&(yield[n,o.value])}}*entriesAscending(){for(const[e,t]of this._entriesAscending())yield[e,t.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,n]of this.entriesAscending())e.call(t,n,r,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}const Be=new Oe({maxSize:1e5}),Re=e=>!("object"!=typeof e||null===e||e instanceof RegExp||e instanceof Error||e instanceof Date),De=(e,t={})=>{if(!Re(e))return e;const{exclude:r,pascalCase:n=0,stopPaths:o,deep:s=0,preserveConsecutiveUppercase:i=0}=t,a=new Set(o),u=e=>(t,o)=>{if(s&&Re(o)){const r=void 0===e?t:`${e}.${t}`;a.has(r)||(o=Ie(o,u(r)))}if(!r||!((e,t)=>e.some((e=>"string"==typeof e?e===t:(e.lastIndex=0,e.test(t)))))(r,t)){const e=n?`${t}_`:t;if(Be.has(e))t=Be.get(e);else{const r=function(e,t){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("Expected the input to be `string | string[]`");if(t={pascalCase:0,preserveConsecutiveUppercase:0,...t},0===(e=Array.isArray(e)?e.map((e=>e.trim())).filter((e=>e.length)).join("-"):e.trim()).length)return"";const r=0==t.locale?e=>e.toLowerCase():e=>e.toLocaleLowerCase(t.locale),n=0==t.locale?e=>e.toUpperCase():e=>e.toLocaleUpperCase(t.locale);return 1===e.length?_e.test(e)?"":t.pascalCase?n(e):r(e):(e!==r(e)&&(e=((e,t,r,n)=>{let o=0,s=0,i=0,a=0;for(let u=0;u<e.length;u++){const l=e[u];a=u>2?"-"===e[u-3]:1,o&&Te.test(l)?(e=e.slice(0,u)+"-"+e.slice(u),o=0,i=s,s=1,u++):s&&i&&Se.test(l)&&(!a||n)?(e=e.slice(0,u-1)+"-"+e.slice(u-1),i=s,s=0,o=1):(o=t(l)===l&&r(l)!==l,i=s,s=r(l)===l&&t(l)!==l)}return e})(e,r,n,t.preserveConsecutiveUppercase)),e=e.replace(Pe,""),e=t.preserveConsecutiveUppercase?((e,t)=>(ke.lastIndex=0,e.replaceAll(ke,(e=>t(e)))))(e,r):r(e),t.pascalCase&&(e=n(e.charAt(0))+e.slice(1)),((e,t)=>(Ne.lastIndex=0,Le.lastIndex=0,e.replaceAll(Le,((r,n,o)=>["_","-"].includes(e.charAt(o+r.length))?r:t(r))).replaceAll(Ne,((e,r)=>t(r)))))(e,n))}(t,{pascalCase:n,locale:0,preserveConsecutiveUppercase:i});t.length<100&&Be.set(e,r),t=r}}return[t,o]};return Ie(e,u(void 0))};function Ue(e){return"0x"+e.toString("hex")}const Fe=e=>Array.isArray(e)?e:[e];function qe(e){return H(e,void 0,"be").lt(u)}const Ke=e=>{return t=e,r={deep:1},Array.isArray(t)?Object.keys(t).map((e=>De(t[e],r))):De(t,r);var t,r};function Ve(e){let r=255;for(;r>=0;){const n=t.Buffer.concat([e,t.Buffer.from([r])]),o=be(n);if(32!==o.length)throw new Error("Invalid hash length");if(o[0]=0,qe(t.Buffer.from(o)))return[t.Buffer.from(o),r];r-=1}return null}function He(e){const t=be.create();for(const r of e)t.update(r);const r=t.digest();return r[0]=0,r}function $e(e,t){const r=e.findIndex((e=>e.equals(t)));return-1===r?(e.push(t),e.length-1):r}function je(e,t,r){if(t<=0)return[];if(void 0===e){if(0===r.length)throw new Error("No input compressed accounts nor output state trees provided. Please pass in at least one of the following: outputStateMerkleTree or inputCompressedAccount");return new Array(t).fill(r[0].merkleTree)}{const r=Fe(e);return r.length>=t?r.slice(0,t):r.concat(new Array(t-r.length).fill(r[0]))}}function Qe(e){return e.map((e=>({pubkey:e,isWritable:1,isSigner:0})))}function ze(e,t,r,n,o=[]){const s=o.slice(),i=[],a=[];if(e.forEach(((e,r)=>{const n=$e(s,e.merkleTree),o=$e(s,e.nullifierQueue);i.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleContext:{merkleTreePubkeyIndex:n,nullifierQueuePubkeyIndex:o,leafIndex:e.leafIndex,queueIndex:null},rootIndex:t[r],readOnly:0})})),void 0===n&&0===e.length)throw new Error("No input compressed accounts nor output state trees provided. Please pass in at least one of the following: outputStateMerkleTree or inputCompressedAccount");const u=je(n,r.length,e);return r.forEach(((e,t)=>{const r=$e(s,u[t]);a.push({compressedAccount:{owner:e.owner,lamports:e.lamports,address:e.address,data:e.data},merkleTreeIndex:r})})),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:s}}const We=e=>{if(e.lt(H(0)))throw new Error("Insufficient balance for transfer")},Je=e=>{if(0===e.length)throw new Error("No accounts provided for validation");const t=e[0].owner;if(!e.every((e=>e.owner.equals(t))))throw new Error("All input accounts must have the same owner")},Ze=(e,t)=>{if(e>0&&t>0){if(8===e)throw new Error(`Invalid number of compressed accounts for proof: ${e}. Allowed numbers: ${[1,2,3,4].join(", ")}`);Ye(e,[1,2,3,4],"compressed accounts"),Xe(t)}else e>0?Ge(e):Xe(t)},Ge=e=>{Ye(e,[1,2,3,4,8],"compressed accounts")},Xe=e=>{Ye(e,[1,2],"new addresses")},Ye=(e,t,r)=>{if(!t.includes(e))throw new Error(`Invalid number of ${r}: ${e}. Allowed numbers: ${t.join(", ")}`)};function et(e,t){return He([t.toBytes(),...e])}function tt(t,r=M().addressTree){if(32!=t.length)throw new Error("Seed length is not 32 bytes.");const n=r.toBytes(),o=Ve(Buffer.from([...n,...t]));if(null===o)throw new Error("DeriveAddressError");const s=o[0];return new e.PublicKey(s)}function rt(e,t){const r=t.slice(),n=e.map((e=>({seed:Array.from(e.seed),addressMerkleTreeRootIndex:e.addressMerkleTreeRootIndex,addressMerkleTreeAccountIndex:0,addressQueueAccountIndex:0})));return e.forEach(((e,t)=>{n[t].addressMerkleTreeAccountIndex=$e(r,e.addressMerkleTreePubkey)})),e.forEach(((e,t)=>{n[t].addressQueueAccountIndex=$e(r,e.addressQueuePubkey)})),{newAddressParamsPacked:n,remainingAccounts:r}}async function nt(e,t,r="confirmed"){const n=await e.getLatestBlockhash(r),o={signature:t.toString(),lastValidBlockHeight:n.lastValidBlockHeight,blockhash:n.blockhash};return await e.confirmTransaction(o,r)}function ot(e){const t=it(e.ar[0]),r=it(e.ar[1]),n=new Uint8Array([...t,...r]),o=it(e.bs[0][0]),s=it(e.bs[0][1]),i=it(e.bs[1][0]),a=it(e.bs[1][1]),u=new Uint8Array([...o,...s,...i,...a]),l=it(e.krs[0]),c=it(e.krs[1]);return{a:n,b:u,c:new Uint8Array([...l,...c])}}function st(e){const t=e.a,r=e.b,n=e.c,o=t.slice(0,32),s=at(new a(t.slice(32,64),32,"be"))?0:1;o[0]=ut(o[0],s);const i=r.slice(0,64),l=r.slice(64,128),c=function(e,t){const r=u.div(new a(2));return e.lt(r)?1:e.gt(r)?0:t.lt(r)}(new a(l.slice(0,32),32,"be"),new a(l.slice(32,64),32,"be"));i[0]=ut(i[0],c);const d=n.slice(0,32),h=n.slice(32,64),p=at(new a(h,32,"be"));return d[0]=ut(d[0],p),{a:Array.from(o),b:Array.from(i),c:Array.from(d)}}function it(e){const t=new a(e.startsWith("0x")?e.substring(2):e,"hex");return new Uint8Array(t.toArray("be",32))}function at(e){return e.lte(u.sub(e))}function ut(e,t){return t?e:128|e}function lt(t,r,n,o){const s=new e.TransactionMessage({payerKey:r,recentBlockhash:n,instructions:t}).compileToV0Message(o);return new e.VersionedTransaction(s)}async function ct(e,t,r,n){const o=await e.sendTransaction(t,r);n||(n=await e.getLatestBlockhash());const s={signature:o,blockhash:n.blockhash,lastValidBlockHeight:n.lastValidBlockHeight},i=(await e.confirmTransaction(s,(null==r?void 0:r.commitment)||e.commitment||"confirmed")).context.slot;return await e.confirmTransactionIndexed(i),o}async function dt(e,t,r,n){n||(n=await e.getLatestBlockhash());const o={signature:t,blockhash:n.blockhash,lastValidBlockHeight:n.lastValidBlockHeight},s=await e.confirmTransaction(o,(null==r?void 0:r.commitment)||e.commitment||"confirmed"),i=s.context.slot;return await e.confirmTransactionIndexed(i),s}function ht(e,t,r,n=[],o){if(n.includes(t))throw new Error("payer must not be in additionalSigners");const s=[t,...n],i=lt(e,t.publicKey,r,o);return i.sign(s),i}async function pt({connection:e,stateTreeLookupTableAddress:t,nullifyTableAddress:r}){const n=await e.getAddressLookupTable(t);if(!n.value)throw new Error("State tree lookup table not found");if(n.value.state.addresses.length%3!=0)throw new Error("State tree lookup table must have a multiple of 3 addresses");const o=await e.getAddressLookupTable(r);if(!o.value)throw new Error("Nullify table not found");const s=n.value.state.addresses,i=o.value.state.addresses,a=[];for(let e=0;e<s.length;e+=3){const t=s[e];i.includes(t)||a.push({tree:t,queue:s[e+1],cpiContext:s[e+2],treeType:exports.TreeType.State})}return a}var mt={},ft={};class gt{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}decode(e,t){throw new Error("Layout is abstract")}encode(e,t,r){throw new Error("Layout is abstract")}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function yt(e,t){return t.property?e+"["+t.property+"]":e}ft.Layout=gt,ft.nameWithProperty=yt,ft.bindConstructorLayout=function(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(e.hasOwnProperty("layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof gt))throw new TypeError("layout must be a Layout");if(t.hasOwnProperty("boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value:function(e,r){return t.encode(this,e,r)},writable:1}),Object.defineProperty(e,"decode",{value:function(e,r){return t.decode(e,r)},writable:1})};class wt extends gt{isCount(){throw new Error("ExternalLayout is abstract")}}class vt extends wt{constructor(e,t){if(void 0===e&&(e=1),!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return 1}decode(e,t){void 0===t&&(t=0);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}class bt extends wt{constructor(e,t,r){if(!(e instanceof gt))throw new TypeError("layout must be a Layout");if(void 0===t)t=0;else if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof xt||this.layout instanceof Et}decode(e,t){return void 0===t&&(t=0),this.layout.decode(e,t+this.offset)}encode(e,t,r){return void 0===r&&(r=0),this.layout.encode(e,t,r+this.offset)}}class xt extends gt{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntLE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeUIntLE(e,r,this.span),this.span}}class Et extends gt{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntBE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeUIntBE(e,r,this.span),this.span}}class Mt extends gt{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntLE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeIntLE(e,r,this.span),this.span}}class At extends gt{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntBE(t,this.span)}encode(e,t,r){return void 0===r&&(r=0),t.writeIntBE(e,r,this.span),this.span}}const It=Math.pow(2,32);function Tt(e){const t=Math.floor(e/It);return{hi32:t,lo32:e-t*It}}function St(e,t){return e*It+t}class kt extends gt{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);const r=e.readUInt32LE(t);return St(e.readUInt32LE(t+4),r)}encode(e,t,r){void 0===r&&(r=0);const n=Tt(e);return t.writeUInt32LE(n.lo32,r),t.writeUInt32LE(n.hi32,r+4),8}}class Ct extends gt{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),St(e.readUInt32BE(t),e.readUInt32BE(t+4))}encode(e,t,r){void 0===r&&(r=0);const n=Tt(e);return t.writeUInt32BE(n.hi32,r),t.writeUInt32BE(n.lo32,r+4),8}}class _t extends gt{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);const r=e.readUInt32LE(t);return St(e.readInt32LE(t+4),r)}encode(e,t,r){void 0===r&&(r=0);const n=Tt(e);return t.writeUInt32LE(n.lo32,r),t.writeInt32LE(n.hi32,r+4),8}}class Pt extends gt{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),St(e.readInt32BE(t),e.readUInt32BE(t+4))}encode(e,t,r){void 0===r&&(r=0);const n=Tt(e);return t.writeInt32BE(n.hi32,r),t.writeUInt32BE(n.lo32,r+4),8}}class Nt extends gt{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatLE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeFloatLE(e,r),4}}class Lt extends gt{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatBE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeFloatBE(e,r),4}}class Ot extends gt{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleLE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeDoubleLE(e,r),8}}class Bt extends gt{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleBE(t)}encode(e,t,r){return void 0===r&&(r=0),t.writeDoubleBE(e,r),8}}class Rt extends gt{constructor(e,t,r){if(!(e instanceof gt))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof wt&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof wt)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0,n=this.count;if(n instanceof wt&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let o=0;for(;o<n;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t){void 0===t&&(t=0);const r=[];let n=0,o=this.count;for(o instanceof wt&&(o=o.decode(e,t));n<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r){void 0===r&&(r=0);const n=this.elementLayout,o=e.reduce(((e,o)=>e+n.encode(o,t,r+e)),0);return this.count instanceof wt&&this.count.encode(e.length,t,r),o}}class Dt extends gt{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof gt),1))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===r&&(r=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0;try{r=this.fields.reduce(((r,n)=>{const o=n.getSpan(e,t);return t+=o,r+o}),0)}catch(e){throw new RangeError("indeterminate span")}return r}decode(e,t){void 0===t&&(t=0);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r){void 0===r&&(r=0);const n=r;let o=0,s=0;for(const n of this.fields){let i=n.span;if(s=0<i?i:0,void 0!==n.property){const o=e[n.property];void 0!==o&&(s=n.encode(o,t,r),0>i&&(i=n.getSpan(t,r)))}o=r,r+=i}return o+s-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}class Ut{constructor(e){this.property=e}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class Ft extends Ut{constructor(e,t){if(!(e instanceof wt&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}class qt extends gt{constructor(e,t,r){const n=e instanceof xt||e instanceof Et;if(n)e=new Ft(new bt(e));else if(e instanceof wt&&e.isCount())e=new Ft(e);else if(!(e instanceof Ut))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(void 0===t&&(t=null),!(null===t||t instanceof gt))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&n&&(o+=e.layout.span)),super(o,r),this.discriminator=e,this.usesPrefixDiscriminator=n,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(e.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&e.hasOwnProperty(this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||e.hasOwnProperty(t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(e.hasOwnProperty(r.property))return r}throw new Error("unable to infer src variant")}decode(e,t){let r;void 0===t&&(t=0);const n=this.discriminator,o=n.decode(e,t);let s=this.registry[o];if(void 0===s){let i=0;s=this.defaultLayout,this.usesPrefixDiscriminator&&(i=n.layout.span),r=this.makeDestinationObject(),r[n.property]=o,r[s.property]=this.defaultLayout.decode(e,t+i)}else r=s.decode(e,t);return r}encode(e,t,r){void 0===r&&(r=0);const n=this.getSourceVariant(e);if(void 0===n){const n=this.discriminator,o=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=n.layout.span),n.encode(e[n.property],t,r),s+o.encode(e[o.property],t,r+s)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new Kt(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t){let r=e;return Buffer.isBuffer(e)&&(void 0===t&&(t=0),r=this.discriminator.decode(e,t)),this.registry[r]}}class Kt extends gt{constructor(e,t,r,n){if(!(e instanceof qt))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof gt))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof n)throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),r+this.layout.getSpan(e,t+r)}decode(e,t){const r=this.makeDestinationObject();if(void 0===t&&(t=0),this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=1:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r){void 0===r&&(r=0);let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!e.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),o+=this.layout.getSpan(t,r+n),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function Vt(e){return 0>e&&(e+=4294967296),e}class Ht extends gt{constructor(e,t,r){if(!(e instanceof xt||e instanceof Et))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===r&&(r=t,t=void 0),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(e){return n=Vt(e),this},this._packedGetValue=function(){return n}}decode(e,t){const r=this.makeDestinationObject();void 0===t&&(t=0);const n=this.word.decode(e,t);this._packedSetValue(n);for(const e of this.fields)void 0!==e.property&&(r[e.property]=e.decode(n));return r}encode(e,t,r){void 0===r&&(r=0);const n=this.word.decode(t,r);this._packedSetValue(n);for(const t of this.fields)if(void 0!==t.property){const r=e[t.property];void 0!==r&&t.encode(r)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new $t(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new jt(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}class $t{constructor(e,t,r){if(!(e instanceof Ht))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,o=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+o>n)throw new Error("bits too long for span remainder ("+(n-o)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=n-o-t),this.wordMask=Vt(this.valueMask<<this.start),this.property=r}decode(){return Vt(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if(!Number.isInteger(e)||e!==Vt(e&this.valueMask))throw new TypeError(yt("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=Vt(e<<this.start);this.container._packedSetValue(Vt(t&~this.wordMask)|r)}}class jt extends $t{constructor(e,t){super(e,1,t)}decode(e,t){return!!$t.prototype.decode.call(this,e,t)}encode(e){return"boolean"==typeof e&&(e=+e),$t.prototype.encode.call(this,e)}}class Qt extends gt{constructor(e,t){if(!(e instanceof wt&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof wt||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t){void 0===t&&(t=0);let r=this.span;return 0>r&&(r=this.length.decode(e,t)),e.slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof wt&&(n=e.length),!Buffer.isBuffer(e)||n!==e.length)throw new TypeError(yt("Blob.encode",this)+" requires (length "+n+") Buffer as src");if(r+n>t.length)throw new RangeError("encoding overruns Buffer");return t.write(e.toString("hex"),r,n,"hex"),this.length instanceof wt&&this.length.encode(n,t,r),n}}class zt extends gt{constructor(e){super(-1,e)}getSpan(e,t){if(!Buffer.isBuffer(e))throw new TypeError("b must be a Buffer");void 0===t&&(t=0);let r=t;for(;r<e.length&&0!==e[r];)r+=1;return 1+r-t}decode(e,t,r){void 0===t&&(t=0);let n=this.getSpan(e,t);return e.slice(t,t+n-1).toString("utf-8")}encode(e,t,r){void 0===r&&(r=0),"string"!=typeof e&&(e=e.toString());const n=new Buffer(e,"utf8"),o=n.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return n.copy(t,r),t[r+o]=0,o+1}}class Wt extends gt{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t){if(!Buffer.isBuffer(e))throw new TypeError("b must be a Buffer");return void 0===t&&(t=0),e.length-t}decode(e,t,r){void 0===t&&(t=0);let n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return e.slice(t,t+n).toString("utf-8")}encode(e,t,r){void 0===r&&(r=0),"string"!=typeof e&&(e=e.toString());const n=new Buffer(e,"utf8"),o=n.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return n.copy(t,r),o}}class Jt extends gt{constructor(e,t){super(0,t),this.value=e}decode(e,t,r){return this.value}encode(e,t,r){return 0}}ft.ExternalLayout=wt,ft.GreedyCount=vt,ft.OffsetLayout=bt,ft.UInt=xt,ft.UIntBE=Et,ft.Int=Mt,ft.IntBE=At,ft.Float=Nt,ft.FloatBE=Lt,ft.Double=Ot,ft.DoubleBE=Bt,ft.Sequence=Rt,ft.Structure=Dt,ft.UnionDiscriminator=Ut,ft.UnionLayoutDiscriminator=Ft,ft.Union=qt,ft.VariantLayout=Kt,ft.BitStructure=Ht,ft.BitField=$t,ft.Boolean=jt,ft.Blob=Qt,ft.CString=zt,ft.UTF8=Wt,ft.Constant=Jt,ft.greedy=(e,t)=>new vt(e,t),ft.offset=(e,t,r)=>new bt(e,t,r),ft.u8=e=>new xt(1,e),ft.u16=e=>new xt(2,e),ft.u24=e=>new xt(3,e),ft.u32=e=>new xt(4,e),ft.u40=e=>new xt(5,e),ft.u48=e=>new xt(6,e),ft.nu64=e=>new kt(e),ft.u16be=e=>new Et(2,e),ft.u24be=e=>new Et(3,e),ft.u32be=e=>new Et(4,e),ft.u40be=e=>new Et(5,e),ft.u48be=e=>new Et(6,e),ft.nu64be=e=>new Ct(e),ft.s8=e=>new Mt(1,e),ft.s16=e=>new Mt(2,e),ft.s24=e=>new Mt(3,e),ft.s32=e=>new Mt(4,e),ft.s40=e=>new Mt(5,e),ft.s48=e=>new Mt(6,e),ft.ns64=e=>new _t(e),ft.s16be=e=>new At(2,e),ft.s24be=e=>new At(3,e),ft.s32be=e=>new At(4,e),ft.s40be=e=>new At(5,e),ft.s48be=e=>new At(6,e),ft.ns64be=e=>new Pt(e),ft.f32=e=>new Nt(e),ft.f32be=e=>new Lt(e),ft.f64=e=>new Ot(e),ft.f64be=e=>new Bt(e),ft.struct=(e,t,r)=>new Dt(e,t,r),ft.bits=(e,t,r)=>new Ht(e,t,r),ft.seq=(e,t,r)=>new Rt(e,t,r),ft.union=(e,t,r)=>new qt(e,t,r),ft.unionLayoutDiscriminator=(e,t)=>new Ft(e,t),ft.blob=(e,t)=>new Qt(e,t),ft.cstr=e=>new zt(e),ft.utf8=(e,t)=>new Wt(e,t),ft.const=(e,t)=>new Jt(e,t),function(t){var n=r&&r.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:1}),t.map=t.array=t.rustEnum=t.str=t.vecU8=t.tagged=t.vec=t.bool=t.option=t.publicKey=t.i256=t.u256=t.i128=t.u128=t.i64=t.u64=t.struct=t.f64=t.f32=t.i32=t.u32=t.i16=t.u16=t.i8=t.u8=void 0;const o=ft,s=e,a=n(i);var u=ft;Object.defineProperty(t,"u8",{enumerable:1,get:function(){return u.u8}}),Object.defineProperty(t,"i8",{enumerable:1,get:function(){return u.s8}}),Object.defineProperty(t,"u16",{enumerable:1,get:function(){return u.u16}}),Object.defineProperty(t,"i16",{enumerable:1,get:function(){return u.s16}}),Object.defineProperty(t,"u32",{enumerable:1,get:function(){return u.u32}}),Object.defineProperty(t,"i32",{enumerable:1,get:function(){return u.s32}}),Object.defineProperty(t,"f32",{enumerable:1,get:function(){return u.f32}}),Object.defineProperty(t,"f64",{enumerable:1,get:function(){return u.f64}}),Object.defineProperty(t,"struct",{enumerable:1,get:function(){return u.struct}});class l extends o.Layout{constructor(e,t,r){super(e,r),this.blob=(0,o.blob)(e),this.signed=t}decode(e,t=0){const r=new a.default(this.blob.decode(e,t),10,"le");return this.signed?r.fromTwos(8*this.span).clone():r}encode(e,t,r=0){return this.signed&&(e=e.toTwos(8*this.span)),this.blob.encode(e.toArrayLike(Buffer,"le",this.span),t,r)}}function c(e){return new l(8,0,e)}t.u64=c,t.i64=function(e){return new l(8,1,e)},t.u128=function(e){return new l(16,0,e)},t.i128=function(e){return new l(16,1,e)},t.u256=function(e){return new l(32,0,e)},t.i256=function(e){return new l(32,1,e)};class d extends o.Layout{constructor(e,t,r,n){super(e.span,n),this.layout=e,this.decoder=t,this.encoder=r}decode(e,t){return this.decoder(this.layout.decode(e,t))}encode(e,t,r){return this.layout.encode(this.encoder(e),t,r)}getSpan(e,t){return this.layout.getSpan(e,t)}}t.publicKey=function(e){return new d((0,o.blob)(32),(e=>new s.PublicKey(e)),(e=>e.toBuffer()),e)};class h extends o.Layout{constructor(e,t){super(-1,t),this.layout=e,this.discriminator=(0,o.u8)()}encode(e,t,r=0){return null==e?this.discriminator.encode(0,t,r):(this.discriminator.encode(1,t,r),this.layout.encode(e,t,r+1)+1)}decode(e,t=0){const r=this.discriminator.decode(e,t);if(0===r)return null;if(1===r)return this.layout.decode(e,t+1);throw new Error("Invalid option "+this.property)}getSpan(e,t=0){const r=this.discriminator.decode(e,t);if(0===r)return 1;if(1===r)return this.layout.getSpan(e,t+1)+1;throw new Error("Invalid option "+this.property)}}function p(e){if(0===e)return 0;if(1===e)return 1;throw new Error("Invalid bool: "+e)}function m(e){return e?1:0}function f(e){const t=(0,o.u32)("length"),r=(0,o.struct)([t,(0,o.blob)((0,o.offset)(t,-t.span),"data")]);return new d(r,(({data:e})=>e),(e=>({data:e})),e)}t.option=function(e,t){return new h(e,t)},t.bool=function(e){return new d((0,o.u8)(),p,m,e)},t.vec=function(e,t){const r=(0,o.u32)("length"),n=(0,o.struct)([r,(0,o.seq)(e,(0,o.offset)(r,-r.span),"values")]);return new d(n,(({values:e})=>e),(e=>({values:e})),t)},t.tagged=function(e,t,r){const n=(0,o.struct)([c("tag"),t.replicate("data")]);return new d(n,(function({tag:t,data:r}){if(!t.eq(e))throw new Error("Invalid tag, expected: "+e.toString("hex")+", got: "+t.toString("hex"));return r}),(t=>({tag:e,data:t})),r)},t.vecU8=f,t.str=function(e){return new d(f(),(e=>e.toString("utf-8")),(e=>Buffer.from(e,"utf-8")),e)},t.rustEnum=function(e,t,r){const n=(0,o.union)(null!=r?r:(0,o.u8)(),t);return e.forEach(((e,t)=>n.addVariant(t,e,e.property))),n},t.array=function(e,t,r){const n=(0,o.struct)([(0,o.seq)(e,t,"values")]);return new d(n,(({values:e})=>e),(e=>({values:e})),r)};class g extends o.Layout{constructor(e,t,r){super(e.span+t.span,r),this.keyLayout=e,this.valueLayout=t}decode(e,t){return t=t||0,[this.keyLayout.decode(e,t),this.valueLayout.decode(e,t+this.keyLayout.getSpan(e,t))]}encode(e,t,r){r=r||0;const n=this.keyLayout.encode(e[0],t,r);return n+this.valueLayout.encode(e[1],t,r+n)}getSpan(e,t){return this.keyLayout.getSpan(e,t)+this.valueLayout.getSpan(e,t)}}t.map=function(e,t,r){const n=(0,o.u32)("length"),s=(0,o.struct)([n,(0,o.seq)(new g(e,t),(0,o.offset)(n,-n.span),"values")]);return new d(s,(({values:e})=>new Map(e)),(e=>({values:Array.from(e.entries())})),r)}}(mt);const Zt=mt.struct([mt.publicKey("owner"),mt.u64("lamports"),mt.option(mt.array(mt.u8(),32),"address"),mt.option(mt.struct([mt.array(mt.u8(),8,"discriminator"),mt.vecU8("data"),mt.array(mt.u8(),32,"dataHash")]),"data")],"compressedAccount"),Gt=mt.struct([mt.u8("merkleTreePubkeyIndex"),mt.u8("nullifierQueuePubkeyIndex"),mt.u32("leafIndex"),mt.option(mt.struct([mt.u8("queueId"),mt.u16("index")]),"queueIndex")],"merkleContext"),Xt=mt.struct([mt.array(mt.u8(),32,"seed"),mt.u8("addressQueueAccountIndex"),mt.u8("addressMerkleTreeAccountIndex"),mt.u16("addressMerkleTreeRootIndex")],"newAddressParams"),Yt=mt.struct([mt.option(mt.struct([mt.array(mt.u8(),32,"a"),mt.array(mt.u8(),64,"b"),mt.array(mt.u8(),32,"c")]),"proof"),mt.vec(mt.struct([Zt,Gt,mt.u16("rootIndex"),mt.bool("readOnly")]),"inputCompressedAccountsWithMerkleContext"),mt.vec(mt.struct([Zt,mt.u8("merkleTreeIndex")]),"outputCompressedAccounts"),mt.option(mt.u64(),"relayFee"),mt.vec(Xt,"newAddressParams"),mt.option(mt.u64(),"compressOrDecompressLamports"),mt.bool("isCompress")]);function er(e){const r=t.Buffer.alloc(1e3),n=Yt.encode(e,r),o=t.Buffer.from(r.slice(0,n)),s=t.Buffer.alloc(4);return s.writeUInt32LE(n,0),t.Buffer.concat([d,s,o])}const tr=mt.struct([mt.option(mt.struct([mt.array(mt.u8(),32,"a"),mt.array(mt.u8(),64,"b"),mt.array(mt.u8(),32,"c")]),"proof"),mt.vec(Xt,"newAddressParams"),mt.vec(mt.struct([Zt,Gt,mt.u16("rootIndex"),mt.bool("readOnly")]),"inputCompressedAccountsWithMerkleContext"),mt.vec(mt.struct([Zt,mt.u8("merkleTreeIndex")]),"outputCompressedAccounts"),mt.option(mt.u64(),"relayFee"),mt.option(mt.u64(),"compressOrDecompressLamports"),mt.bool("isCompress"),mt.option(mt.struct([mt.bool("set_context"),mt.bool("first_set_context"),mt.u8("cpi_context_account_index")]),"compressedCpiContext")]);function rr(e){return Yt.decode(e.slice(d.length+4))}function nr(e){return tr.decode(e.slice(h.length+4))}const or=e=>{const t=gr.programId,{feePayer:r,authority:n,registeredProgramPda:o,noopProgram:s,accountCompressionAuthority:i,accountCompressionProgram:a,solPoolPda:u,decompressionRecipient:l,systemProgram:c}=e;return[{pubkey:r,isSigner:1,isWritable:1},{pubkey:n,isSigner:1,isWritable:0},{pubkey:o,isSigner:0,isWritable:0},{pubkey:s,isSigner:0,isWritable:0},{pubkey:i,isSigner:0,isWritable:0},{pubkey:a,isSigner:0,isWritable:0},{pubkey:null!=u?u:t,isSigner:0,isWritable:null!==u},{pubkey:null!=l?l:t,isSigner:0,isWritable:1},{pubkey:c,isSigner:0,isWritable:0}]},sr=mt.struct([mt.vec(mt.array(mt.u8(),32),"inputCompressedAccountHashes"),mt.vec(mt.array(mt.u8(),32),"outputCompressedAccountHashes"),mt.vec(mt.struct([mt.struct([mt.publicKey("owner"),mt.u64("lamports"),mt.option(mt.array(mt.u8(),32),"address"),mt.option(mt.struct([mt.array(mt.u8(),8,"discriminator"),mt.vecU8("data"),mt.array(mt.u8(),32,"dataHash")]),"data")],"compressedAccount"),mt.u8("merkleTreeIndex")]),"outputCompressedAccounts"),mt.vec(mt.u32(),"outputLeafIndices"),mt.vec(mt.struct([mt.publicKey("pubkey"),mt.u64("seq")]),"sequenceNumbers"),mt.option(mt.u64(),"relayFee"),mt.bool("isCompress"),mt.option(mt.u64(),"compressOrDecompressLamports"),mt.vec(mt.publicKey(),"pubkeyArray"),mt.option(mt.vecU8(),"message")]);function ir(e){return sr.decode(e)}const ar=mt.struct([mt.u8("is_invoked_by_program"),mt.u8("bump"),mt.u8("num_queues"),mt.u8("num_output_queues"),mt.u8("start_output_appends"),mt.u8("num_address_queues"),mt.array(mt.u8(),32,"tx_hash")],"appendNullifyCreateAddressInputsMeta"),ur=mt.struct([mt.u8("index"),mt.array(mt.u8(),32,"leaf")],"appendLeavesInput"),lr=mt.struct([mt.array(mt.u8(),32,"account_hash"),mt.u32("leaf_index"),mt.u8("prove_by_index"),mt.u8("tree_index"),mt.u8("queue_index")],"insertNullifierInput"),cr=mt.struct([mt.array(mt.u8(),32,"address"),mt.u8("tree_index"),mt.u8("queue_index")],"insertAddressInput"),dr=mt.struct([mt.publicKey("pubkey"),mt.u64("seq")],"merkleTreeSequenceNumber");function hr(e){let t=0;const r=ar.decode(e,t);t+=ar.span;const n=e.readUInt8(t);t+=1;const o=[];for(let r=0;r<n;r++){const r=ur.decode(e,t);o.push(r),t+=ur.span}const s=e.readUInt8(t);t+=1;const i=[];for(let r=0;r<s;r++){const r=lr.decode(e,t);i.push(r),t+=lr.span}const a=e.readUInt8(t);t+=1;const u=[];for(let r=0;r<a;r++){const r=cr.decode(e,t);u.push(r),t+=cr.span}const l=e.readUInt8(t);t+=1;const c=[];for(let r=0;r<l;r++){const r=dr.decode(e,t);c.push(r),t+=dr.span}const d=e.readUInt8(t);t+=1;for(let r=0;r<d;r++)dr.decode(e,t),t+=dr.span;const h=e.readUInt8(t);t+=1;for(let r=0;r<h;r++)dr.decode(e,t),t+=dr.span;const p=e.readUInt8(t);t+=1;const m=[];for(let r=0;r<p;r++){const r=mt.u32().decode(e,t);m.push(r),t+=4}return{meta:r,leaves:o,nullifiers:i,addresses:u,sequence_numbers:c,output_leaf_indices:m}}function pr(r,n,o){const s=e=>Array.from(e instanceof t.Buffer?new Uint8Array(e):e);return{inputCompressedAccountHashes:r.nullifiers.map((e=>s(e.account_hash))),outputCompressedAccountHashes:r.leaves.map((e=>s(e.leaf))),outputCompressedAccounts:r.leaves.map(((r,n)=>{var a,u,l,c,d,h;return{compressedAccount:{owner:new e.PublicKey((null===(a=null==o?void 0:o.outputCompressedAccounts[n])||void 0===a?void 0:a.compressedAccount.owner)||e.PublicKey.default),lamports:new i.BN((null===(u=null==o?void 0:o.outputCompressedAccounts[n])||void 0===u?void 0:u.compressedAccount.lamports)||0),address:null==o?void 0:o.outputCompressedAccounts[n].compressedAccount.address,data:(null===(l=null==o?void 0:o.outputCompressedAccounts[n])||void 0===l?void 0:l.compressedAccount.data)?{discriminator:s(t.Buffer.from(null===(c=o.outputCompressedAccounts[n].compressedAccount.data)||void 0===c?void 0:c.discriminator)),data:null!==(d=s(t.Buffer.from(o.outputCompressedAccounts[n].compressedAccount.data.data)))&&void 0!==d?d:[],dataHash:s(t.Buffer.from(null===(h=o.outputCompressedAccounts[n].compressedAccount.data)||void 0===h?void 0:h.dataHash))}:null},merkleTreeIndex:r.index}})),outputLeafIndices:r.output_leaf_indices,sequenceNumbers:r.sequence_numbers.map((t=>({pubkey:new e.PublicKey(t.pubkey),seq:new i.BN(t.seq)}))),pubkeyArray:n.slice(2).filter((t=>!t.equals(e.PublicKey.default))),isCompress:(null==o?void 0:o.isCompress)||0,relayFee:(null==o?void 0:o.relayFee)?new i.BN(o.relayFee):null,compressOrDecompressLamports:(null==o?void 0:o.compressOrDecompressLamports)?new i.BN(o.compressOrDecompressLamports):null,message:null}}const mr=e=>e.reduce(((e,t)=>e.add(H(t.lamports))),H(0)),fr=t.Buffer.from("sol_pool_pda");class gr{constructor(){}static deriveCompressedSolPda(){const t=[fr],[r,n]=e.PublicKey.findProgramAddressSync(t,this.programId);return r}static createTransferOutputState(e,t,r){r=H(r);const n=mr(e).sub(r);return We(n),n.eq(H(0))?[Q(t,r)]:(Je(e),[Q(e[0].owner,n),Q(t,r)])}static createDecompressOutputState(e,t){t=H(t);const r=mr(e).sub(t);return We(r),r.eq(H(0))?[]:(Je(e),[Q(e[0].owner,r)])}static createNewAddressOutputState(e,t,r,n){r=H(null!=r?r:0);const o=mr(null!=n?n:[]).sub(r);return We(o),o.eq(H(0))||!n?[Q(t,r,void 0,e)]:(Je(n),[Q(n[0].owner,o),Q(t,r,void 0,e)])}static async createAccount({payer:t,newAddressParams:r,newAddress:n,recentValidityProof:o,outputStateTree:s,inputCompressedAccounts:i,inputStateRootIndices:a,lamports:u}){const l=this.createNewAddressOutputState(n,t,u,i),{packedInputCompressedAccounts:c,packedOutputCompressedAccounts:d,remainingAccounts:h}=ze(null!=i?i:[],null!=a?a:[],l,s),{newAddressParamsPacked:p,remainingAccounts:m}=rt([r],h),f=er({proof:o,inputCompressedAccountsWithMerkleContext:c,outputCompressedAccounts:d,relayFee:null,newAddressParams:p,compressOrDecompressLamports:null,isCompress:0}),g=[...or(Object.assign(Object.assign({},v()),{feePayer:t,authority:t,solPoolPda:null,decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...Qe(m)];return new e.TransactionInstruction({programId:this.programId,keys:g,data:f})}static async transfer({payer:t,inputCompressedAccounts:r,toAddress:n,lamports:o,recentInputStateRootIndices:s,recentValidityProof:i,outputStateTrees:a}){const u=this.createTransferOutputState(r,n,o),{packedInputCompressedAccounts:l,packedOutputCompressedAccounts:c,remainingAccounts:d}=ze(r,s,u,a),h=er({proof:i,inputCompressedAccountsWithMerkleContext:l,outputCompressedAccounts:c,relayFee:null,newAddressParams:[],compressOrDecompressLamports:null,isCompress:0}),p=[...or(Object.assign(Object.assign({},v()),{feePayer:t,authority:t,solPoolPda:null,decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...Qe(d)];return new e.TransactionInstruction({programId:this.programId,keys:p,data:h})}static async compress({payer:t,toAddress:r,lamports:n,outputStateTree:o}){n=H(n);const s=Q(r,n),{packedInputCompressedAccounts:i,packedOutputCompressedAccounts:a,remainingAccounts:u}=ze([],[],[s],o),l=er({proof:null,inputCompressedAccountsWithMerkleContext:i,outputCompressedAccounts:a,relayFee:null,newAddressParams:[],compressOrDecompressLamports:n,isCompress:1}),c=[...or(Object.assign(Object.assign({},v()),{feePayer:t,authority:t,solPoolPda:gr.deriveCompressedSolPda(),decompressionRecipient:null,systemProgram:e.SystemProgram.programId})),...Qe(u)];return new e.TransactionInstruction({programId:this.programId,keys:c,data:l})}static async decompress({payer:t,inputCompressedAccounts:r,toAddress:n,lamports:o,recentInputStateRootIndices:s,recentValidityProof:i,outputStateTree:a}){o=H(o);const u=this.createDecompressOutputState(r,o),{packedInputCompressedAccounts:l,packedOutputCompressedAccounts:c,remainingAccounts:d}=ze(r,s,u,a),h=er({proof:i,inputCompressedAccountsWithMerkleContext:l,outputCompressedAccounts:c,relayFee:null,newAddressParams:[],compressOrDecompressLamports:o,isCompress:0}),p=[...or(Object.assign(Object.assign({},v()),{feePayer:t,authority:t,solPoolPda:gr.deriveCompressedSolPda(),decompressionRecipient:n,systemProgram:e.SystemProgram.programId})),...Qe(d)];return new e.TransactionInstruction({programId:this.programId,keys:p,data:h})}}function yr(e,t){let r=H(0);t=H(t);const n=[];e.sort(((e,t)=>t.lamports.cmp(e.lamports)));for(const o of e){if(r.gte(H(t)))break;r=r.add(o.lamports),n.push(o)}if(r.lt(H(t)))throw new Error(`Insufficient balance for transfer. Required: ${t.toString()}, available: ${r.toString()}`);return[n,r]}gr.programId=new e.PublicKey("SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7");class wr extends TypeError{constructor(e,t){let r;const{message:n,explanation:o,...s}=e,{path:i}=e,a=0===i.length?n:`At path: ${i.join(".")} -- ${n}`;super(o??a),null!=o&&(this.cause=a),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function vr(e){return"object"==typeof e&&null!=e}function br(e){return vr(e)&&!Array.isArray(e)}function xr(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function Er(e,t,r,n){if(1==e)return;0==e?e={}:"string"==typeof e&&(e={message:e});const{path:o,branch:s}=t,{type:i}=r,{refinement:a,message:u=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${xr(n)}\``}=e;return{value:n,type:i,refinement:a,key:o[o.length-1],path:o,branch:s,...e,message:u}}function*Mr(e,t,r,n){var o;vr(o=e)&&"function"==typeof o[Symbol.iterator]||(e=[e]);for(const o of e){const e=Er(o,t,r,n);e&&(yield e)}}function*Ar(e,t,r={}){const{path:n=[],branch:o=[e],coerce:s=0,mask:i=0}=r,a={path:n,branch:o,mask:i};s&&(e=t.coercer(e,a));let u="valid";for(const n of t.validator(e,a))n.explanation=r.message,u="not_valid",yield[n,void 0];for(let[l,c,d]of t.entries(e,a)){const t=Ar(c,d,{path:void 0===l?n:[...n,l],branch:void 0===l?o:[...o,c],coerce:s,mask:i,message:r.message});for(const r of t)r[0]?(u=null!=r[0].refinement?"not_refined":"not_valid",yield[r[0],void 0]):s&&(c=r[1],void 0===l?e=c:e instanceof Map?e.set(l,c):e instanceof Set?e.add(c):vr(e)&&(void 0!==c||l in e)&&(e[l]=c))}if("not_valid"!==u)for(const n of t.refiner(e,a))n.explanation=r.message,u="not_refined",yield[n,void 0];"valid"===u&&(yield[void 0,e])}class Ir{constructor(e){const{type:t,schema:r,validator:n,refiner:o,coercer:s=(e=>e),entries:i=function*(){}}=e;this.type=t,this.schema=r,this.entries=i,this.coercer=s,this.validator=n?(e,t)=>Mr(n(e,t),t,this,e):()=>[],this.refiner=o?(e,t)=>Mr(o(e,t),t,this,e):()=>[]}assert(e,t){return function(e,t,r){const n=kr(e,t,{message:r});if(n[0])throw n[0]}(e,this,t)}create(e,t){return Tr(e,this,t)}is(e){return Sr(e,this)}mask(e,t){return function(e,t,r){const n=kr(e,t,{coerce:1,mask:1,message:r});if(n[0])throw n[0];return n[1]}(e,this,t)}validate(e,t={}){return kr(e,this,t)}}function Tr(e,t,r){const n=kr(e,t,{coerce:1,message:r});if(n[0])throw n[0];return n[1]}function Sr(e,t){return!kr(e,t)[0]}function kr(e,t,r={}){const n=Ar(e,t,r),o=function(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);return o[0]?[new wr(o[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]:[void 0,o[1]]}function Cr(e,t){return new Ir({type:e,schema:null,validator:t})}function _r(){return Cr("any",(()=>1))}function Pr(e){return new Ir({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${xr(e)}`})}function Nr(e){return Cr("instance",(t=>t instanceof e||`Expected a \`${e.name}\` instance, but received: ${xr(t)}`))}function Lr(e){const t=xr(e);return new Ir({type:"literal",schema:e,validator:r=>r===e||`Expected the literal \`${t}\`, but received: ${xr(r)}`})}function Or(e){return new Ir({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function Br(){return Cr("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${xr(e)}`))}function Rr(){return Cr("string",(e=>"string"==typeof e||`Expected a string, but received: ${xr(e)}`))}function Dr(e){const t=Object.keys(e);return new Ir({type:"type",schema:e,*entries(r){if(vr(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>br(e)||`Expected an object, but received: ${xr(e)}`,coercer:e=>br(e)?{...e}:e})}function Ur(e){const t=e.map((e=>e.type)).join(" | ");return new Ir({type:"union",schema:null,coercer(t,r){for(const n of e){const[e,o]=n.validate(t,{coerce:1,mask:r.mask});if(!e)return o}return t},validator(r,n){const o=[];for(const t of e){const[...e]=Ar(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&o.push(t)}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${xr(r)}`,...o]}})}function Fr(){return Cr("unknown",(()=>1))}function qr(e,t,r){return new Ir({...e,coercer:(n,o)=>Sr(n,t)?e.coercer(r(n,o),o):e.coercer(n,o)})}const Kr=qr(Nr(e.PublicKey),Rr(),(t=>new e.PublicKey(t))),Vr=qr(Nr(Array),Rr(),(t=>Array.from(new e.PublicKey(t).toBytes()))),Hr=qr(Nr(a),Rr(),(e=>$(e,"base58"))),$r=qr(Nr(a),Ur([Rr(),Br()]),(e=>{if("number"==typeof e){if(!Number.isSafeInteger(e))throw new Error(`Unsafe integer. Precision loss: ${e}`);return new a(e)}return new a(e,10)})),jr=qr(Rr(),Rr(),(e=>""===e?null:e));function Qr(e){return Ur([Dr({jsonrpc:Lr("2.0"),id:Rr(),result:e}),Dr({jsonrpc:Lr("2.0"),id:Rr(),error:Dr({code:Fr(),message:Rr(),data:Or(_r())})})])}const zr=Qr(Fr());function Wr(e){return qr(Qr(e),zr,(t=>"error"in t?t:Object.assign(Object.assign({},t),{result:Tr(t.result,e)})))}function Jr(e){return Wr(Dr({context:Dr({slot:Br()}),value:e}))}const Zr=Dr({address:Or(Vr),hash:Hr,data:Or(Dr({data:jr,dataHash:Hr,discriminator:$r})),lamports:$r,owner:Kr,leafIndex:Br(),tree:Kr,seq:Or($r),slotCreated:$r}),Gr=Dr({mint:Kr,owner:Kr,amount:$r,delegate:Or(Kr),state:Rr()}),Xr=Dr({tokenData:Gr,account:Zr}),Yr=Dr({items:Pr(Zr)}),en=Dr({items:Pr(Zr),cursor:Or(Rr())}),tn=Dr({items:Pr(Xr),cursor:Or(Rr())}),rn=Br(),nn=Rr(),on=Dr({items:Pr(Dr({signature:Rr(),slot:Br(),blockTime:Br(),error:Or(Rr())}))}),sn=Dr({items:Pr(Dr({signature:Rr(),slot:Br(),blockTime:Br()})),cursor:Or(Rr())}),an=Dr({hash:Hr,leafIndex:Br(),merkleTree:Kr,proof:Pr(Hr),rootSeq:Br(),root:Hr}),un=Dr({address:Hr,nextIndex:Br(),merkleTree:Kr,proof:Pr(Hr),rootSeq:Br(),root:Hr,lowerRangeAddress:Hr,higherRangeAddress:Hr,lowElementLeafIndex:Br()}),ln=Dr({a:Pr(Br()),b:Pr(Br()),c:Pr(Br())}),cn=Dr({compressedProof:ln,leafIndices:Pr(Br()),leaves:Pr(Hr),rootIndices:Pr(Br()),roots:Pr(Hr),merkleTrees:Pr(Kr)}),dn=Pr(an),hn=Dr({amount:$r}),pn=$r,mn=Dr({balance:$r,mint:Kr}),fn=Dr({tokenBalances:Pr(mn),cursor:Or(Rr())}),gn=Dr({items:Pr(mn),cursor:Or(Rr())}),yn=Dr({cursor:Or(Rr()),items:Pr(Dr({balance:$r,owner:Kr}))}),wn=Dr({hash:Pr(Br()),root:Pr(Br()),proof:Pr(Pr(Br()))}),vn=Dr({items:Pr(Dr({blockTime:Br(),signature:Rr(),slot:Br()}))}),bn=Dr({items:Pr(Dr({blockTime:Br(),signature:Rr(),slot:Br()})),cursor:Or(Rr())}),xn=Dr({compressionInfo:Dr({closedAccounts:Pr(Dr({account:Zr,optionalTokenData:Or(Gr)})),openedAccounts:Pr(Dr({account:Zr,optionalTokenData:Or(Gr)}))}),transaction:_r()});function En({discriminator:e,data:r,dataHash:n}){return{discriminator:e.toArray("le",8),data:t.Buffer.from(r,"base64"),dataHash:n.toArray("le",32)}}async function Mn(t,r,n,o=0){var s,i;const a=o?"getCompressedTokenAccountsByDelegate":"getCompressedTokenAccountsByOwner",u=o?"delegate":"owner",l=Tr(await Tn(t.compressionApiEndpoint,a,{[u]:r.toBase58(),mint:null===(s=n.mint)||void 0===s?void 0:s.toBase58(),limit:null===(i=n.limit)||void 0===i?void 0:i.toNumber(),cursor:n.cursor}),Jr(tn));if("error"in l)throw new e.SolanaJSONRPCError(l.error,`failed to get info for compressed accounts by ${u} ${r.toBase58()}`);if(null===l.result.value)throw new Error("not implemented: NULL result");const c=[],d=await t.getCachedActiveStateTreeInfo();return l.result.value.items.map((e=>{var t;const n=e.account,o=e.tokenData,s=Pn(d,n.tree),i=z(W(n.tree,s,n.hash.toArray("be",32),n.leafIndex),n.owner,H(n.lamports),n.data?En(n.data):void 0,n.address||void 0),a={mint:o.mint,owner:o.owner,amount:o.amount,delegate:o.delegate,state:["uninitialized","initialized","frozen"].indexOf(o.state),tlv:null};if((null===(t=a[u])||void 0===t?void 0:t.toBase58())!==r.toBase58())throw new Error(`RPC returned token account with ${u} different from requested ${u}`);c.push({compressedAccount:i,parsed:a})})),{items:c.sort(((e,t)=>t.compressedAccount.leafIndex-e.compressedAccount.leafIndex)),cursor:l.result.value.cursor}}function An(e,t){const r=e.account,n=e.optionalTokenData,o=Pn(t,r.tree),s=z(W(r.merkleTree,o,r.hash.toArray("be",32),r.leafIndex),r.owner,H(r.lamports),r.data?En(r.data):void 0,r.address||void 0);return null===n?{account:s,maybeTokenData:null}:{account:s,maybeTokenData:{mint:n.mint,owner:n.owner,amount:n.amount,delegate:n.delegate,state:["uninitialized","initialized","frozen"].indexOf(n.state),tlv:null}}}function In(e){return e.replace(/(":\s*)(-?\d+)(\s*[},])/g,((e,t,r,n)=>{const o=Number(r);return!Number.isNaN(o)&&(o>Number.MAX_SAFE_INTEGER||o<Number.MIN_SAFE_INTEGER)?`${t}"${r}"${n}`:e}))}const Tn=async(e,t,r=[],n=1,o=0)=>{const s=JSON.stringify({jsonrpc:"2.0",id:"test-account",method:t,params:r});if(o){const t=()=>{const t=s.replace(/"/g,'\\"');return`curl -X POST ${e} \\\n     -H "Content-Type: application/json" \\\n     -d "${t}"`};console.log("Debug: Stack trace:"),console.log((new Error).stack),console.log("\nDebug: curl:"),console.log(t()),console.log("\n")}const i=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:s});if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);const a=In(await i.text());return n?Ke(JSON.parse(a)):JSON.parse(a)},Sn=async(e,t,r=[],n=0)=>{let o,s="";n&&(s=`Proof generation for method:${t}`,console.time(s)),"inclusion"===t?o=JSON.stringify({circuitType:"inclusion",stateTreeHeight:26,inputCompressedAccounts:r}):"new-address"===t?o=JSON.stringify({circuitType:"non-inclusion",addressTreeHeight:26,newAddresses:r}):"combined"===t&&(o=JSON.stringify({circuitType:"combined",stateTreeHeight:26,addressTreeHeight:26,inputCompressedAccounts:r[0],newAddresses:r[1]}));const i=await fetch(`${e}/prove`,{method:"POST",headers:{"Content-Type":"application/json"},body:o});if(!i.ok)throw new Error(`Error fetching proof: ${i.statusText}`);const a=st(ot(await i.json()));return n&&console.timeEnd(s),a};function kn(e){const t=[];for(let r=0;r<e.length;r++){const n={root:Ue(e[r].root),pathIndex:e[r].leafIndex,pathElements:e[r].merkleProof.map((e=>Ue(e))),leaf:Ue(H(e[r].hash))};t.push(n)}return t}function Cn(e){const t=[];for(let r=0;r<e.length;r++){const n={root:Ue(e[r].root),value:Ue(e[r].value),pathIndex:e[r].indexHashedIndexedElementLeaf.toNumber(),pathElements:e[r].merkleProofHashedIndexedElementLeaf.map((e=>Ue(e))),nextIndex:e[r].nextIndex.toNumber(),leafLowerRangeValue:Ue(e[r].leafLowerRangeValue),leafHigherRangeValue:Ue(e[r].leafHigherRangeValue)};t.push(n)}return t}function _n(e,t,r){if(e.length!==t.length)throw new Error("Input lengths must match.");if(0===e.length)return new a(0);let n=r.poseidonHashBN([e[0].toString(),t[0].toString()]);for(let o=1;o<e.length;o++)n=r.poseidonHashBN([n.toString(),e[o].toString(),t[o].toString()]);return n}function Pn(e,t){const r=e.findIndex((e=>e.tree.equals(t)));if(-1===r)throw new Error("No associated queue found for tree. Please set activeStateTreeInfo with latest Tree accounts. If you use custom state trees, set manually.");if(!e[r].queue)throw new Error("Queue must not be null for state tree");return e[r].queue}function Nn(e){const t=e.length,r=Math.floor(Math.random()*t);if(!e[r].queue)throw new Error("Queue must not be null for state tree");return{tree:e[r].tree,queue:e[r].queue}}class Ln extends e.Connection{constructor(e,t,r,n){super(e,n||"confirmed"),this.activeStateTreeInfo=null,this.compressionApiEndpoint=t,this.proverEndpoint=r}setStateTreeInfo(e){this.activeStateTreeInfo=e}async getCachedActiveStateTreeInfo(){if(x(this.rpcEndpoint))return E();let e=null;if(!this.activeStateTreeInfo){const{mainnet:t,devnet:r}=b();try{e=await pt({connection:this,stateTreeLookupTableAddress:t[0].stateTreeLookupTable,nullifyTableAddress:t[0].nullifyTable}),this.activeStateTreeInfo=e}catch(t){e=await pt({connection:this,stateTreeLookupTableAddress:r[0].stateTreeLookupTable,nullifyTableAddress:r[0].nullifyTable}),this.activeStateTreeInfo=e}}if(!this.activeStateTreeInfo)throw new Error(`activeStateTreeInfo should not be null ${JSON.stringify(this.activeStateTreeInfo)}`);return this.activeStateTreeInfo}async getLatestActiveStateTreeInfo(){return this.activeStateTreeInfo=null,await this.getCachedActiveStateTreeInfo()}async getCompressedAccount(t,r){if(!r&&!t)throw new Error("Either hash or address must be provided");if(r&&t)throw new Error("Only one of hash or address must be provided");const n=Tr(await Tn(this.compressionApiEndpoint,"getCompressedAccount",{hash:r?j(r):void 0,address:t?j(t):void 0}),Jr(Or(Zr)));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get info for compressed account ${r?r.toString():t?t.toString():""}`);if(null===n.result.value)return null;const o=Pn(await this.getCachedActiveStateTreeInfo(),n.result.value.tree),s=n.result.value;return z(W(s.tree,o,s.hash.toArray("be",32),s.leafIndex),s.owner,H(s.lamports),s.data?En(s.data):void 0,s.address||void 0)}async getCompressedBalance(t,r){if(!r&&!t)throw new Error("Either hash or address must be provided");if(r&&t)throw new Error("Only one of hash or address must be provided");const n=Tr(await Tn(this.compressionApiEndpoint,"getCompressedBalance",{hash:r?j(r):void 0,address:t?j(t):void 0}),Jr(pn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get balance for compressed account ${r?r.toString():t?t.toString():""}`);return null===n.result.value?H(0):H(n.result.value)}async getCompressedBalanceByOwner(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getCompressedBalanceByOwner",{owner:t.toBase58()}),Jr(pn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get balance for compressed account ${t.toBase58()}`);return null===r.result.value?H(0):H(r.result.value)}async getCompressedAccountProof(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getCompressedAccountProof",{hash:j(t)}),Jr(an));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get proof for compressed account ${t.toString()}`);if(null===r.result.value)throw new Error(`failed to get proof for compressed account ${t.toString()}`);const n=Pn(await this.getCachedActiveStateTreeInfo(),r.result.value.merkleTree);return{hash:r.result.value.hash.toArray("be",32),merkleTree:r.result.value.merkleTree,leafIndex:r.result.value.leafIndex,merkleProof:r.result.value.proof,nullifierQueue:n,rootIndex:r.result.value.rootSeq%2400,root:r.result.value.root}}async getMultipleCompressedAccounts(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getMultipleCompressedAccounts",{hashes:t.map((e=>j(e)))}),Jr(Yr));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get info for compressed accounts ${t.map((e=>j(e))).join(", ")}`);if(null===r.result.value)throw new Error(`failed to get info for compressed accounts ${t.map((e=>j(e))).join(", ")}`);const n=await this.getCachedActiveStateTreeInfo(),o=[];return r.result.value.items.map((e=>{const t=Pn(n,e.tree),r=z(W(e.tree,t,e.hash.toArray("be",32),e.leafIndex),e.owner,H(e.lamports),e.data?En(e.data):void 0,e.address||void 0);o.push(r)})),o.sort(((e,t)=>t.leafIndex-e.leafIndex))}async getMultipleCompressedAccountProofs(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getMultipleCompressedAccountProofs",t.map((e=>j(e)))),Jr(Pr(an)));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get proofs for compressed accounts ${t.map((e=>j(e))).join(", ")}`);if(null===r.result.value)throw new Error(`failed to get proofs for compressed accounts ${t.map((e=>j(e))).join(", ")}`);const n=[],o=await this.getCachedActiveStateTreeInfo();for(const e of r.result.value){const t=Pn(o,e.merkleTree),r={hash:e.hash.toArray("be",32),merkleTree:e.merkleTree,leafIndex:e.leafIndex,merkleProof:e.proof,nullifierQueue:t,rootIndex:e.rootSeq%2400,root:e.root};n.push(r)}return n}async getCompressedAccountsByOwner(t,r){var n;const o=Tr(await Tn(this.compressionApiEndpoint,"getCompressedAccountsByOwner",{owner:t.toBase58(),filters:(null==r?void 0:r.filters)||[],dataSlice:null==r?void 0:r.dataSlice,cursor:null==r?void 0:r.cursor,limit:null===(n=null==r?void 0:r.limit)||void 0===n?void 0:n.toNumber()}),Jr(en));if("error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get info for compressed accounts owned by ${t.toBase58()}`);if(null===o.result.value)return{items:[],cursor:null};const s=[],i=await this.getCachedActiveStateTreeInfo();return o.result.value.items.map((e=>{const t=Pn(i,e.tree),r=z(W(e.tree,t,e.hash.toArray("be",32),e.leafIndex),e.owner,H(e.lamports),e.data?En(e.data):void 0,e.address||void 0);s.push(r)})),{items:s.sort(((e,t)=>t.leafIndex-e.leafIndex)),cursor:o.result.value.cursor}}async getCompressedTokenAccountsByOwner(e,t){return t||(t={}),await Mn(this,e,t,0)}async getCompressedTokenAccountsByDelegate(e,t){return t||(t={}),await Mn(this,e,t,1)}async getCompressedTokenAccountBalance(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getCompressedTokenAccountBalance",{hash:j(t)}),Jr(hn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get balance for compressed token account ${t.toString()}`);if(null===r.result.value)throw new Error(`failed to get balance for compressed token account ${t.toString()}`);return{amount:H(r.result.value.amount)}}async getCompressedTokenBalancesByOwner(t,r){var n,o;r||(r={});const s=Tr(await Tn(this.compressionApiEndpoint,"getCompressedTokenBalancesByOwner",{owner:t.toBase58(),mint:null===(n=r.mint)||void 0===n?void 0:n.toBase58(),limit:null===(o=r.limit)||void 0===o?void 0:o.toNumber(),cursor:r.cursor}),Jr(fn));if("error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get compressed token balances for owner ${t.toBase58()}`);if(null===s.result.value)throw new Error(`failed to get compressed token balances for owner ${t.toBase58()}`);return{items:r.mint?s.result.value.tokenBalances.filter((e=>e.mint.toBase58()===r.mint.toBase58())):s.result.value.tokenBalances,cursor:s.result.value.cursor}}async getCompressedTokenBalancesByOwnerV2(t,r){var n,o;r||(r={});const s=Tr(await Tn(this.compressionApiEndpoint,"getCompressedTokenBalancesByOwnerV2",{owner:t.toBase58(),mint:null===(n=r.mint)||void 0===n?void 0:n.toBase58(),limit:null===(o=r.limit)||void 0===o?void 0:o.toNumber(),cursor:r.cursor}),Jr(gn));if("error"in s)throw new e.SolanaJSONRPCError(s.error,`failed to get compressed token balances for owner ${t.toBase58()}`);if(null===s.result.value)throw new Error(`failed to get compressed token balances for owner ${t.toBase58()}`);const i=r.mint?s.result.value.items.filter((e=>e.mint.toBase58()===r.mint.toBase58())):s.result.value.items;return{context:s.result.context,value:{items:i,cursor:s.result.value.cursor}}}async getCompressionSignaturesForAccount(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForAccount",{hash:j(t)}),Jr(vn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get signatures for compressed account ${t.toString()}`);return r.result.value.items}async getTransactionWithCompressionInfo(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getTransactionWithCompressionInfo",{signature:t}),Wr(xn));if("error"in r)throw new e.SolanaJSONRPCError(r.error,"failed to get slot");if(null===r.result.transaction)return null;const n=[],o=[],s=await this.getCachedActiveStateTreeInfo();r.result.compressionInfo.closedAccounts.map((e=>{n.push(An(e,s))})),r.result.compressionInfo.openedAccounts.map((e=>{o.push(An(e,s))}));const i=e=>{const t=Object.values(e.reduce(((e,{maybeTokenData:t})=>{if(t){const{owner:r,mint:n,amount:o}=t,s=`${r.toBase58()}_${n.toBase58()}`;s in e?e[s].amount=e[s].amount.add(o):e[s]={owner:r,mint:n,amount:o}}return e}),{}));return t.length>0?t:void 0},a=i(n),u=i(o);return{compressionInfo:{closedAccounts:n,openedAccounts:o,preTokenBalances:a,postTokenBalances:u},transaction:r.result.transaction}}async getCompressionSignaturesForAddress(t,r){var n;const o=Tr(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForAddress",{address:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(n=null==r?void 0:r.limit)||void 0===n?void 0:n.toNumber()}),Jr(bn));if("error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get signatures for address ${t.toBase58()}`);if(null===o.result.value)throw new Error(`failed to get signatures for address ${t.toBase58()}`);return o.result.value}async getCompressionSignaturesForOwner(t,r){var n;const o=Tr(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForOwner",{owner:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(n=null==r?void 0:r.limit)||void 0===n?void 0:n.toNumber()}),Jr(bn));if("error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get signatures for owner ${t.toBase58()}`);if(null===o.result.value)throw new Error(`failed to get signatures for owner ${t.toBase58()}`);return o.result.value}async getCompressionSignaturesForTokenOwner(t,r){var n;const o=Tr(await Tn(this.compressionApiEndpoint,"getCompressionSignaturesForTokenOwner",{owner:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(n=null==r?void 0:r.limit)||void 0===n?void 0:n.toNumber()}),Jr(bn));if("error"in o)throw new e.SolanaJSONRPCError(o.error,`failed to get signatures for owner ${t.toBase58()}`);if(null===o.result.value)throw new Error(`failed to get signatures for owner ${t.toBase58()}`);return o.result.value}async getIndexerHealth(){const t=Tr(await Tn(this.compressionApiEndpoint,"getIndexerHealth"),Wr(nn));if("error"in t)throw new e.SolanaJSONRPCError(t.error,"failed to get health");return t.result}async confirmTransactionIndexed(e){const t=Date.now();for(;;){if(await this.getIndexerSlot()>=e)return 1;if(Date.now()-t>2e4)throw new Error("Timeout: Indexer slot did not reach the required slot within 20 seconds");await new Promise((e=>setTimeout(e,200)))}}async getIndexerSlot(){const t=Tr(await Tn(this.compressionApiEndpoint,"getIndexerSlot"),Wr(rn));if("error"in t)throw new e.SolanaJSONRPCError(t.error,"failed to get slot");return t.result}async getCompressedMintTokenHolders(t,r){var n;const o=Tr(await Tn(this.compressionApiEndpoint,"getCompressedMintTokenHolders",{mint:t.toBase58(),cursor:null==r?void 0:r.cursor,limit:null===(n=null==r?void 0:r.limit)||void 0===n?void 0:n.toNumber()}),Jr(yn));if("error"in o)throw new e.SolanaJSONRPCError(o.error,"failed to get mint token holders");return o.result}async getLatestCompressionSignatures(t,r){const n=Tr(await Tn(this.compressionApiEndpoint,"getLatestCompressionSignatures",{limit:r,cursor:t}),Jr(sn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,"failed to get latest non-voting signatures");return n.result}async getLatestNonVotingSignatures(t,r){const n=Tr(await Tn(this.compressionApiEndpoint,"getLatestNonVotingSignatures",{limit:t,cursor:r}),Jr(on));if("error"in n)throw new e.SolanaJSONRPCError(n.error,"failed to get latest non-voting signatures");return n.result}async getMultipleNewAddressProofs(t){const r=Tr(await Tn(this.compressionApiEndpoint,"getMultipleNewAddressProofs",t.map((e=>j(e)))),Jr(Pr(un)));if("error"in r)throw new e.SolanaJSONRPCError(r.error,`failed to get proofs for new addresses ${t.map((e=>j(e))).join(", ")}`);if(null===r.result.value)throw new Error(`failed to get proofs for new addresses ${t.map((e=>j(e))).join(", ")}`);const n=[];for(const e of r.result.value){const t={root:e.root,rootIndex:e.rootSeq%2400,value:e.address,leafLowerRangeValue:e.lowerRangeAddress,leafHigherRangeValue:e.higherRangeAddress,nextIndex:H(e.nextIndex),merkleProofHashedIndexedElementLeaf:e.proof,indexHashedIndexedElementLeaf:H(e.lowElementLeafIndex),merkleTree:e.merkleTree,nullifierQueue:M().addressQueue};n.push(t)}return n}async getValidityProofDirect(e=[],t=[]){let r;if(0===e.length&&0===t.length)throw new Error("Empty input. Provide hashes and/or new addresses.");if(e.length>0&&0===t.length){const t=await this.getMultipleCompressedAccountProofs(e),n=kn(t);r={compressedProof:await Sn(this.proverEndpoint,"inclusion",n,0),roots:t.map((e=>e.root)),rootIndices:t.map((e=>e.rootIndex)),leafIndices:t.map((e=>e.leafIndex)),leaves:t.map((e=>H(e.hash))),merkleTrees:t.map((e=>e.merkleTree)),nullifierQueues:t.map((e=>e.nullifierQueue))}}else if(0===e.length&&t.length>0){const e=await this.getMultipleNewAddressProofs(t),n=Cn(e);r={compressedProof:await Sn(this.proverEndpoint,"new-address",n,0),roots:e.map((e=>e.root)),rootIndices:e.map((e=>e.rootIndex)),leafIndices:e.map((e=>e.nextIndex.toNumber())),leaves:e.map((e=>H(e.value))),merkleTrees:e.map((e=>e.merkleTree)),nullifierQueues:e.map((e=>e.nullifierQueue))}}else{if(!(e.length>0&&t.length>0))throw new Error("Invalid input");{const n=await this.getMultipleCompressedAccountProofs(e),o=kn(n),s=await this.getMultipleNewAddressProofs(t),i=Cn(s);r={compressedProof:await Sn(this.proverEndpoint,"combined",[o,i],0),roots:n.map((e=>e.root)).concat(s.map((e=>e.root))),rootIndices:n.map((e=>e.rootIndex)).concat(s.map((e=>e.rootIndex))),leafIndices:n.map((e=>e.leafIndex)).concat(s.map((e=>e.nextIndex.toNumber()))),leaves:n.map((e=>H(e.hash))).concat(s.map((e=>H(e.value)))),merkleTrees:n.map((e=>e.merkleTree)).concat(s.map((e=>e.merkleTree))),nullifierQueues:n.map((e=>e.nullifierQueue)).concat(s.map((e=>e.nullifierQueue)))}}}return r}async getValidityProof(e=[],t=[]){const r=await this.getMultipleCompressedAccounts(e),n=r.map((e=>e.merkleTree)),o=r.map((e=>e.nullifierQueue)),s=M().addressTree,i=M().addressQueue,a=e.map(((e,t)=>({hash:e,tree:n[t],queue:o[t]}))),u=t.map((e=>({address:e,tree:s,queue:i})));return this.getValidityProofV0(a,u)}async getValidityProofV0(e=[],t=[]){const{value:r}=await this.getValidityProofAndRpcContext(e,t);return r}async getValidityProofAndRpcContext(t=[],r=[]){Ze(t.length,r.length);const n=Tr(await Tn(this.compressionApiEndpoint,"getValidityProof",{hashes:t.map((({hash:e})=>j(e))),newAddressesWithTrees:r.map((({address:e,tree:t})=>({address:j(e),tree:t.toBase58()})))}),Jr(cn));if("error"in n)throw new e.SolanaJSONRPCError(n.error,`failed to get ValidityProof for compressed accounts ${t.map((e=>e.toString()))}`);const o=n.result.value;if(null===o)throw new Error(`failed to get ValidityProof for compressed accounts ${t.map((e=>e.toString()))}`);return{value:{compressedProof:o.compressedProof,merkleTrees:o.merkleTrees,leafIndices:o.leafIndices,nullifierQueues:[...t.map((({queue:e})=>e)),...r.map((({queue:e})=>e))],rootIndices:o.rootIndices,roots:o.roots,leaves:o.leaves},context:n.result.context}}}function On(e,t){return t.includes(e)?t.filter((t=>t.publicKey.toString()!==e.publicKey.toString())):t}var Bn,Rn,Dn,Un,Fn,qn,Kn,Vn;exports.UtxoErrorCode=void 0,(Bn=exports.UtxoErrorCode||(exports.UtxoErrorCode={})).NEGATIVE_LAMPORTS="NEGATIVE_LAMPORTS",Bn.NOT_U64="NOT_U64",Bn.BLINDING_EXCEEDS_FIELD_SIZE="BLINDING_EXCEEDS_FIELD_SIZE",exports.SelectInUtxosErrorCode=void 0,(Rn=exports.SelectInUtxosErrorCode||(exports.SelectInUtxosErrorCode={})).FAILED_TO_FIND_UTXO_COMBINATION="FAILED_TO_FIND_UTXO_COMBINATION",Rn.INVALID_NUMBER_OF_IN_UTXOS="INVALID_NUMBER_OF_IN_UTXOS",exports.CreateUtxoErrorCode=void 0,(Dn=exports.CreateUtxoErrorCode||(exports.CreateUtxoErrorCode={})).OWNER_UNDEFINED="OWNER_UNDEFINED",Dn.INVALID_OUTPUT_UTXO_LENGTH="INVALID_OUTPUT_UTXO_LENGTH",Dn.UTXO_DATA_UNDEFINED="UTXO_DATA_UNDEFINED",exports.RpcErrorCode=void 0,(Un=exports.RpcErrorCode||(exports.RpcErrorCode={})).CONNECTION_UNDEFINED="CONNECTION_UNDEFINED",Un.RPC_PUBKEY_UNDEFINED="RPC_PUBKEY_UNDEFINED",Un.RPC_METHOD_NOT_IMPLEMENTED="RPC_METHOD_NOT_IMPLEMENTED",Un.RPC_INVALID="RPC_INVALID",exports.LookupTableErrorCode=void 0,(Fn=exports.LookupTableErrorCode||(exports.LookupTableErrorCode={})).LOOK_UP_TABLE_UNDEFINED="LOOK_UP_TABLE_UNDEFINED",Fn.LOOK_UP_TABLE_NOT_INITIALIZED="LOOK_UP_TABLE_NOT_INITIALIZED",exports.HashErrorCode=void 0,(exports.HashErrorCode||(exports.HashErrorCode={})).NO_POSEIDON_HASHER_PROVIDED="NO_POSEIDON_HASHER_PROVIDED",exports.ProofErrorCode=void 0,(qn=exports.ProofErrorCode||(exports.ProofErrorCode={})).INVALID_PROOF="INVALID_PROOF",qn.PROOF_INPUT_UNDEFINED="PROOF_INPUT_UNDEFINED",qn.PROOF_GENERATION_FAILED="PROOF_GENERATION_FAILED",exports.MerkleTreeErrorCode=void 0,(Kn=exports.MerkleTreeErrorCode||(exports.MerkleTreeErrorCode={})).MERKLE_TREE_NOT_INITIALIZED="MERKLE_TREE_NOT_INITIALIZED",Kn.SOL_MERKLE_TREE_UNDEFINED="SOL_MERKLE_TREE_UNDEFINED",Kn.MERKLE_TREE_UNDEFINED="MERKLE_TREE_UNDEFINED",Kn.INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE="INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE",Kn.MERKLE_TREE_INDEX_UNDEFINED="MERKLE_TREE_INDEX_UNDEFINED",Kn.MERKLE_TREE_SET_SPACE_UNDEFINED="MERKLE_TREE_SET_SPACE_UNDEFINED",exports.UtilsErrorCode=void 0,(Vn=exports.UtilsErrorCode||(exports.UtilsErrorCode={})).ACCOUNT_NAME_UNDEFINED_IN_IDL="ACCOUNT_NAME_UNDEFINED_IN_IDL",Vn.PROPERTY_UNDEFINED="PROPERTY_UNDEFINED",Vn.LOOK_UP_TABLE_CREATION_FAILED="LOOK_UP_TABLE_CREATION_FAILED",Vn.UNSUPPORTED_ARCHITECTURE="UNSUPPORTED_ARCHITECTURE",Vn.UNSUPPORTED_PLATFORM="UNSUPPORTED_PLATFORM",Vn.ACCOUNTS_UNDEFINED="ACCOUNTS_UNDEFINED",Vn.INVALID_NUMBER="INVALID_NUMBER";class Hn extends Error{constructor(e,t,r){super(`${e}: ${r}`),this.code=e,this.functionName=t,this.codeMessage=r}}class $n{constructor(e,t,r){this.index=e,this.value=t,this.nextIndex=r}equals(e){return this.value.eq(e.value)}compareTo(e){return this.value.cmp(e.value)}hash(e,t){try{return e.poseidonHash([H(this.value.toArray("be",32)).toString(),H(this.nextIndex).toString(),H(t.toArray("be",32)).toString()])}catch(e){throw new Error("Hashing failed")}}}class jn{constructor(e,t,r){this.newLowElement=e,this.newElement=t,this.newElementNextValue=r}}class Qn{constructor(e,t,r){this.elements=e,this.currentNodeIndex=t,this.highestElementIndex=r}static default(){return new Qn([new $n(0,H(0),0)],0,0)}get(e){return this.elements[e]}length(){return Number(this.currentNodeIndex)}isEmpty(){return 0===this.currentNodeIndex}findElement(e){return this.elements.slice(0,this.length()+1).find((t=>t.value===e))}init(){try{const e=l;return this.append(e)}catch(e){throw new Error(`Failed to initialize IndexedArray: ${e}`)}}findLowElementIndex(e){for(let t=0;t<=this.length();t++){const r=this.elements[t];if(this.elements[r.nextIndex].value.gt(e)&&r.value.lt(e))return t;if(r.value.eq(e))throw new Error("Element already exists in the array")}return this.highestElementIndex}findLowElement(e){const t=this.findLowElementIndex(e);if(void 0===t)return[void 0,void 0];const r=this.elements[t];return[r,this.elements[r.nextIndex].value]}hashElement(e,t){const r=this.elements[t];if(!r)return;const n=this.elements[r.nextIndex];return n?e.poseidonHash([H(r.value.toArray("be",32)).toString(),H(r.nextIndex).toString(),H(n.value.toArray("be",32)).toString()]):void 0}append(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.appendWithLowElementIndex(t,e)}appendWithLowElementIndex(e,t){const r=this.elements[e];if(0===r.nextIndex){if(t.lte(r.value))throw new Error("New element value must be greater than the low element value.")}else{const e=this.elements[r.nextIndex];if(t.lte(r.value))throw new Error("New element value must be greater than the low element value.");if(t.gte(e.value))throw new Error("New element value must be less than the next element value.")}const n=this.newElementWithLowElementIndex(e,t);return 0===r.nextIndex&&(this.highestElementIndex=n.newElement.index),this.currentNodeIndex=n.newElement.index,this.elements[this.length()]=n.newElement,this.elements[e]=n.newLowElement,n}lowest(){return this.elements.length>0?this.elements[0]:void 0}newElementWithLowElementIndex(e,t){const r=this.elements[e],n=this.currentNodeIndex+1,o=new $n(n,t,r.nextIndex);r.nextIndex=n;const s=this.elements[o.nextIndex].value;return new jn(r,o,s)}newElement(e){const t=this.findLowElementIndex(e);if(void 0===t)throw new Error("Low element index not found.");return this.newElementWithLowElementIndex(t,e)}}class zn{constructor(e,t,r=[],{zeroElement:n="0"}={}){if(this.levels=e,this.capacity=2**e,this.zeroElement=n,this._lightWasm=t,r.length>this.capacity)throw new Error("Tree is full");this._zeros=[],this._layers=[],this._layers[0]=r,this._zeros[0]=this.zeroElement;for(let t=1;t<=e;t++)this._zeros[t]=this._lightWasm.poseidonHashString([this._zeros[t-1],this._zeros[t-1]]);this._rebuild()}_rebuild(){for(let e=1;e<=this.levels;e++){this._layers[e]=[];for(let t=0;t<Math.ceil(this._layers[e-1].length/2);t++)this._layers[e][t]=this._lightWasm.poseidonHashString([this._layers[e-1][2*t],2*t+1<this._layers[e-1].length?this._layers[e-1][2*t+1]:this._zeros[e-1]])}}root(){return this._layers[this.levels].length>0?this._layers[this.levels][0]:this._zeros[this.levels]}insert(e){if(this._layers[0].length>=this.capacity)throw new Error("Tree is full");this.update(this._layers[0].length,e)}bulkInsert(e){if(this._layers[0].length+e.length>this.capacity)throw new Error("Tree is full");this._layers[0].push(...e),this._rebuild()}update(e,t){if(isNaN(Number(e))||e<0||e>this._layers[0].length||e>=this.capacity)throw new Error("Insert index out of bounds: "+e);this._layers[0][e]=t;for(let t=1;t<=this.levels;t++)e>>=1,this._layers[t][e]=this._lightWasm.poseidonHashString([this._layers[t-1][2*e],2*e+1<this._layers[t-1].length?this._layers[t-1][2*e+1]:this._zeros[t-1]])}path(e){if(isNaN(Number(e))||e<0||e>=this._layers[0].length)throw new Error("Index out of bounds: "+e);const t=[],r=[];for(let n=0;n<this.levels;n++)r[n]=e%2,t[n]=(1^e)<this._layers[n].length?this._layers[n][1^e]:this._zeros[n],e>>=1;return{pathElements:t,pathIndices:r}}indexOf(e,t=null){return t?this._layers[0].findIndex((r=>t(e,r))):this._layers[0].indexOf(e)}elements(){return this._layers[0].slice()}serialize(){return{levels:this.levels,_zeros:this._zeros,_layers:this._layers}}static deserialize(e,t){const r=Object.assign(Object.create(this.prototype),e);return r._hash=t,r.capacity=2**r.levels,r.zeroElement=r._zeros[0],r}}async function Wn(e){const t=[],{noopProgram:r,accountCompressionProgram:n}=v(),o=(await e.getConfirmedSignaturesForAddress2(n,void 0,"confirmed")).map((e=>e.signature)),s=await e.getParsedTransactions(o,{maxSupportedTransactionVersion:0,commitment:"confirmed"});for(const r of s){if(!r||!r.transaction||!r.meta)continue;if(!r.meta.innerInstructions||0==r.meta.innerInstructions.length)continue;const n=r.transaction.message.accountKeys.map((e=>e.pubkey)),o=[],s=await e.getTransaction(r.transaction.signatures[0],{commitment:"confirmed",maxSupportedTransactionVersion:0});for(const e of(null==s?void 0:s.transaction.message.compiledInstructions)||[])if(e.data&&e.data.length>0){const t=Uint8Array.from(e.data);if(t.length===c.length&&c.every(((e,r)=>e===t[r])))continue;o.push(t)}const i=[];if(s.meta.innerInstructions&&s.meta.innerInstructions.length>0)for(const e of s.meta.innerInstructions)for(const t of e.instructions){const e=t.accounts.map((e=>n[e]));if(i.push(e),t.data&&t.data.length>0){const e=V.decode(t.data);o.push(e)}}const a=Gn(o,i);a&&t.push(a)}if(t.length>0)return t;const i=s.filter((e=>e?e.transaction.message.accountKeys.some((e=>("string"==typeof e?e:e.pubkey.toBase58())===r.toBase58())):0));return Jn(i,Zn)}const Jn=(e,r)=>{const{noopProgram:n}=v(),o=[];return e.forEach((e=>{!e||!e.meta||e.meta.err||!e.meta.innerInstructions||e.meta.innerInstructions.length<=0||e.meta.innerInstructions.forEach((s=>{if(s.instructions.length>0){const i=s.instructions[s.instructions.length-1];if("data"in i&&i.data&&i.programId.toBase58()===n.toBase58()){const n=V.decode(i.data),s=r(t.Buffer.from(n),e);null!=s&&o.push(s)}}}))})),o},Zn=e=>{const r=t.Buffer.from(e.map((e=>e)));try{return ir(r)}catch(e){return console.error("Error deserializing event:",e),null}};function Gn(e,r){let n=0,o=null,s=null;for(const r of e){const e=r.slice(0,8),s=V.encode(e),i=V.encode(d),a=V.encode(h);if(s===i){o=rr(t.Buffer.from(r)),n=1;break}if(s==a){o=nr(t.Buffer.from(r)),n=1;break}}if(!n)return null;for(const r of e){const e=r.slice(0,8);if(V.encode(e)!==V.encode(p))console.log("discriminator does not match");else{const e=r.slice(12);s=hr(t.Buffer.from(e))}}return o?pr(s,r[r.length-1],o):null}async function Xn(e,t){return(await Yn(e)).find((e=>H(e.hash).eq(t)))}async function Yn(e){var t,r;const n=(await Wn(e)).reverse(),o=[],s=[];for(const e of n){for(let n=0;n<e.outputCompressedAccounts.length;n++){const s=e.outputCompressedAccounts[n],i={merkleTree:M().merkleTree,nullifierQueue:M().nullifierQueue,hash:e.outputCompressedAccountHashes[n],leafIndex:e.outputLeafIndices[n]},a=z(i,s.compressedAccount.owner,s.compressedAccount.lamports,null!==(t=s.compressedAccount.data)&&void 0!==t?t:void 0,null!==(r=s.compressedAccount.address)&&void 0!==r?r:void 0);o.push(a)}for(let t=0;t<e.inputCompressedAccountHashes.length;t++){const r=e.inputCompressedAccountHashes[t];s.push(H(r))}}const i=o.filter((e=>!s.some((t=>t.eq(H(e.hash))))));return i.sort(((e,t)=>t.leafIndex-e.leafIndex)),i}const eo=new e.PublicKey("cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m"),to=mt.struct([mt.publicKey("mint"),mt.publicKey("owner"),mt.u64("amount"),mt.option(mt.publicKey(),"delegate"),mt.u8("state"),mt.option(mt.vecU8(),"tlv")]);function ro(e,t=eo){if(null===e.data)return null;const{data:r}=e.data;if(0===r.length)return null;if(e.owner.toBase58()!==t.toBase58())throw new Error(`Invalid owner ${e.owner.toBase58()} for token layout`);return to.decode(Buffer.from(r))}async function no(e){const t=await Promise.all(e.map((e=>async function(e){const t=e.pubkeyArray,r=e.outputCompressedAccountHashes,n=e.outputCompressedAccounts.map(((n,o)=>{var s;const i={merkleTree:t[e.outputCompressedAccounts[o].merkleTreeIndex],nullifierQueue:M().nullifierQueue,hash:r[o],leafIndex:e.outputLeafIndices[o]};if(!n.compressedAccount.data)throw new Error("No data");const a=ro(n.compressedAccount);if(!a)throw new Error("Invalid token data");return{compressedAccount:z(i,n.compressedAccount.owner,n.compressedAccount.lamports,n.compressedAccount.data,null!==(s=n.compressedAccount.address)&&void 0!==s?s:void 0),parsed:a}}));return{inputCompressedAccountHashes:e.inputCompressedAccountHashes,outputCompressedAccounts:n}}(e)))),r=t.flatMap((e=>e.outputCompressedAccounts)),n=t.flatMap((e=>e.inputCompressedAccountHashes));return r.filter((e=>!n.some((t=>JSON.stringify(t)===JSON.stringify(e.compressedAccount.hash)))))}async function oo(e,t,r){const n=await Wn(e);return{items:(await no(n)).filter((e=>e.parsed.owner.equals(t)&&e.parsed.mint.equals(r))).sort(((e,t)=>t.compressedAccount.leafIndex-e.compressedAccount.leafIndex)),cursor:null}}async function so(e,t,r){const n=await Wn(e);return{items:(await no(n)).filter((e=>{var n;return(null===(n=e.parsed.delegate)||void 0===n?void 0:n.equals(t))&&e.parsed.mint.equals(r)})),cursor:null}}async function io(e,t){const r=await Wn(e),n=(await no(r)).filter((e=>H(e.compressedAccount.hash).eq(t)));if(0===n.length)throw new Error("No compressed account found");return n[0]}class ao extends e.Connection{constructor(e,t,r,n,o,s){super(e,o||"confirmed"),this.log=0,this.activeStateTreeInfo=null,this.compressionApiEndpoint=r,this.proverEndpoint=n;const{merkleTreeAddress:i,nullifierQueueAddress:a,depth:u,log:l,addressTreeAddress:c,addressQueueAddress:d}=null!=s?s:{},{merkleTree:h,nullifierQueue:p,merkleTreeHeight:m,addressQueue:f,addressTree:g}=M();this.lightWasm=t,this.merkleTreeAddress=null!=i?i:h,this.nullifierQueueAddress=null!=a?a:p,this.addressTreeAddress=null!=c?c:g,this.addressQueueAddress=null!=d?d:f,this.depth=null!=u?u:m,this.log=null!=l?l:0}setStateTreeInfo(e){this.activeStateTreeInfo=e}async getCachedActiveStateTreeInfo(){return E()}async getLatestActiveStateTreeInfo(){return E()}async getCompressedAccount(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const r=await Xn(this,t);return null!=r?r:null}async getCompressedBalance(e,t){if(e)throw new Error("address is not supported in test-rpc");if(!t)throw new Error("hash is required");const r=await Xn(this,t);if(!r)throw new Error("Account not found");return H(r.lamports)}async getCompressedBalanceByOwner(e){return(await this.getCompressedAccountsByOwner(e)).items.reduce(((e,t)=>e.add(t.lamports)),H(0))}async getCompressedAccountProof(e){return(await this.getMultipleCompressedAccountProofs([e]))[0]}async getMultipleCompressedAccounts(e){return await async function(e,t){return(await Yn(e)).filter((e=>t.some((t=>H(e.hash).eq(t))))).sort(((e,t)=>t.leafIndex-e.leafIndex))}(this,e)}async confirmTransactionIndexed(e){return 1}async getMultipleCompressedAccountProofs(e){const t=await Wn(this).then((e=>e.reverse())),r=[],n=[];for(const e of t)for(let t=0;t<e.outputCompressedAccounts.length;t++){const o=e.outputCompressedAccountHashes[t];r.push(o),n.push(e.outputLeafIndices[t])}const o=new zn(this.depth,this.lightWasm,r.map((e=>H(e).toString()))),s=[];for(let t=0;t<e.length;t++){const n=o.indexOf(e[t].toString()),i=o.path(n).pathElements.map((e=>H(e))),a=H(o.root()),u={hash:e[t].toArray("be",32),merkleTree:this.merkleTreeAddress,leafIndex:n,merkleProof:i,nullifierQueue:this.nullifierQueueAddress,rootIndex:r.length,root:a};s.push(u)}return s.forEach(((e,t)=>{const r=e.leafIndex,n=o.elements()[r],s=H(n).toArray("be",32);if(!s.every(((t,r)=>t===e.hash[r])))throw new Error(`Mismatch at index ${t}: expected ${e.hash.toString()}, got ${s.toString()}`)})),s}async getCompressedAccountsByOwner(e,t){const r=await async function(e,t){return(await Yn(e)).filter((e=>e.owner.equals(t)))}(this,e);return{items:r,cursor:null}}async getLatestCompressionSignatures(e,t){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getLatestNonVotingSignatures(e){throw new Error("getLatestNonVotingSignaturesWithContext not supported in test-rpc")}async getCompressedTokenAccountsByOwner(e,t){return await oo(this,e,t.mint)}async getCompressedTokenAccountsByDelegate(e,t){return await so(this,e,t.mint)}async getCompressedTokenAccountBalance(e){const t=await io(this,e);return{amount:H(t.parsed.amount)}}async getCompressedTokenBalancesByOwner(e,t){return{items:(await oo(this,e,t.mint)).items.map((e=>({balance:H(e.parsed.amount),mint:e.parsed.mint}))),cursor:null}}async getCompressedTokenBalancesByOwnerV2(e,t){return{context:{slot:1},value:{items:(await oo(this,e,t.mint)).items.map((e=>({balance:H(e.parsed.amount),mint:e.parsed.mint}))),cursor:null}}}async getCompressionSignaturesForAccount(e){throw new Error("getCompressionSignaturesForAccount not implemented in test-rpc")}async getTransactionWithCompressionInfo(e){throw new Error("getCompressedTransaction not implemented in test-rpc")}async getCompressionSignaturesForAddress(e,t){throw new Error("getSignaturesForAddress3 not implemented")}async getCompressionSignaturesForOwner(e,t){throw new Error("getSignaturesForOwner not implemented")}async getCompressionSignaturesForTokenOwner(e,t){throw new Error("getSignaturesForTokenOwner not implemented")}async getIndexerHealth(){return"ok"}async getIndexerSlot(){return 1}async getMultipleNewAddressProofs(e){const t=Qn.default(),r=[];t.init();const n=[];for(let e=0;e<r.length;e++)t.append(H(r[e]));for(let e=0;e<t.elements.length;e++){const r=t.hashElement(this.lightWasm,e);n.push(H(r))}const o=new zn(this.depth,this.lightWasm,n.map((e=>H(e).toString()))),s=[];for(let r=0;r<e.length;r++){const[n]=t.findLowElement(e[r]);if(!n)throw new Error("Address not found");const i=n.index,a=o.path(i).pathElements.map((e=>H(e))),u=t.get(n.nextIndex).value,l={root:H(o.root()),rootIndex:3,value:e[r],leafLowerRangeValue:n.value,leafHigherRangeValue:u,nextIndex:H(n.nextIndex),merkleProofHashedIndexedElementLeaf:a,indexHashedIndexedElementLeaf:H(n.index),merkleTree:this.addressTreeAddress,nullifierQueue:this.addressQueueAddress};s.push(l)}return s}async getCompressedMintTokenHolders(e,t){throw new Error("getCompressedMintTokenHolders not implemented in test-rpc")}async getValidityProofDirect(e=[],t=[]){return this.getValidityProof(e,t)}async getValidityProofAndRpcContext(e=[],t=[]){if(t.some((e=>!(e instanceof a))))throw new Error("AddressWithTree is not supported in test-rpc");return{value:await this.getValidityProofV0(e,t),context:{slot:1}}}async getValidityProof(e=[],t=[]){if(t.some((e=>!(e instanceof a))))throw new Error("AddressWithTree is not supported in test-rpc");let r;if(0===e.length&&0===t.length)throw new Error("Empty input. Provide hashes and/or new addresses.");if(e.length>0&&0===t.length){const t=await this.getMultipleCompressedAccountProofs(e),n=kn(t);r={compressedProof:await Sn(this.proverEndpoint,"inclusion",n,this.log),roots:t.map((e=>e.root)),rootIndices:t.map((e=>e.rootIndex)),leafIndices:t.map((e=>e.leafIndex)),leaves:t.map((e=>H(e.hash))),merkleTrees:t.map((e=>e.merkleTree)),nullifierQueues:t.map((e=>e.nullifierQueue))}}else if(0===e.length&&t.length>0){const e=await this.getMultipleNewAddressProofs(t),n=Cn(e);r={compressedProof:await Sn(this.proverEndpoint,"new-address",n,this.log),roots:e.map((e=>e.root)),rootIndices:e.map((()=>3)),leafIndices:e.map((e=>e.indexHashedIndexedElementLeaf.toNumber())),leaves:e.map((e=>H(e.value))),merkleTrees:e.map((e=>e.merkleTree)),nullifierQueues:e.map((e=>e.nullifierQueue))}}else{if(!(e.length>0&&t.length>0))throw new Error("Invalid input");{const n=await this.getMultipleCompressedAccountProofs(e),o=kn(n),s=await this.getMultipleNewAddressProofs(t),i=Cn(s);r={compressedProof:await Sn(this.proverEndpoint,"combined",[o,i],this.log),roots:n.map((e=>e.root)).concat(s.map((e=>e.root))),rootIndices:n.map((e=>e.rootIndex)).concat(s.map((()=>3))),leafIndices:n.map((e=>e.leafIndex)).concat(s.map((e=>e.indexHashedIndexedElementLeaf.toNumber()))),leaves:n.map((e=>H(e.hash))).concat(s.map((e=>H(e.value)))),merkleTrees:n.map((e=>e.merkleTree)).concat(s.map((e=>e.merkleTree))),nullifierQueues:n.map((e=>e.nullifierQueue)).concat(s.map((e=>e.nullifierQueue)))}}}return r}async getValidityProofV0(e=[],t=[]){return this.getValidityProof(e.map((e=>e.hash)),t.map((e=>e.address)))}}let uo=1;const lo=mo(255),co=mo(254),ho=mo(253),po=mo(252);function mo(t){if(t||(t=uo,uo++),t>255)return e.Keypair.generate();const r=new Uint8Array(32);return r[31]=t,e.Keypair.fromSeed(r)}exports.ADDRESS_QUEUE_ROLLOVER_FEE=F,exports.ADDRESS_TREE_NETWORK_FEE=K,exports.ALICE=lo,exports.AccountProofResult=wn,exports.AppendLeavesInputLayout=ur,exports.AppendNullifyCreateAddressInputsMetaLayout=ar,exports.BOB=co,exports.BalanceResult=hn,exports.CHARLIE=ho,exports.COMPUTE_BUDGET_PATTERN=c,exports.CompressedAccountLayout=Zt,exports.CompressedAccountResult=Zr,exports.CompressedAccountsByOwnerResult=en,exports.CompressedMintTokenHoldersResult=yn,exports.CompressedTokenAccountResult=Xr,exports.CompressedTokenAccountsByOwnerOrDelegateResult=tn,exports.CompressedTransactionResult=xn,exports.CreateUtxoError=class extends Hn{},exports.DAVE=po,exports.DEFAULT_MERKLE_TREE_HEIGHT=R,exports.DEFAULT_MERKLE_TREE_ROOTS=2800,exports.DEFAULT_ZERO="0",exports.FIELD_SIZE=u,exports.HIGHEST_ADDRESS_PLUS_ONE=l,exports.HashError=class extends Hn{},exports.HealthResult=nn,exports.IDL={version:"1.2.0",name:"light_system_program",constants:[{name:"SOL_POOL_PDA_SEED",type:"bytes",value:"[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]"}],instructions:[{name:"initCpiContextAccount",accounts:[{name:"feePayer",isMut:1,isSigner:1},{name:"cpiContextAccount",isMut:1,isSigner:0},{name:"associatedMerkleTree",isMut:0,isSigner:0}],args:[]},{name:"invoke",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:0,isSigner:0,docs:["Merkle trees."]},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs",type:"bytes"}]},{name:"invokeCpi",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"invokingProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0},{name:"cpiContextAccount",isMut:1,isSigner:0,isOptional:1}],args:[{name:"inputs",type:"bytes"}]},{name:"invokeCpiWithReadOnly",accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0},{name:"accountCompressionProgram",isMut:0,isSigner:0},{name:"invokingProgram",isMut:0,isSigner:0},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1},{name:"systemProgram",isMut:0,isSigner:0},{name:"cpiContextAccount",isMut:1,isSigner:0,isOptional:1}],args:[{name:"inputs",type:"bytes"}]},{name:"stubIdlBuild",docs:["This function is a stub to allow Anchor to include the input types in","the IDL. It should not be included in production builds nor be called in","practice."],accounts:[{name:"feePayer",isMut:1,isSigner:1,docs:["Fee payer needs to be mutable to pay rollover and protocol fees."]},{name:"authority",isMut:0,isSigner:1},{name:"registeredProgramPda",isMut:0,isSigner:0},{name:"noopProgram",isMut:0,isSigner:0},{name:"accountCompressionAuthority",isMut:0,isSigner:0,docs:["This pda is used to invoke the account compression program."]},{name:"accountCompressionProgram",isMut:0,isSigner:0,docs:["Merkle trees."]},{name:"solPoolPda",isMut:1,isSigner:0,isOptional:1,docs:["Sol pool pda is used to store the native sol that has been compressed.","It's only required when compressing or decompressing sol."]},{name:"decompressionRecipient",isMut:1,isSigner:0,isOptional:1,docs:["Only needs to be provided for decompression as a recipient for the","decompressed sol.","Compressed sol originate from authority."]},{name:"systemProgram",isMut:0,isSigner:0}],args:[{name:"inputs1",type:{defined:"InstructionDataInvoke"}},{name:"inputs2",type:{defined:"InstructionDataInvokeCpi"}},{name:"inputs3",type:{defined:"PublicTransactionEvent"}}]}],accounts:[{name:"cpiContextAccount",docs:["Collects instruction data without executing a compressed transaction.","Signer checks are performed on instruction data.","Collected instruction data is combined with the instruction data of the executing cpi,","and executed as a single transaction.","This enables to use input compressed accounts that are owned by multiple programs,","with one zero-knowledge proof."],type:{kind:"struct",fields:[{name:"feePayer",type:"publicKey"},{name:"associatedMerkleTree",type:"publicKey"},{name:"context",type:{vec:{defined:"InstructionDataInvokeCpi"}}}]}}],types:[{name:"InstructionDataInvoke",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"}]}},{name:"NewAddressParamsPacked",type:{kind:"struct",fields:[{name:"seed",type:{array:["u8",32]}},{name:"addressQueueAccountIndex",type:"u8"},{name:"addressMerkleTreeAccountIndex",type:"u8"},{name:"addressMerkleTreeRootIndex",type:"u16"}]}},{name:"OutputCompressedAccountWithPackedContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleTreeIndex",type:"u8"}]}},{name:"CompressedProof",type:{kind:"struct",fields:[{name:"a",type:{array:["u8",32]}},{name:"b",type:{array:["u8",64]}},{name:"c",type:{array:["u8",32]}}]}},{name:"InstructionDataInvokeCpi",type:{kind:"struct",fields:[{name:"proof",type:{option:{defined:"CompressedProof"}}},{name:"newAddressParams",type:{vec:{defined:"NewAddressParamsPacked"}}},{name:"inputCompressedAccountsWithMerkleContext",type:{vec:{defined:"PackedCompressedAccountWithMerkleContext"}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"relayFee",type:{option:"u64"}},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"cpiContext",type:{option:{defined:"CompressedCpiContext"}}}]}},{name:"CompressedCpiContext",type:{kind:"struct",fields:[{name:"setContext",docs:["Is set by the program that is invoking the CPI to signal that is should","set the cpi context."],type:"bool"},{name:"firstSetContext",docs:["Is set to wipe the cpi context since someone could have set it before","with unrelated data."],type:"bool"},{name:"cpiContextAccountIndex",docs:["Index of cpi context account in remaining accounts."],type:"u8"}]}},{name:"CompressedAccount",type:{kind:"struct",fields:[{name:"owner",type:"publicKey"},{name:"lamports",type:"u64"},{name:"address",type:{option:{array:["u8",32]}}},{name:"data",type:{option:{defined:"CompressedAccountData"}}}]}},{name:"CompressedAccountData",type:{kind:"struct",fields:[{name:"discriminator",type:{array:["u8",8]}},{name:"data",type:"bytes"},{name:"dataHash",type:{array:["u8",32]}}]}},{name:"PackedCompressedAccountWithMerkleContext",type:{kind:"struct",fields:[{name:"compressedAccount",type:{defined:"CompressedAccount"}},{name:"merkleContext",type:{defined:"PackedMerkleContext"}},{name:"rootIndex",docs:["Index of root used in inclusion validity proof."],type:"u16"},{name:"readOnly",docs:["Placeholder to mark accounts read-only unimplemented set to false."],type:"bool"}]}},{name:"PackedMerkleContext",type:{kind:"struct",fields:[{name:"merkleTreePubkeyIndex",type:"u8"},{name:"nullifierQueuePubkeyIndex",type:"u8"},{name:"leafIndex",type:"u32"},{name:"queueIndex",type:{option:{defined:"QueueIndex"}}}]}},{name:"QueueIndex",type:{kind:"struct",fields:[{name:"queueId",docs:["Id of queue in queue account."],type:"u8"},{name:"index",docs:["Index of compressed account hash in queue."],type:"u16"}]}},{name:"MerkleTreeSequenceNumber",type:{kind:"struct",fields:[{name:"pubkey",type:"publicKey"},{name:"seq",type:"u64"}]}},{name:"PublicTransactionEvent",type:{kind:"struct",fields:[{name:"inputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccountHashes",type:{vec:{array:["u8",32]}}},{name:"outputCompressedAccounts",type:{vec:{defined:"OutputCompressedAccountWithPackedContext"}}},{name:"outputLeafIndices",type:{vec:"u32"}},{name:"sequenceNumbers",type:{vec:{defined:"MerkleTreeSequenceNumber"}}},{name:"relayFee",type:{option:"u64"}},{name:"isCompress",type:"bool"},{name:"compressOrDecompressLamports",type:{option:"u64"}},{name:"pubkeyArray",type:{vec:"publicKey"}},{name:"message",type:{option:"bytes"}}]}}],errors:[{code:6e3,name:"SumCheckFailed",msg:"Sum check failed"},{code:6001,name:"SignerCheckFailed",msg:"Signer check failed"},{code:6002,name:"CpiSignerCheckFailed",msg:"Cpi signer check failed"},{code:6003,name:"ComputeInputSumFailed",msg:"Computing input sum failed."},{code:6004,name:"ComputeOutputSumFailed",msg:"Computing output sum failed."},{code:6005,name:"ComputeRpcSumFailed",msg:"Computing rpc sum failed."},{code:6006,name:"InvalidAddress",msg:"InvalidAddress"},{code:6007,name:"DeriveAddressError",msg:"DeriveAddressError"},{code:6008,name:"CompressedSolPdaUndefinedForCompressSol",msg:"CompressedSolPdaUndefinedForCompressSol"},{code:6009,name:"DeCompressLamportsUndefinedForCompressSol",msg:"DeCompressLamportsUndefinedForCompressSol"},{code:6010,name:"CompressedSolPdaUndefinedForDecompressSol",msg:"CompressedSolPdaUndefinedForDecompressSol"},{code:6011,name:"DeCompressLamportsUndefinedForDecompressSol",msg:"DeCompressLamportsUndefinedForDecompressSol"},{code:6012,name:"DecompressRecipientUndefinedForDecompressSol",msg:"DecompressRecipientUndefinedForDecompressSol"},{code:6013,name:"WriteAccessCheckFailed",msg:"WriteAccessCheckFailed"},{code:6014,name:"InvokingProgramNotProvided",msg:"InvokingProgramNotProvided"},{code:6015,name:"InvalidCapacity",msg:"InvalidCapacity"},{code:6016,name:"InvalidMerkleTreeOwner",msg:"InvalidMerkleTreeOwner"},{code:6017,name:"ProofIsNone",msg:"ProofIsNone"},{code:6018,name:"ProofIsSome",msg:"Proof is some but no input compressed accounts or new addresses provided."},{code:6019,name:"EmptyInputs",msg:"EmptyInputs"},{code:6020,name:"CpiContextAccountUndefined",msg:"CpiContextAccountUndefined"},{code:6021,name:"CpiContextEmpty",msg:"CpiContextEmpty"},{code:6022,name:"CpiContextMissing",msg:"CpiContextMissing"},{code:6023,name:"DecompressionRecipientDefined",msg:"DecompressionRecipientDefined"},{code:6024,name:"SolPoolPdaDefined",msg:"SolPoolPdaDefined"},{code:6025,name:"AppendStateFailed",msg:"AppendStateFailed"},{code:6026,name:"InstructionNotCallable",msg:"The instruction is not callable"},{code:6027,name:"CpiContextFeePayerMismatch",msg:"CpiContextFeePayerMismatch"},{code:6028,name:"CpiContextAssociatedMerkleTreeMismatch",msg:"CpiContextAssociatedMerkleTreeMismatch"},{code:6029,name:"NoInputs",msg:"NoInputs"},{code:6030,name:"InputMerkleTreeIndicesNotInOrder",msg:"Input merkle tree indices are not in ascending order."},{code:6031,name:"OutputMerkleTreeIndicesNotInOrder",msg:"Output merkle tree indices are not in ascending order."},{code:6032,name:"OutputMerkleTreeNotUnique"},{code:6033,name:"DataFieldUndefined"},{code:6034,name:"ReadOnlyAddressAlreadyExists"},{code:6035,name:"ReadOnlyAccountDoesNotExist"},{code:6036,name:"HashChainInputsLenghtInconsistent"},{code:6037,name:"InvalidAddressTreeHeight"},{code:6038,name:"InvalidStateTreeHeight"}]},exports.INSERT_INTO_QUEUES_DISCRIMINATOR=p,exports.INVOKE_CPI_DISCRIMINATOR=h,exports.INVOKE_DISCRIMINATOR=d,exports.IndexedArray=Qn,exports.IndexedElement=$n,exports.IndexedElementBundle=jn,exports.InsertAddressInputLayout=cr,exports.InsertNullifierInputLayout=lr,exports.InstructionDataInvokeCpiLayout=tr,exports.InstructionDataInvokeLayout=Yt,exports.LatestNonVotingSignaturesResult=on,exports.LatestNonVotingSignaturesResultPaginated=sn,exports.LightSystemProgram=gr,exports.LookupTableError=class extends Hn{},exports.MerkeProofResult=an,exports.MerkleContextLayout=Gt,exports.MerkleTree=zn,exports.MerkleTreeError=class extends Hn{},exports.MerkleTreeSequenceNumberLayout=dr,exports.MultipleCompressedAccountsResult=Yr,exports.MultipleMerkleProofsResult=dn,exports.NativeBalanceResult=pn,exports.NewAddressParamsLayout=Xt,exports.NewAddressProofResult=un,exports.ProofError=class extends Hn{},exports.PublicTransactionEventLayout=sr,exports.Rpc=Ln,exports.RpcError=class extends Hn{},exports.STATE_MERKLE_TREE_NETWORK_FEE=q,exports.STATE_MERKLE_TREE_ROLLOVER_FEE=U,exports.SelectInUtxosError=class extends Hn{},exports.SignatureListResult=vn,exports.SignatureListWithCursorResult=bn,exports.SlotResult=rn,exports.TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD=D,exports.TestRpc=ao,exports.TokenBalanceListResult=fn,exports.TokenBalanceListResultV2=gn,exports.TokenBalanceResult=mn,exports.TokenDataLayout=to,exports.TokenDataResult=Gr,exports.UTXO_MERGE_MAXIMUM=10,exports.UTXO_MERGE_THRESHOLD=20,exports.UtilsError=class extends Hn{},exports.UtxoError=class extends Hn{},exports.ValidityProofResult=cn,exports.accountCompressionProgram=g,exports.addressQueue=N,exports.addressTree=P,exports.airdropSol=async function({connection:e,lamports:t,recipientPublicKey:r}){const n=await e.requestAirdrop(r,t);return await nt(e,n),n},exports.bn=H,exports.bufToDecStr=e=>$(e).toString(),exports.buildAndSignTx=ht,exports.buildTx=lt,exports.byteArrayToKeypair=function(t){return e.Keypair.fromSecretKey(Uint8Array.from(t))},exports.calculateComputeUnitPrice=function(e,t){return Math.ceil(1e6*e/t)},exports.checkValidityProofShape=e=>{if(32!==e.a.length||64!==e.b.length||32!==e.c.length)throw new Error("ValidityProof has invalid shape")},exports.compress=async function(t,r,n,o,s,i){const{blockhash:a}=await t.getLatestBlockhash();if(!s){const e=await t.getCachedActiveStateTreeInfo(),{tree:r}=Nn(e);s=r}const u=await gr.compress({payer:r.publicKey,toAddress:o,lamports:n,outputStateTree:s}),l=ht([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),u],r,a,[]);return await ct(t,l,i)},exports.confirmConfig={commitment:"confirmed",preflightCommitment:"confirmed"},exports.confirmTransaction=nt,exports.confirmTx=dt,exports.convertMerkleProofsWithContextToHex=kn,exports.convertNonInclusionMerkleProofInputsToHex=Cn,exports.convertToPublicTransactionEvent=pr,exports.cpiContext2Pubkey=B,exports.cpiContextPubkey=C,exports.createAccount=async function(t,r,n,o,s,i,a,u){const{blockhash:l}=await t.getLatestBlockhash();s=null!=s?s:M().addressTree,i=null!=i?i:M().addressQueue;const c=et(n,o),d=tt(c,s);if(!a){const e=await t.getCachedActiveStateTreeInfo(),{tree:r}=Nn(e);a=r}const h=await t.getValidityProofV0(void 0,[{address:H(d.toBytes()),tree:s,queue:i}]),p={seed:c,addressMerkleTreeRootIndex:h.rootIndices[0],addressMerkleTreePubkey:h.merkleTrees[0],addressQueuePubkey:h.nullifierQueues[0]},m=await gr.createAccount({payer:r.publicKey,newAddressParams:p,newAddress:Array.from(d.toBytes()),recentValidityProof:h.compressedProof,programId:o,outputStateTree:a}),f=ht([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),m],r,l,[]);return await ct(t,f,u)},exports.createAccountWithLamports=async function(t,r,n,o,s,i,a,u,l){o=H(o);const c=await t.getCompressedAccountsByOwner(r.publicKey),[d]=yr(c.items,o);if(!u){const e=await t.getCachedActiveStateTreeInfo(),{tree:r}=Nn(e);u=r}const{blockhash:h}=await t.getLatestBlockhash();i=null!=i?i:M().addressTree,a=null!=a?a:M().addressQueue;const p=et(n,s),m=tt(p,i),f=await t.getValidityProof(d.map((e=>H(e.hash))),[H(m.toBytes())]),g={seed:p,addressMerkleTreeRootIndex:f.rootIndices[f.rootIndices.length-1],addressMerkleTreePubkey:f.merkleTrees[f.merkleTrees.length-1],addressQueuePubkey:f.nullifierQueues[f.nullifierQueues.length-1]},y=await gr.createAccount({payer:r.publicKey,newAddressParams:g,newAddress:Array.from(m.toBytes()),recentValidityProof:f.compressedProof,inputCompressedAccounts:d,inputStateRootIndices:f.rootIndices,programId:s,outputStateTree:u}),w=ht([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),y],r,h,[]);return await ct(t,w,l)},exports.createBN254=$,exports.createCompressedAccount=Q,exports.createCompressedAccountWithMerkleContext=z,exports.createMerkleContext=W,exports.createRpc=function(t,r,n,o){let s;if(t)if("string"==typeof t)s=t,r=r||s,n=n||s;else{if(!(t instanceof e.Connection))throw new Error("Invalid endpoint or connection type");s=t.rpcEndpoint,r=r||s,n=n||s}else s="http://127.0.0.1:8899",r=r||"http://127.0.0.1:8784",n=n||"http://127.0.0.1:3001";return new Ln(s,r,n,o)},exports.createRpcResult=Qr,exports.createStateTreeLookupTable=async function({connection:t,payer:r,authority:n,recentSlot:o}){const[s,i]=e.AddressLookupTableProgram.createLookupTable({payer:r.publicKey,authority:n.publicKey,recentSlot:o}),a=ht([s],r,(await t.getLatestBlockhash()).blockhash,On(r,[n]));return{address:i,txId:await ct(t,a)}},exports.decodeInstructionDataInvoke=rr,exports.decodeInstructionDataInvokeCpi=nr,exports.decodePublicTransactionEvent=ir,exports.decompress=async function(t,r,n,o,s,i){const a=(await t.getCompressedAccountsByOwner(r.publicKey)).items;n=H(n);const u=mr(a);if(n.gt(u))throw new Error(`Not enough compressed lamports. Expected ${n}, got ${u}`);const l=await t.getValidityProof(a.map((e=>H(e.hash)))),{blockhash:c}=await t.getLatestBlockhash(),d=await gr.decompress({payer:r.publicKey,toAddress:o,outputStateTree:s,inputCompressedAccounts:a,recentValidityProof:l.compressedProof,recentInputStateRootIndices:l.rootIndices,lamports:n}),h=ht([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),d],r,c,[]);return await ct(t,h,i)},exports.dedupeSigner=On,exports.deepEqual=function e(t,r){if(typeof t!=typeof r)return console.log(`Type mismatch: ${typeof t} !== ${typeof r}`),0;if(t instanceof a&&r instanceof a)return t.eq(r);if("object"==typeof t&&null!==t&&null!==r){const n=Object.keys(t),o=Object.keys(r);if(n.length!==o.length)return console.log(`Key length mismatch: ${n.length} !== ${o.length}`),0;for(const s of n){if(!o.includes(s))return console.log(`Key ${s} not found in value`),0;if(!e(t[s],r[s]))return console.log(`Value mismatch at key ${s}`),0}return 1}return t!==r&&console.log(`Value mismatch: ${t} !== ${r}`),t===r},exports.defaultStateTreeLookupTables=b,exports.defaultStaticAccounts=()=>[new e.PublicKey(y()),new e.PublicKey(m),new e.PublicKey(g),new e.PublicKey(w())],exports.defaultStaticAccountsStruct=v,exports.defaultTestStateTreeAccounts=M,exports.defaultTestStateTreeAccounts2=()=>({nullifierQueue2:new e.PublicKey(O),merkleTree2:new e.PublicKey(L)}),exports.deriveAddress=tt,exports.deriveAddressSeed=et,exports.deserializeAppendNullifyCreateAddressInputsIndexer=hr,exports.encodeBN254toBase58=j,exports.encodeInstructionDataInvoke=er,exports.encodePublicTransactionEvent=function(e){const r=t.Buffer.alloc(1e3),n=sr.encode(e,r);return r.slice(0,n)},exports.extendStateTreeLookupTable=async function({connection:t,tableAddress:r,newStateTreeAddresses:n,newQueueAddresses:o,newCpiContextAddresses:s,payer:i,authority:a}){const u=await t.getAddressLookupTable(r);if(!u.value)throw new Error("Lookup table not found");if(u.value.state.addresses.length%3!=0)throw new Error("Lookup table must have a multiple of 3 addresses");if(n.length!==o.length||n.length!==s.length)throw new Error("Same number of newStateTreeAddresses, newQueueAddresses, and newCpiContextAddresses required");const l=ht([e.AddressLookupTableProgram.extendLookupTable({payer:i.publicKey,authority:a.publicKey,lookupTable:r,addresses:n.flatMap(((e,t)=>[e,o[t],s[t]]))})],i,(await t.getLatestBlockhash()).blockhash,On(i,[a]));return{tableAddress:r,txId:await ct(t,l)}},exports.getAccountCompressionAuthority=w,exports.getCompressedTokenAccountByHashTest=io,exports.getCompressedTokenAccounts=no,exports.getCompressedTokenAccountsByDelegateTest=so,exports.getCompressedTokenAccountsByOwnerTest=oo,exports.getConnection=function(){return new e.Connection("http://127.0.0.1:8899","confirmed")},exports.getIndexOrAdd=$e,exports.getLightStateTreeInfo=pt,exports.getParsedEvents=Wn,exports.getPublicInputHash=function(e,t,r,n){const o=_n(e.map((e=>e.root)),t,n),s=r.map((e=>e.value)),i=_n(r.map((e=>e.root)),s,n);return i.isZero()?o.isZero()?_n([o],[i],n):o:i},exports.getQueueForTree=Pn,exports.getRegisteredProgramPda=y,exports.getTestKeypair=mo,exports.getTestRpc=async function(e,t="http://127.0.0.1:8899",r="http://127.0.0.1:8784",n="http://127.0.0.1:3001",o,s,i,a=0){const u=M();return new ao(t,e,r,n,void 0,{merkleTreeAddress:o||u.merkleTree,nullifierQueueAddress:s||u.nullifierQueue,depth:i||u.merkleTreeHeight,log:a})},exports.getTreeForQueue=function(e,t){const r=e.findIndex((e=>{var r;return null===(r=e.queue)||void 0===r?void 0:r.equals(t)}));if(-1===r)throw new Error("No associated tree found for queue. Please set activeStateTreeInfo with latest Tree accounts. If you use custom state trees, set manually.");if(!e[r].tree)throw new Error("Tree must not be null for state tree");return e[r].tree},exports.hashToBn254FieldSizeBe=Ve,exports.hashvToBn254FieldSizeBe=He,exports.invokeAccountsLayout=or,exports.isLocalTest=x,exports.isSmallerThanBn254FieldSizeBe=qe,exports.jsonRpcResult=Wr,exports.jsonRpcResultAndContext=Jr,exports.lightProgram=f,exports.localTestActiveStateTreeInfo=E,exports.merkleTree2Pubkey=L,exports.merkletreePubkey=_,exports.negateAndCompressProof=st,exports.newAccountWithLamports=async function(e,t=1e9,r){(void 0===r||r>255)&&(r=256);const n=mo(r),o=await e.requestAirdrop(n.publicKey,t);return await dt(e,o),n},exports.noopProgram=m,exports.nullifiedStateTreeLookupTableDevnet=S,exports.nullifiedStateTreeLookupTableMainnet=I,exports.nullifierQueue2Pubkey=O,exports.nullifierQueuePubkey=k,exports.nullifyLookupTable=async function({connection:t,fullStateTreeAddress:r,nullifyTableAddress:n,stateTreeLookupTableAddress:o,payer:s,authority:i}){const a=await t.getAddressLookupTable(o);if(!a.value)throw new Error("State tree lookup table not found");if(!a.value.state.addresses.includes(r))throw new Error("State tree address not found in lookup table. Pass correct address or stateTreeLookupTable");const u=await t.getAddressLookupTable(n);if(!u.value)throw new Error("Nullify table not found");if(u.value.state.addresses.includes(r))throw new Error("Address already exists in nullify lookup table");const l=ht([e.AddressLookupTableProgram.extendLookupTable({payer:s.publicKey,authority:i.publicKey,lookupTable:n,addresses:[r]})],s,(await t.getLatestBlockhash()).blockhash);return{txId:await ct(t,l)}},exports.packCompressedAccounts=ze,exports.packNewAddressParams=rt,exports.padOutputStateMerkleTrees=je,exports.parseAccountData=En,exports.parseEvents=Jn,exports.parseLightTransaction=Gn,exports.parsePublicTransactionEventWithIdl=Zn,exports.parseTokenLayoutWithIdl=ro,exports.pickRandomTreeAndQueue=Nn,exports.pipe=function(e,...t){return r=>t.reduce(((e,t)=>t(e)),e(r))},exports.placeholderValidityProof=()=>({a:Array.from({length:32},((e,t)=>t+1)),b:Array.from({length:64},((e,t)=>t+1)),c:Array.from({length:32},((e,t)=>t+1))}),exports.proofFromJsonStruct=ot,exports.proverRequest=Sn,exports.pushUniqueItems=function(e,t){e.forEach((e=>{t.includes(e)||t.push(e)}))},exports.rpcRequest=Tn,exports.selectMinCompressedSolAccountsForTransfer=yr,exports.sendAndConfirmTx=ct,exports.sleep=function(e){return new Promise((t=>setTimeout(t,e)))},exports.stateTreeLookupTableDevnet=T,exports.stateTreeLookupTableMainnet=A,exports.sumUpLamports=mr,exports.toAccountMetas=Qe,exports.toArray=Fe,exports.toCamelCase=Ke,exports.toHex=Ue,exports.toUnixTimestamp=e=>new Date(e).getTime(),exports.transfer=async function(t,r,n,o,s,i,u){var l;let c=H(0);const d=[];let h;for(n=H(n);c.lt(n);){const e={filters:void 0,dataSlice:void 0,cursor:h,limit:new a(1e3)},r=await t.getCompressedAccountsByOwner(o.publicKey,e);for(const e of r.items)e.lamports.gt(new a(0))&&(d.push(e),c=c.add(e.lamports));if(h=null!==(l=r.cursor)&&void 0!==l?l:void 0,r.items.length<1e3||c.gte(n))break}if(c.lt(n))throw new Error(`Insufficient balance for transfer. Required: ${n.toString()}, available: ${c.toString()}`);const[p]=yr(d,n),m=await t.getValidityProof(p.map((e=>H(e.hash)))),f=await gr.transfer({payer:r.publicKey,inputCompressedAccounts:p,toAddress:s,lamports:n,recentInputStateRootIndices:m.rootIndices,recentValidityProof:m.compressedProof,outputStateTrees:i}),{blockhash:g}=await t.getLatestBlockhash(),y=ht([e.ComputeBudgetProgram.setComputeUnitLimit({units:1e6}),f],r,g);return await ct(t,y,u)},exports.validateNumbers=Ye,exports.validateNumbersForInclusionProof=Ge,exports.validateNumbersForNonInclusionProof=Xe,exports.validateNumbersForProof=Ze,exports.validateSameOwner=Je,exports.validateSufficientBalance=We,exports.wrapBigNumbersAsStrings=In;
//# sourceMappingURL=index.cjs.map
