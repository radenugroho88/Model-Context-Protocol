{"version":3,"file":"index.cjs","sources":["../../../../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js","../../../../../src/state/types.ts","../../../../../src/constants.ts","../../../../../node_modules/.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js","../../../../../node_modules/.pnpm/base-x@5.0.0/node_modules/base-x/src/esm/index.js","../../../../../src/state/BN254.ts","../../../../../src/state/compressed-account.ts","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js","../../../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha3.js","../../../../../node_modules/.pnpm/map-obj@5.0.0/node_modules/map-obj/index.js","../../../../../node_modules/.pnpm/camelcase@8.0.0/node_modules/camelcase/index.js","../../../../../node_modules/.pnpm/quick-lru@6.1.2/node_modules/quick-lru/index.js","../../../../../node_modules/.pnpm/camelcase-keys@9.1.3/node_modules/camelcase-keys/index.js","../../../../../src/utils/conversion.ts","../../../../../src/instruction/pack-compressed-accounts.ts","../../../../../src/utils/validation.ts","../../../../../src/utils/address.ts","../../../../../src/utils/airdrop.ts","../../../../../src/utils/parse-validity-proof.ts","../../../../../src/utils/send-and-confirm.ts","../../../../../src/utils/get-light-state-tree-info.ts","../../../../../node_modules/.pnpm/buffer-layout@1.2.2/node_modules/buffer-layout/lib/Layout.js","../../../../../node_modules/.pnpm/@coral-xyz+borsh@0.29.0_@solana+web3.js@1.98.0/node_modules/@coral-xyz/borsh/dist/index.js","../../../../../src/programs/layout.ts","../../../../../src/programs/system.ts","../../../../../node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs","../../../../../src/rpc-interface.ts","../../../../../src/rpc.ts","../../../../../src/actions/common.ts","../../../../../src/errors.ts","../../../../../src/test-helpers/merkle-tree/indexed-array.ts","../../../../../src/test-helpers/merkle-tree/merkle-tree.ts","../../../../../src/test-helpers/test-rpc/get-parsed-events.ts","../../../../../src/test-helpers/test-rpc/get-compressed-accounts.ts","../../../../../src/test-helpers/test-rpc/get-compressed-token-accounts.ts","../../../../../src/test-helpers/test-rpc/test-rpc.ts","../../../../../src/test-helpers/test-utils.ts","../../../../../src/idl.ts","../../../../../src/utils/calculate-compute-unit-price.ts","../../../../../src/actions/compress.ts","../../../../../src/actions/create-account.ts","../../../../../src/actions/decompress.ts","../../../../../src/utils/pipe.ts","../../../../../src/utils/sleep.ts","../../../../../src/actions/transfer.ts"],"sourcesContent":["(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = require('buffer').Buffer;\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n","import BN from 'bn.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { NewAddressParamsPacked } from '../utils';\n\nexport enum TreeType {\n    /**\n     * v1 state merkle tree\n     */\n    State = 0,\n    /**\n     * v1 address merkle tree\n     */\n    Address = 1,\n    /**\n     * v2 state merkle tree\n     */\n    BatchedState = 2,\n    /**\n     * v2 address merkle tree\n     */\n    BatchedAddress = 3,\n}\n\nexport type ActiveTreeBundle = {\n    tree: PublicKey;\n    queue: PublicKey | null;\n    cpiContext: PublicKey | null;\n    treeType: TreeType;\n};\n\nexport interface PackedCompressedAccountWithMerkleContext {\n    compressedAccount: CompressedAccount;\n    merkleContext: PackedMerkleContext;\n    rootIndex: number; // u16\n    readOnly: boolean;\n}\n\nexport interface PackedMerkleContext {\n    merkleTreePubkeyIndex: number; // u8\n    nullifierQueuePubkeyIndex: number; // u8\n    leafIndex: number; // u32\n    queueIndex: null | QueueIndex; // Option<QueueIndex>\n}\n\nexport interface QueueIndex {\n    queueId: number; // u8\n    index: number; // u16\n}\n\n/**\n * Describe the generic compressed account details applicable to every\n * compressed account.\n * */\nexport interface CompressedAccount {\n    /** Public key of program or user that owns the account */\n    owner: PublicKey;\n    /** Lamports attached to the account */\n    lamports: BN; // u64 // FIXME: optional\n    /**\n     * TODO: use PublicKey. Optional unique account ID that is persistent across\n     * transactions.\n     */\n    address: number[] | null; // Option<PublicKey>\n    /** Optional data attached to the account */\n    data: CompressedAccountData | null; // Option<CompressedAccountData>\n}\n\n/**\n * Describe the generic compressed account details applicable to every\n * compressed account.\n * */\nexport interface OutputCompressedAccountWithPackedContext {\n    compressedAccount: CompressedAccount;\n    merkleTreeIndex: number;\n}\n\nexport interface CompressedAccountData {\n    discriminator: number[]; // [u8; 8] // TODO: test with uint8Array instead\n    data: Buffer; // bytes\n    dataHash: number[]; // [u8; 32]\n}\nexport interface MerkleTreeSequenceNumber {\n    pubkey: PublicKey;\n    seq: BN;\n}\n\nexport interface PublicTransactionEvent {\n    inputCompressedAccountHashes: number[][]; // Vec<[u8; 32]>\n    outputCompressedAccountHashes: number[][]; // Vec<[u8; 32]>\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    outputLeafIndices: number[]; // Vec<u32>\n    sequenceNumbers: MerkleTreeSequenceNumber[]; // Vec<MerkleTreeSequenceNumber>\n    relayFee: BN | null; // Option<u64>\n    isCompress: boolean; // bool\n    compressOrDecompressLamports: BN | null; // Option<u64>\n    pubkeyArray: PublicKey[]; // Vec<PublicKey>\n    message: Uint8Array | null; // Option<bytes>\n}\n\nexport interface InstructionDataInvoke {\n    proof: CompressedProof | null; // Option<CompressedProof>\n    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    relayFee: BN | null; // Option<u64>\n    newAddressParams: NewAddressParamsPacked[]; // Vec<NewAddressParamsPacked>\n    compressOrDecompressLamports: BN | null; // Option<u64>\n    isCompress: boolean; // bool\n}\n\nexport interface InstructionDataInvokeCpi {\n    proof: CompressedProof | null; // Option<CompressedProof>\n    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];\n    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    relayFee: BN | null; // Option<u64>\n    newAddressParams: NewAddressParamsPacked[]; // Vec<NewAddressParamsPacked>\n    compressOrDecompressLamports: BN | null; // Option<u64>\n    isCompress: boolean; // bool\n    compressedCpiContext: CompressedCpiContext | null;\n}\n\nexport interface CompressedCpiContext {\n    /// Is set by the program that is invoking the CPI to signal that is should\n    /// set the cpi context.\n    set_context: boolean;\n    /// Is set to wipe the cpi context since someone could have set it before\n    /// with unrelated data.\n    first_set_context: boolean;\n    /// Index of cpi context account in remaining accounts.\n    cpi_context_account_index: number;\n}\n\nexport interface CompressedProof {\n    a: number[]; // [u8; 32]\n    b: number[]; // [u8; 64]\n    c: number[]; // [u8; 32]\n}\n\nexport interface InputTokenDataWithContext {\n    amount: BN;\n    delegateIndex: number | null; // Option<u8>\n    merkleContext: PackedMerkleContext;\n    rootIndex: number; // u16\n    lamports: BN | null;\n    tlv: Buffer | null;\n}\nexport type TokenData = {\n    /// The mint associated with this account\n    mint: PublicKey;\n    /// The owner of this account.\n    owner: PublicKey;\n    /// The amount of tokens this account holds.\n    amount: BN;\n    /// If `delegate` is `Some` then `delegated_amount` represents\n    /// the amount authorized by the delegate\n    delegate: PublicKey | null;\n    /// The account's state\n    state: number; // AccountState_IdlType;\n    /// TokenExtension tlv\n    tlv: Buffer | null;\n};\n","import BN from 'bn.js';\nimport { Buffer } from 'buffer';\nimport { ConfirmOptions, PublicKey } from '@solana/web3.js';\nimport { ActiveTreeBundle, TreeType } from './state/types';\n\nexport const FIELD_SIZE = new BN(\n    '21888242871839275222246405745257275088548364400416034343698204186575808495617',\n);\nexport const HIGHEST_ADDRESS_PLUS_ONE = new BN(\n    '452312848583266388373324160190187140051835877600158453279131187530910662655',\n);\n\nexport const COMPUTE_BUDGET_PATTERN = [2, 64, 66, 15, 0];\n\nexport const INVOKE_DISCRIMINATOR = Buffer.from([\n    26, 16, 169, 7, 21, 202, 242, 25,\n]);\n\nexport const INVOKE_CPI_DISCRIMINATOR = Buffer.from([\n    49, 212, 191, 129, 39, 194, 43, 196,\n]);\n\nexport const INSERT_INTO_QUEUES_DISCRIMINATOR = Buffer.from([\n    180, 143, 159, 153, 35, 46, 248, 163,\n]);\n\n// TODO: implement properly\nexport const noopProgram = 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';\nexport const lightProgram = 'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7';\nexport const accountCompressionProgram = // also: merkletree program\n    'compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq';\n\nexport const getRegisteredProgramPda = () =>\n    new PublicKey('35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh'); // TODO: better labelling. gov authority pda\n\nexport const getAccountCompressionAuthority = () =>\n    PublicKey.findProgramAddressSync(\n        [Buffer.from('cpi_authority')],\n        new PublicKey(\n            // TODO: can add check to ensure its consistent with the idl\n            lightProgram,\n        ),\n    )[0];\n\nexport const defaultStaticAccounts = () => [\n    new PublicKey(getRegisteredProgramPda()),\n    new PublicKey(noopProgram),\n    new PublicKey(accountCompressionProgram),\n    new PublicKey(getAccountCompressionAuthority()),\n];\nexport const defaultStaticAccountsStruct = () => {\n    return {\n        registeredProgramPda: new PublicKey(getRegisteredProgramPda()),\n        noopProgram: new PublicKey(noopProgram),\n        accountCompressionProgram: new PublicKey(accountCompressionProgram),\n        accountCompressionAuthority: new PublicKey(\n            getAccountCompressionAuthority(),\n        ),\n        cpiSignatureAccount: null,\n    };\n};\n\nexport type StateTreeLUTPair = {\n    stateTreeLookupTable: PublicKey;\n    nullifyTable: PublicKey;\n};\n\n/**\n * Returns the Default Public State Tree LUTs for Devnet and Mainnet-Beta.\n */\nexport const defaultStateTreeLookupTables = (): {\n    mainnet: StateTreeLUTPair[];\n    devnet: StateTreeLUTPair[];\n} => {\n    return {\n        mainnet: [\n            {\n                stateTreeLookupTable: new PublicKey(\n                    stateTreeLookupTableMainnet,\n                ),\n                nullifyTable: new PublicKey(\n                    nullifiedStateTreeLookupTableMainnet,\n                ),\n            },\n        ],\n        devnet: [\n            {\n                stateTreeLookupTable: new PublicKey(stateTreeLookupTableDevnet),\n                nullifyTable: new PublicKey(\n                    nullifiedStateTreeLookupTableDevnet,\n                ),\n            },\n        ],\n    };\n};\n\n/**\n * @internal\n */\nexport const isLocalTest = (url: string) => {\n    return url.includes('localhost') || url.includes('127.0.0.1');\n};\n\n/**\n * @internal\n */\nexport const localTestActiveStateTreeInfo = (): ActiveTreeBundle[] => {\n    return [\n        {\n            tree: new PublicKey(merkletreePubkey),\n            queue: new PublicKey(nullifierQueuePubkey),\n            cpiContext: new PublicKey(cpiContextPubkey),\n            treeType: TreeType.State,\n        },\n        {\n            tree: new PublicKey(merkleTree2Pubkey),\n            queue: new PublicKey(nullifierQueue2Pubkey),\n            cpiContext: new PublicKey(cpiContext2Pubkey),\n            treeType: TreeType.State,\n        },\n    ];\n};\n\n/**\n * Use only with Localnet testing.\n * For public networks, fetch via {@link defaultStateTreeLookupTables} and {@link getLightStateTreeInfo}.\n */\nexport const defaultTestStateTreeAccounts = () => {\n    return {\n        nullifierQueue: new PublicKey(nullifierQueuePubkey),\n        merkleTree: new PublicKey(merkletreePubkey),\n        merkleTreeHeight: DEFAULT_MERKLE_TREE_HEIGHT,\n        addressTree: new PublicKey(addressTree),\n        addressQueue: new PublicKey(addressQueue),\n    };\n};\n\n/**\n * @internal testing only\n */\nexport const defaultTestStateTreeAccounts2 = () => {\n    return {\n        nullifierQueue2: new PublicKey(nullifierQueue2Pubkey),\n        merkleTree2: new PublicKey(merkleTree2Pubkey),\n    };\n};\n\nexport const stateTreeLookupTableMainnet =\n    '7i86eQs3GSqHjN47WdWLTCGMW6gde1q96G2EVnUyK2st';\nexport const nullifiedStateTreeLookupTableMainnet =\n    'H9QD4u1fG7KmkAzn2tDXhheushxFe1EcrjGGyEFXeMqT';\n\nexport const stateTreeLookupTableDevnet =\n    '8n8rH2bFRVA6cSGNDpgqcKHCndbFCT1bXxAQG89ejVsh';\nexport const nullifiedStateTreeLookupTableDevnet =\n    '5dhaJLBjnVBQFErr8oiCJmcVsx3Zj6xDekGB2zULPsnP';\n\nexport const nullifierQueuePubkey =\n    'nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148';\nexport const cpiContextPubkey = 'cpi1uHzrEhBG733DoEJNgHCyRS3XmmyVNZx5fonubE4';\n\nexport const merkletreePubkey = 'smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT';\nexport const addressTree = 'amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2';\nexport const addressQueue = 'aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F';\n\nexport const merkleTree2Pubkey = 'smt2rJAFdyJJupwMKAqTNAJwvjhmiZ4JYGZmbVRw1Ho';\nexport const nullifierQueue2Pubkey =\n    'nfq2hgS7NYemXsFaFUCe3EMXSDSfnZnAe27jC6aPP1X';\nexport const cpiContext2Pubkey = 'cpi2cdhkH5roePvcudTgUL8ppEBfTay1desGh8G8QxK';\n\nexport const confirmConfig: ConfirmOptions = {\n    commitment: 'confirmed',\n    preflightCommitment: 'confirmed',\n};\n\nexport const DEFAULT_MERKLE_TREE_HEIGHT = 26;\nexport const DEFAULT_MERKLE_TREE_ROOTS = 2800;\n/** Threshold (per asset) at which new in-UTXOs get merged, in order to reduce UTXO pool size */\nexport const UTXO_MERGE_THRESHOLD = 20;\nexport const UTXO_MERGE_MAXIMUM = 10;\n\n/**\n * Treshold after which the currently used transaction Merkle tree is switched\n * to the next one\n */\nexport const TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD = new BN(\n    Math.floor(2 ** DEFAULT_MERKLE_TREE_HEIGHT * 0.95),\n);\n\n/**\n * Fee to provide continous funding for the state Merkle tree.\n * Once the state Merkle tree is at 95% capacity the accumulated fees\n * will be used to fund the next state Merkle tree with the same parameters.\n *\n * Is charged per output compressed account.\n */\nexport const STATE_MERKLE_TREE_ROLLOVER_FEE = new BN(300);\n\n/**\n * Fee to provide continous funding for the address queue and address Merkle tree.\n * Once the address Merkle tree is at 95% capacity the accumulated fees\n * will be used to fund the next address queue and address tree with the same parameters.\n *\n * Is charged per newly created address.\n */\nexport const ADDRESS_QUEUE_ROLLOVER_FEE = new BN(392);\n\n/**\n * Is charged if the transaction nullifies at least one compressed account.\n */\nexport const STATE_MERKLE_TREE_NETWORK_FEE = new BN(5000);\n\n/**\n * Is charged if the transaction creates at least one address.\n */\nexport const ADDRESS_TREE_NETWORK_FEE = new BN(5000);\n","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","// TODO: consider implementing BN254 as wrapper class around _BN mirroring\n// PublicKey this would encapsulate our runtime checks and also enforce\n// typesafety at compile time\n\nimport { FIELD_SIZE } from '../constants';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport { Buffer } from 'buffer';\n\n/**\n * bignumber with <254-bit max size. Anchor serialization doesn't support native\n * bigint yet, so we wrap BN. This wrapper has simple base10 encoding which is\n * needed for zk circuit compat, in addition to the base58 encoding that users\n * are used to from working with the web3.js PublicKey type.\n */\nexport type BN254 = BN;\n\nexport const bn = (\n    number: string | number | BN | Buffer | Uint8Array | number[],\n    base?: number | 'hex' | undefined,\n    endian?: BN.Endianness | undefined,\n): BN => new BN(number, base, endian);\n\n/** Create a bigint instance with <254-bit max size and base58 capabilities */\nexport const createBN254 = (\n    number: string | number | BN | Buffer | Uint8Array | number[],\n    base?: number | 'hex' | 'base58' | undefined,\n): BN254 => {\n    if (base === 'base58') {\n        if (typeof number !== 'string')\n            throw new Error('Must be a base58 string');\n        return createBN254(bs58.decode(number));\n    }\n\n    const bigintNumber = new BN(number, base);\n\n    return enforceSize(bigintNumber);\n};\n\n/**\n * Enforces a maximum size of <254 bits for bigint instances. This is necessary\n * for compatibility with zk-SNARKs, where hashes must be less than the field\n * modulus (~2^254).\n */\nfunction enforceSize(bigintNumber: BN254): BN254 {\n    if (bigintNumber.gte(FIELD_SIZE)) {\n        throw new Error('Value is too large. Max <254 bits');\n    }\n    return bigintNumber;\n}\n\n/** Convert <254-bit bigint to Base58 string.  */\nexport function encodeBN254toBase58(bigintNumber: BN): string {\n    /// enforce size\n    const bn254 = createBN254(bigintNumber);\n    const bn254Buffer = bn254.toArrayLike(Buffer, undefined, 32);\n\n    return bs58.encode(bn254Buffer);\n}\n","import BN from 'bn.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { CompressedAccount, CompressedAccountData } from './types';\nimport { BN254, bn } from './BN254';\n\nexport type CompressedAccountWithMerkleContext = CompressedAccount &\n    MerkleContext & {\n        readOnly: boolean;\n    };\n\n/**\n * Context for compressed account inserted into a state Merkle tree\n * */\nexport type MerkleContext = {\n    /** State Merkle tree */\n    merkleTree: PublicKey;\n    /** The state nullfier queue belonging to merkleTree */\n    nullifierQueue: PublicKey;\n    /** Poseidon hash of the utxo preimage. Is a leaf in state merkle tree  */\n    hash: number[]; // TODO: BN254;\n    /** 'hash' position within the Merkle tree */\n    leafIndex: number;\n};\n\nexport type MerkleContextWithMerkleProof = MerkleContext & {\n    /** Recent valid 'hash' proof path, expires after n slots */\n    merkleProof: BN254[];\n    /** Index of state root the merkleproof is valid for, expires after n slots */\n    rootIndex: number;\n    /** Current root */\n    root: BN254;\n};\n\nexport const createCompressedAccount = (\n    owner: PublicKey,\n    lamports?: BN,\n    data?: CompressedAccountData,\n    address?: number[],\n): CompressedAccount => ({\n    owner,\n    lamports: lamports ?? bn(0),\n    address: address ?? null,\n    data: data ?? null,\n});\n\nexport const createCompressedAccountWithMerkleContext = (\n    merkleContext: MerkleContext,\n    owner: PublicKey,\n    lamports?: BN,\n    data?: CompressedAccountData,\n    address?: number[],\n): CompressedAccountWithMerkleContext => ({\n    ...createCompressedAccount(owner, lamports, data, address),\n    ...merkleContext,\n    readOnly: false,\n});\n\nexport const createMerkleContext = (\n    merkleTree: PublicKey,\n    nullifierQueue: PublicKey,\n    hash: number[], // TODO: BN254,\n    leafIndex: number,\n): MerkleContext => ({\n    merkleTree,\n    nullifierQueue,\n    hash,\n    leafIndex,\n});\n","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","const isObject = value => typeof value === 'object' && value !== null;\n\n// Customized for this use-case\nconst isObjectCustom = value =>\n\tisObject(value)\n\t&& !(value instanceof RegExp)\n\t&& !(value instanceof Error)\n\t&& !(value instanceof Date);\n\nexport const mapObjectSkip = Symbol('mapObjectSkip');\n\nconst _mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options,\n\t};\n\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\n\tisSeen.set(object, options.target);\n\n\tconst {target} = options;\n\tdelete options.target;\n\n\tconst mapArray = array => array.map(element => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\n\t\tif (mapResult === mapObjectSkip) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\n\t\t// Drop `__proto__` keys.\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue)\n\t\t\t\t? mapArray(newValue)\n\t\t\t\t: _mapObject(newValue, mapper, options, isSeen);\n\t\t}\n\n\t\ttarget[newKey] = newValue;\n\t}\n\n\treturn target;\n};\n\nexport default function mapObject(object, mapper, options) {\n\tif (!isObject(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\n\treturn _mapObject(object, mapper, options);\n}\n","const UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu;\nconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst SEPARATORS = /[_.\\- ]+/;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\tLEADING_CAPITAL.lastIndex = 0;\n\n\treturn input.replaceAll(LEADING_CAPITAL, match => toLowerCase(match));\n};\n\nconst postProcess = (input, toUpperCase) => {\n\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ['_', '-'].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match))\n\t\t.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));\n};\n\nexport default function camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);\n\t}\n\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\tinput = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);\n\n\tif (options.pascalCase) {\n\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t}\n\n\treturn postProcess(input, toUpperCase);\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","import mapObject from 'map-obj';\nimport camelCase from 'camelcase';\nimport QuickLru from 'quick-lru';\n\nconst has = (array, key) => array.some(element => {\n\tif (typeof element === 'string') {\n\t\treturn element === key;\n\t}\n\n\telement.lastIndex = 0;\n\n\treturn element.test(key);\n});\n\nconst cache = new QuickLru({maxSize: 100_000});\n\n// Reproduces behavior from `map-obj`.\nconst isObject = value =>\n\ttypeof value === 'object'\n\t\t&& value !== null\n\t\t&& !(value instanceof RegExp)\n\t\t&& !(value instanceof Error)\n\t\t&& !(value instanceof Date);\n\nconst transform = (input, options = {}) => {\n\tif (!isObject(input)) {\n\t\treturn input;\n\t}\n\n\tconst {\n\t\texclude,\n\t\tpascalCase = false,\n\t\tstopPaths,\n\t\tdeep = false,\n\t\tpreserveConsecutiveUppercase = false,\n\t} = options;\n\n\tconst stopPathsSet = new Set(stopPaths);\n\n\tconst makeMapper = parentPath => (key, value) => {\n\t\tif (deep && isObject(value)) {\n\t\t\tconst path = parentPath === undefined ? key : `${parentPath}.${key}`;\n\n\t\t\tif (!stopPathsSet.has(path)) {\n\t\t\t\tvalue = mapObject(value, makeMapper(path));\n\t\t\t}\n\t\t}\n\n\t\tif (!(exclude && has(exclude, key))) {\n\t\t\tconst cacheKey = pascalCase ? `${key}_` : key;\n\n\t\t\tif (cache.has(cacheKey)) {\n\t\t\t\tkey = cache.get(cacheKey);\n\t\t\t} else {\n\t\t\t\tconst returnValue = camelCase(key, {pascalCase, locale: false, preserveConsecutiveUppercase});\n\n\t\t\t\tif (key.length < 100) { // Prevent abuse\n\t\t\t\t\tcache.set(cacheKey, returnValue);\n\t\t\t\t}\n\n\t\t\t\tkey = returnValue;\n\t\t\t}\n\t\t}\n\n\t\treturn [key, value];\n\t};\n\n\treturn mapObject(input, makeMapper(undefined));\n};\n\nexport default function camelcaseKeys(input, options) {\n\tif (Array.isArray(input)) {\n\t\treturn Object.keys(input).map(key => transform(input[key], options));\n\t}\n\n\treturn transform(input, options);\n}\n","import { Buffer } from 'buffer';\nimport { bn, createBN254 } from '../state/BN254';\nimport { FIELD_SIZE } from '../constants';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport { Keypair } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport camelcaseKeys from 'camelcase-keys';\n\nexport function byteArrayToKeypair(byteArray: number[]): Keypair {\n    return Keypair.fromSecretKey(Uint8Array.from(byteArray));\n}\n/**\n * @internal\n * convert BN to hex with '0x' prefix\n */\nexport function toHex(bn: BN): string {\n    return '0x' + bn.toString('hex');\n}\n\nexport const toArray = <T>(value: T | T[]) =>\n    Array.isArray(value) ? value : [value];\n\nexport const bufToDecStr = (buf: Buffer): string => {\n    return createBN254(buf).toString();\n};\nexport function isSmallerThanBn254FieldSizeBe(bytes: Buffer): boolean {\n    const bigint = bn(bytes, undefined, 'be');\n    return bigint.lt(FIELD_SIZE);\n}\n\nexport const toCamelCase = (object: any) =>\n    camelcaseKeys(object, { deep: true });\n\n/**\n/**\n * Hash the provided `bytes` with Keccak256 and ensure the result fits in the\n * BN254 prime field by repeatedly hashing the inputs with various \"bump seeds\"\n * and truncating the resulting hash to 31 bytes.\n *\n * @deprecated Use `hashvToBn254FieldSizeBe` instead.\n */\nexport function hashToBn254FieldSizeBe(bytes: Buffer): [Buffer, number] | null {\n    // TODO(vadorovsky, affects-onchain): Get rid of the bump mechanism, it\n    // makes no sense. Doing the same as in the `hashvToBn254FieldSizeBe` below\n    // - overwriting the most significant byte with zero - is sufficient for\n    // truncation, it's also faster, doesn't force us to return `Option` and\n    // care about handling an error which is practically never returned.\n    //\n    // The reason we can't do it now is that it would affect on-chain programs.\n    // Once we can update programs, we can get rid of the seed bump (or even of\n    // this function all together in favor of the `hashv` variant).\n    let bumpSeed = 255;\n    while (bumpSeed >= 0) {\n        const inputWithBumpSeed = Buffer.concat([\n            bytes,\n            Buffer.from([bumpSeed]),\n        ]);\n        const hash = keccak_256(inputWithBumpSeed);\n        if (hash.length !== 32) {\n            throw new Error('Invalid hash length');\n        }\n        hash[0] = 0;\n\n        if (isSmallerThanBn254FieldSizeBe(Buffer.from(hash))) {\n            return [Buffer.from(hash), bumpSeed];\n        }\n\n        bumpSeed -= 1;\n    }\n    return null;\n}\n\n/**\n * Hash the provided `bytes` with Keccak256 and ensure that the result fits in\n * the BN254 prime field by truncating the resulting hash to 31 bytes.\n *\n * @param bytes Input bytes\n *\n * @returns     Hash digest\n */\nexport function hashvToBn254FieldSizeBe(bytes: Uint8Array[]): Uint8Array {\n    const hasher = keccak_256.create();\n    for (const input of bytes) {\n        hasher.update(input);\n    }\n    const hash = hasher.digest();\n    hash[0] = 0;\n    return hash;\n}\n\n/** Mutates array in place */\nexport function pushUniqueItems<T>(items: T[], map: T[]): void {\n    items.forEach(item => {\n        if (!map.includes(item)) {\n            map.push(item);\n        }\n    });\n}\n","import { AccountMeta, PublicKey } from '@solana/web3.js';\nimport {\n    CompressedAccount,\n    OutputCompressedAccountWithPackedContext,\n    PackedCompressedAccountWithMerkleContext,\n} from '../state';\nimport { CompressedAccountWithMerkleContext } from '../state/compressed-account';\nimport { toArray } from '../utils/conversion';\n\n/**\n * @internal Finds the index of a PublicKey in an array, or adds it if not\n * present\n * */\nexport function getIndexOrAdd(\n    accountsArray: PublicKey[],\n    key: PublicKey,\n): number {\n    const index = accountsArray.findIndex(existingKey =>\n        existingKey.equals(key),\n    );\n    if (index === -1) {\n        accountsArray.push(key);\n        return accountsArray.length - 1;\n    }\n    return index;\n}\n\n/**\n * @internal\n * Pads output state trees with the 0th state tree of the input state.\n *\n * @param outputStateMerkleTrees            Optional output state trees to be\n *                                          inserted into the output state.\n *                                          Defaults to the 0th state tree of\n *                                          the input state. Gets padded to the\n *                                          length of outputCompressedAccounts.\n * @param numberOfOutputCompressedAccounts  The number of output compressed\n *                                          accounts.\n * @param inputCompressedAccountsWithMerkleContext The input compressed accounts\n *                                          with merkle context.\n *\n * @returns Padded output state trees.\n */\nexport function padOutputStateMerkleTrees(\n    outputStateMerkleTrees: PublicKey[] | PublicKey | undefined,\n    numberOfOutputCompressedAccounts: number,\n    inputCompressedAccountsWithMerkleContext: CompressedAccountWithMerkleContext[],\n): PublicKey[] {\n    if (numberOfOutputCompressedAccounts <= 0) {\n        return [];\n    }\n\n    /// Default: use the 0th state tree of input state for all output accounts\n    if (outputStateMerkleTrees === undefined) {\n        if (inputCompressedAccountsWithMerkleContext.length === 0) {\n            throw new Error(\n                'No input compressed accounts nor output state trees provided. Please pass in at least one of the following: outputStateMerkleTree or inputCompressedAccount',\n            );\n        }\n        return new Array(numberOfOutputCompressedAccounts).fill(\n            inputCompressedAccountsWithMerkleContext[0].merkleTree,\n        );\n        /// Align the number of output state trees with the number of output\n        /// accounts, and fill up with 0th output state tree\n    } else {\n        /// Into array\n        const treesArray = toArray(outputStateMerkleTrees);\n        if (treesArray.length >= numberOfOutputCompressedAccounts) {\n            return treesArray.slice(0, numberOfOutputCompressedAccounts);\n        } else {\n            return treesArray.concat(\n                new Array(\n                    numberOfOutputCompressedAccounts - treesArray.length,\n                ).fill(treesArray[0]),\n            );\n        }\n    }\n}\n\nexport function toAccountMetas(remainingAccounts: PublicKey[]): AccountMeta[] {\n    return remainingAccounts.map(\n        (account): AccountMeta => ({\n            pubkey: account,\n            isWritable: true,\n            isSigner: false,\n        }),\n    );\n}\n\n/**\n * Packs Compressed Accounts.\n *\n * Replaces PublicKey with index pointer to remaining accounts.\n *\n *\n * @param inputCompressedAccounts           Ix input state to be consumed\n * @param inputStateRootIndices             The recent state root indices of the\n *                                          input state. The expiry is tied to\n *                                          the proof.\n * @param outputCompressedAccounts          Ix output state to be created\n * @param outputStateMerkleTrees            Optional output state trees to be\n *                                          inserted into the output state.\n *                                          Defaults to the 0th state tree of\n *                                          the input state. Gets padded to the\n *                                          length of outputCompressedAccounts.\n *\n * @param remainingAccounts                 Optional existing array of accounts\n *                                          to append to.\n **/\nexport function packCompressedAccounts(\n    inputCompressedAccounts: CompressedAccountWithMerkleContext[],\n    inputStateRootIndices: number[],\n    outputCompressedAccounts: CompressedAccount[],\n    outputStateMerkleTrees?: PublicKey[] | PublicKey,\n    remainingAccounts: PublicKey[] = [],\n): {\n    packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[];\n    packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[];\n    remainingAccounts: PublicKey[];\n} {\n    const _remainingAccounts = remainingAccounts.slice();\n\n    const packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[] =\n        [];\n\n    const packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[] =\n        [];\n\n    /// input\n    inputCompressedAccounts.forEach((account, index) => {\n        const merkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.merkleTree,\n        );\n\n        const nullifierQueuePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            account.nullifierQueue,\n        );\n\n        packedInputCompressedAccounts.push({\n            compressedAccount: {\n                owner: account.owner,\n                lamports: account.lamports,\n                address: account.address,\n                data: account.data,\n            },\n            merkleContext: {\n                merkleTreePubkeyIndex,\n                nullifierQueuePubkeyIndex,\n                leafIndex: account.leafIndex,\n                queueIndex: null,\n            },\n            rootIndex: inputStateRootIndices[index],\n            readOnly: false,\n        });\n    });\n\n    if (\n        outputStateMerkleTrees === undefined &&\n        inputCompressedAccounts.length === 0\n    ) {\n        throw new Error(\n            'No input compressed accounts nor output state trees provided. Please pass in at least one of the following: outputStateMerkleTree or inputCompressedAccount',\n        );\n    }\n    /// output\n    const paddedOutputStateMerkleTrees = padOutputStateMerkleTrees(\n        outputStateMerkleTrees,\n        outputCompressedAccounts.length,\n        inputCompressedAccounts,\n    );\n\n    outputCompressedAccounts.forEach((account, index) => {\n        const merkleTreePubkeyIndex = getIndexOrAdd(\n            _remainingAccounts,\n            paddedOutputStateMerkleTrees[index],\n        );\n        packedOutputCompressedAccounts.push({\n            compressedAccount: {\n                owner: account.owner,\n                lamports: account.lamports,\n                address: account.address,\n                data: account.data,\n            },\n            merkleTreeIndex: merkleTreePubkeyIndex,\n        });\n    });\n\n    return {\n        packedInputCompressedAccounts,\n        packedOutputCompressedAccounts,\n        remainingAccounts: _remainingAccounts,\n    };\n}\n","import BN from 'bn.js';\nimport {\n    CompressedAccount,\n    CompressedAccountWithMerkleContext,\n    bn,\n} from '../state';\n\nexport const validateSufficientBalance = (balance: BN) => {\n    if (balance.lt(bn(0))) {\n        throw new Error('Insufficient balance for transfer');\n    }\n};\n\nexport const validateSameOwner = (\n    compressedAccounts:\n        | CompressedAccount[]\n        | CompressedAccountWithMerkleContext[],\n) => {\n    if (compressedAccounts.length === 0) {\n        throw new Error('No accounts provided for validation');\n    }\n    const zerothOwner = compressedAccounts[0].owner;\n    if (\n        !compressedAccounts.every(account => account.owner.equals(zerothOwner))\n    ) {\n        throw new Error('All input accounts must have the same owner');\n    }\n};\n\n/// for V1 circuits.\nexport const validateNumbersForProof = (\n    hashesLength: number,\n    newAddressesLength: number,\n) => {\n    if (hashesLength > 0 && newAddressesLength > 0) {\n        if (hashesLength === 8) {\n            throw new Error(\n                `Invalid number of compressed accounts for proof: ${hashesLength}. Allowed numbers: ${[1, 2, 3, 4].join(', ')}`,\n            );\n        }\n        validateNumbers(hashesLength, [1, 2, 3, 4], 'compressed accounts');\n        validateNumbersForNonInclusionProof(newAddressesLength);\n    } else {\n        if (hashesLength > 0) {\n            validateNumbersForInclusionProof(hashesLength);\n        } else {\n            validateNumbersForNonInclusionProof(newAddressesLength);\n        }\n    }\n};\n\n/// Ensure that the amount if compressed accounts is allowed.\nexport const validateNumbersForInclusionProof = (hashesLength: number) => {\n    validateNumbers(hashesLength, [1, 2, 3, 4, 8], 'compressed accounts');\n};\n\n/// Ensure that the amount if new addresses is allowed.\nexport const validateNumbersForNonInclusionProof = (\n    newAddressesLength: number,\n) => {\n    validateNumbers(newAddressesLength, [1, 2], 'new addresses');\n};\n\n/// V1 circuit safeguards.\nexport const validateNumbers = (\n    length: number,\n    allowedNumbers: number[],\n    type: string,\n) => {\n    if (!allowedNumbers.includes(length)) {\n        throw new Error(\n            `Invalid number of ${type}: ${length}. Allowed numbers: ${allowedNumbers.join(', ')}`,\n        );\n    }\n};\n","import { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { hashToBn254FieldSizeBe, hashvToBn254FieldSizeBe } from './conversion';\nimport { defaultTestStateTreeAccounts } from '../constants';\nimport { getIndexOrAdd } from '../instruction';\n\nexport function deriveAddressSeed(\n    seeds: Uint8Array[],\n    programId: PublicKey,\n): Uint8Array {\n    const combinedSeeds: Uint8Array[] = [programId.toBytes(), ...seeds];\n    const hash = hashvToBn254FieldSizeBe(combinedSeeds);\n    return hash;\n}\n\n/**\n * Derive an address for a compressed account from a seed and an address Merkle\n * tree public key.\n *\n * @param seed                     Seed to derive the address from\n * @param addressMerkleTreePubkey  Merkle tree public key. Defaults to\n *                                 defaultTestStateTreeAccounts().addressTree\n * @returns                        Derived address\n */\nexport function deriveAddress(\n    seed: Uint8Array,\n    addressMerkleTreePubkey: PublicKey = defaultTestStateTreeAccounts()\n        .addressTree,\n): PublicKey {\n    if (seed.length != 32) {\n        throw new Error('Seed length is not 32 bytes.');\n    }\n    const bytes = addressMerkleTreePubkey.toBytes();\n    const combined = Buffer.from([...bytes, ...seed]);\n    const hash = hashToBn254FieldSizeBe(combined);\n\n    if (hash === null) {\n        throw new Error('DeriveAddressError');\n    }\n    const buf = hash[0];\n    return new PublicKey(buf);\n}\n\nexport interface NewAddressParams {\n    /**\n     * Seed for the compressed account. Must be seed used to derive\n     * newAccountAddress\n     */\n    seed: Uint8Array;\n    /**\n     * Recent state root index of the address tree. The expiry is tied to the\n     * validity proof.\n     */\n    addressMerkleTreeRootIndex: number;\n    /**\n     * Address tree pubkey. Must be base pubkey used to derive new address\n     */\n    addressMerkleTreePubkey: PublicKey;\n    /**\n     * Address space queue pubkey. Associated with the state tree.\n     */\n    addressQueuePubkey: PublicKey;\n}\n\nexport interface NewAddressParamsPacked {\n    /**\n     * Seed for the compressed account. Must be seed used to derive\n     * newAccountAddress\n     */\n    seed: number[];\n    /**\n     * Recent state root index of the address tree. The expiry is tied to the\n     * validity proof.\n     */\n    addressMerkleTreeRootIndex: number;\n    /**\n     * Index of the address merkle tree account in the remaining accounts array\n     */\n    addressMerkleTreeAccountIndex: number;\n    /**\n     * Index of the address queue account in the remaining accounts array\n     */\n    addressQueueAccountIndex: number;\n}\n\n/**\n * Packs new address params for instruction data in TypeScript clients\n *\n * @param newAddressParams      New address params\n * @param remainingAccounts     Remaining accounts\n * @returns                     Packed new address params\n */\nexport function packNewAddressParams(\n    newAddressParams: NewAddressParams[],\n    remainingAccounts: PublicKey[],\n): {\n    newAddressParamsPacked: NewAddressParamsPacked[];\n    remainingAccounts: PublicKey[];\n} {\n    const _remainingAccounts = remainingAccounts.slice();\n\n    const newAddressParamsPacked: NewAddressParamsPacked[] =\n        newAddressParams.map(x => ({\n            seed: Array.from(x.seed),\n            addressMerkleTreeRootIndex: x.addressMerkleTreeRootIndex,\n            addressMerkleTreeAccountIndex: 0, // will be assigned later\n            addressQueueAccountIndex: 0, // will be assigned later\n        }));\n\n    newAddressParams.forEach((params, i) => {\n        newAddressParamsPacked[i].addressMerkleTreeAccountIndex = getIndexOrAdd(\n            _remainingAccounts,\n            params.addressMerkleTreePubkey,\n        );\n    });\n\n    newAddressParams.forEach((params, i) => {\n        newAddressParamsPacked[i].addressQueueAccountIndex = getIndexOrAdd(\n            _remainingAccounts,\n            params.addressQueuePubkey,\n        );\n    });\n\n    return { newAddressParamsPacked, remainingAccounts: _remainingAccounts };\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    const programId = new PublicKey(\n        '7yucc7fL3JGbyMwg4neUaenNSdySS39hbAk89Ao3t1Hz',\n    );\n\n    describe('derive address seed', () => {\n        it('should derive a valid address seed', () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('foo'),\n                new TextEncoder().encode('bar'),\n            ];\n            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(\n                new Uint8Array([\n                    0, 246, 150, 3, 192, 95, 53, 123, 56, 139, 206, 179, 253,\n                    133, 115, 103, 120, 155, 251, 72, 250, 47, 117, 217, 118,\n                    59, 174, 207, 49, 101, 201, 110,\n                ]),\n            );\n        });\n\n        it('should derive a valid address seed', () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('ayy'),\n                new TextEncoder().encode('lmao'),\n            ];\n            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(\n                new Uint8Array([\n                    0, 202, 44, 25, 221, 74, 144, 92, 69, 168, 38, 19, 206, 208,\n                    29, 162, 53, 27, 120, 214, 152, 116, 15, 107, 212, 168, 33,\n                    121, 187, 10, 76, 233,\n                ]),\n            );\n        });\n    });\n\n    describe('deriveAddress function', () => {\n        it('should derive a valid address from a seed and a merkle tree public key', async () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('foo'),\n                new TextEncoder().encode('bar'),\n            ];\n            const seed = deriveAddressSeed(seeds, programId);\n            const merkleTreePubkey = new PublicKey(\n                '11111111111111111111111111111111',\n            );\n            const derivedAddress = deriveAddress(seed, merkleTreePubkey);\n            expect(derivedAddress).toBeInstanceOf(PublicKey);\n            expect(derivedAddress).toStrictEqual(\n                new PublicKey('139uhyyBtEh4e1CBDJ68ooK5nCeWoncZf9HPyAfRrukA'),\n            );\n        });\n\n        it('should derive a valid address from a seed and a merkle tree public key', async () => {\n            const seeds: Uint8Array[] = [\n                new TextEncoder().encode('ayy'),\n                new TextEncoder().encode('lmao'),\n            ];\n            const seed = deriveAddressSeed(seeds, programId);\n            const merkleTreePubkey = new PublicKey(\n                '11111111111111111111111111111111',\n            );\n            const derivedAddress = deriveAddress(seed, merkleTreePubkey);\n            expect(derivedAddress).toBeInstanceOf(PublicKey);\n            expect(derivedAddress).toStrictEqual(\n                new PublicKey('12bhHm6PQjbNmEn3Yu1Gq9k7XwVn2rZpzYokmLwbFazN'),\n            );\n        });\n    });\n\n    describe('packNewAddressParams function', () => {\n        it('should pack new address params correctly', () => {\n            const newAddressParams = [\n                {\n                    seed: new Uint8Array([1, 2, 3, 4]),\n                    addressMerkleTreeRootIndex: 0,\n                    addressMerkleTreePubkey: new PublicKey(\n                        '11111111111111111111111111111111',\n                    ),\n                    addressQueuePubkey: new PublicKey(\n                        '11111111111111111111111111111112',\n                    ),\n                },\n            ];\n            const remainingAccounts = [\n                new PublicKey('11111111111111111111111111111112'),\n                new PublicKey('11111111111111111111111111111111'),\n            ];\n            const packedParams = packNewAddressParams(\n                newAddressParams,\n                remainingAccounts,\n            );\n            expect(\n                packedParams.newAddressParamsPacked[0]\n                    .addressMerkleTreeAccountIndex,\n            ).toBe(1);\n            expect(\n                packedParams.newAddressParamsPacked[0].addressQueueAccountIndex,\n            ).toBe(0);\n        });\n    });\n}\n","import {\n    Commitment,\n    Connection,\n    PublicKey,\n    TransactionConfirmationStrategy,\n} from '@solana/web3.js';\n\nexport async function airdropSol({\n    connection,\n    lamports,\n    recipientPublicKey,\n}: {\n    connection: Connection;\n    lamports: number;\n    recipientPublicKey: PublicKey;\n}) {\n    const txHash = await connection.requestAirdrop(\n        recipientPublicKey,\n        lamports,\n    );\n    await confirmTransaction(connection, txHash);\n    return txHash;\n}\n\nexport async function confirmTransaction(\n    connection: Connection,\n    signature: string,\n    confirmation: Commitment = 'confirmed',\n) {\n    const latestBlockHash = await connection.getLatestBlockhash(confirmation);\n    const strategy: TransactionConfirmationStrategy = {\n        signature: signature.toString(),\n        lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n        blockhash: latestBlockHash.blockhash,\n    };\n    return await connection.confirmTransaction(strategy, confirmation);\n}\n","import BN from 'bn.js';\nimport { FIELD_SIZE } from '../constants';\nimport { CompressedProof } from '../state';\n\ninterface GnarkProofJson {\n    ar: string[];\n    bs: string[][];\n    krs: string[];\n}\n\ntype ProofABC = {\n    a: Uint8Array;\n    b: Uint8Array;\n    c: Uint8Array;\n};\n\nexport const placeholderValidityProof = () => ({\n    a: Array.from({ length: 32 }, (_, i) => i + 1),\n    b: Array.from({ length: 64 }, (_, i) => i + 1),\n    c: Array.from({ length: 32 }, (_, i) => i + 1),\n});\n\nexport const checkValidityProofShape = (proof: CompressedProof) => {\n    if (\n        proof.a.length !== 32 ||\n        proof.b.length !== 64 ||\n        proof.c.length !== 32\n    ) {\n        throw new Error('ValidityProof has invalid shape');\n    }\n};\n\nexport function proofFromJsonStruct(json: GnarkProofJson): ProofABC {\n    const proofAX = deserializeHexStringToBeBytes(json.ar[0]);\n    const proofAY = deserializeHexStringToBeBytes(json.ar[1]);\n    const proofA: Uint8Array = new Uint8Array([...proofAX, ...proofAY]);\n\n    const proofBX0 = deserializeHexStringToBeBytes(json.bs[0][0]);\n    const proofBX1 = deserializeHexStringToBeBytes(json.bs[0][1]);\n    const proofBY0 = deserializeHexStringToBeBytes(json.bs[1][0]);\n    const proofBY1 = deserializeHexStringToBeBytes(json.bs[1][1]);\n    const proofB: Uint8Array = new Uint8Array([\n        ...proofBX0,\n        ...proofBX1,\n        ...proofBY0,\n        ...proofBY1,\n    ]);\n\n    const proofCX = deserializeHexStringToBeBytes(json.krs[0]);\n    const proofCY = deserializeHexStringToBeBytes(json.krs[1]);\n    const proofC: Uint8Array = new Uint8Array([...proofCX, ...proofCY]);\n\n    const proofABC: ProofABC = { a: proofA, b: proofB, c: proofC };\n    return proofABC;\n}\n\n// TODO: add unit test for negation\n// TODO: test if LE BE issue. unit test\nexport function negateAndCompressProof(proof: ProofABC): CompressedProof {\n    const proofA = proof.a;\n    const proofB = proof.b;\n    const proofC = proof.c;\n\n    const aXElement = proofA.slice(0, 32);\n    const aYElement = new BN(proofA.slice(32, 64), 32, 'be');\n\n    /// Negate\n    const proofAIsPositive = yElementIsPositiveG1(aYElement) ? false : true;\n    /// First byte of proofA is the bitmask\n    aXElement[0] = addBitmaskToByte(aXElement[0], proofAIsPositive);\n\n    const bXElement = proofB.slice(0, 64);\n    const bYElement = proofB.slice(64, 128);\n\n    const proofBIsPositive = yElementIsPositiveG2(\n        new BN(bYElement.slice(0, 32), 32, 'be'),\n        new BN(bYElement.slice(32, 64), 32, 'be'),\n    );\n\n    bXElement[0] = addBitmaskToByte(bXElement[0], proofBIsPositive);\n\n    const cXElement = proofC.slice(0, 32);\n    const cYElement = proofC.slice(32, 64);\n    const proofCIsPositive = yElementIsPositiveG1(new BN(cYElement, 32, 'be'));\n    cXElement[0] = addBitmaskToByte(cXElement[0], proofCIsPositive);\n\n    const compressedProof: CompressedProof = {\n        a: Array.from(aXElement),\n        b: Array.from(bXElement),\n        c: Array.from(cXElement),\n    };\n\n    return compressedProof;\n}\n\nfunction deserializeHexStringToBeBytes(hexStr: string): Uint8Array {\n    // Using BN for simpler conversion from hex string to byte array\n    const bn = new BN(\n        hexStr.startsWith('0x') ? hexStr.substring(2) : hexStr,\n        'hex',\n    );\n    return new Uint8Array(bn.toArray('be', 32));\n}\n\nfunction yElementIsPositiveG1(yElement: BN): boolean {\n    return yElement.lte(FIELD_SIZE.sub(yElement));\n}\n\nfunction yElementIsPositiveG2(yElement1: BN, yElement2: BN): boolean {\n    const fieldMidpoint = FIELD_SIZE.div(new BN(2));\n\n    // Compare the first component of the y coordinate\n    if (yElement1.lt(fieldMidpoint)) {\n        return true;\n    } else if (yElement1.gt(fieldMidpoint)) {\n        return false;\n    }\n\n    // If the first component is equal to the midpoint, compare the second component\n    return yElement2.lt(fieldMidpoint);\n}\n// bitmask compatible with solana altbn128 compression syscall and arkworks' implementation\n// https://github.com/arkworks-rs/algebra/blob/master/ff/src/fields/models/fp/mod.rs#L580\n// https://github.com/arkworks-rs/algebra/blob/master/serialize/src/flags.rs#L18\n// fn u8_bitmask(value: u8, inf: bool, neg: bool) -> u8 {\n//     let mut mask = 0;\n//     match self {\n//         inf => mask |= 1 << 6,\n//         neg => mask |= 1 << 7,\n//         _ => (),\n//     }\n//     mask\n// }\nfunction addBitmaskToByte(byte: number, yIsPositive: boolean): number {\n    if (!yIsPositive) {\n        return (byte |= 1 << 7);\n    } else {\n        return byte;\n    }\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    // Unit test for addBitmaskToByte function\n    describe('addBitmaskToByte', () => {\n        it('should add a bitmask to the byte if yIsPositive is false', () => {\n            const byte = 0b00000000;\n            const yIsPositive = false;\n            const result = addBitmaskToByte(byte, yIsPositive);\n            expect(result).toBe(0b10000000); // 128 in binary, which is 1 << 7\n        });\n\n        it('should not modify the byte if yIsPositive is true', () => {\n            const byte = 0b00000000;\n            const yIsPositive = true;\n            const result = addBitmaskToByte(byte, yIsPositive);\n            expect(result).toBe(0b00000000);\n        });\n    });\n\n    describe('test prover server', () => {\n        const TEST_JSON = {\n            ar: [\n                '0x22bdaa3187d8fe294925a66fa0165a11bc9e07678fa2fc72402ebfd33d521c69',\n                '0x2d18ff780b69898b4cdd8d7b6ac72d077799399f0f45e52665426456f3903584',\n            ],\n            bs: [\n                [\n                    '0x138cc0962e49f76a701d2871d2799892c9782940095eb0429e979f336d2e162d',\n                    '0x2fe1bfbb15cbfb83d7e00ace23e45f890604003783eaf34affa35e0d6f4822bc',\n                ],\n                [\n                    '0x1a89264f82cc6e8ef1c696bea0b5803c28c0ba6ab61366bcb71e73a4135cae8d',\n                    '0xf778d857b3df01a4100265c9d014ce02d47425f0114685356165fa5ee3f3a26',\n                ],\n            ],\n            krs: [\n                '0x176b6ae9001f66832951e2d43a98a972667447bb1781f534b70cb010270dcdd3',\n                '0xb748d5fac1686db28d94c02250af7eb4f28dfdabc8983305c45bcbc6e163eeb',\n            ],\n        };\n        const COMPRESSED_PROOF_A = [\n            34, 189, 170, 49, 135, 216, 254, 41, 73, 37, 166, 111, 160, 22, 90,\n            17, 188, 158, 7, 103, 143, 162, 252, 114, 64, 46, 191, 211, 61, 82,\n            28, 105,\n        ];\n        const COMPRESSED_PROOF_B = [\n            147, 140, 192, 150, 46, 73, 247, 106, 112, 29, 40, 113, 210, 121,\n            152, 146, 201, 120, 41, 64, 9, 94, 176, 66, 158, 151, 159, 51, 109,\n            46, 22, 45, 47, 225, 191, 187, 21, 203, 251, 131, 215, 224, 10, 206,\n            35, 228, 95, 137, 6, 4, 0, 55, 131, 234, 243, 74, 255, 163, 94, 13,\n            111, 72, 34, 188,\n        ];\n        const COMPRESSED_PROOF_C = [\n            23, 107, 106, 233, 0, 31, 102, 131, 41, 81, 226, 212, 58, 152, 169,\n            114, 102, 116, 71, 187, 23, 129, 245, 52, 183, 12, 176, 16, 39, 13,\n            205, 211,\n        ];\n\n        it('should execute a compressed token mint', async () => {\n            const proof = proofFromJsonStruct(TEST_JSON);\n            const compressedProof = negateAndCompressProof(proof);\n            expect(compressedProof.a).toEqual(COMPRESSED_PROOF_A);\n            expect(compressedProof.b).toEqual(COMPRESSED_PROOF_B);\n            expect(compressedProof.c).toEqual(COMPRESSED_PROOF_C);\n        });\n    });\n    describe('Validity Proof Functions', () => {\n        describe('placeholderValidityProof', () => {\n            it('should create a validity proof with correct shape', () => {\n                const validityProof = placeholderValidityProof();\n                expect(validityProof.a.length).toBe(32);\n                expect(validityProof.b.length).toBe(64);\n                expect(validityProof.c.length).toBe(32);\n            });\n        });\n\n        describe('checkValidityProofShape', () => {\n            it('should not throw an error for valid proof shape', () => {\n                const validProof = {\n                    a: Array.from(new Uint8Array(32)),\n                    b: Array.from(new Uint8Array(64)),\n                    c: Array.from(new Uint8Array(32)),\n                };\n                expect(() => checkValidityProofShape(validProof)).not.toThrow();\n            });\n\n            it('should throw an error for an invalid proof', () => {\n                const invalidProof = {\n                    a: Array.from(new Uint8Array(31)), // incorrect length\n                    b: Array.from(new Uint8Array(64)),\n                    c: Array.from(new Uint8Array(32)),\n                };\n                expect(() => checkValidityProofShape(invalidProof)).toThrow(\n                    'ValidityProof has invalid shape',\n                );\n            });\n        });\n    });\n}\n","import {\n    VersionedTransaction,\n    TransactionConfirmationStrategy,\n    SignatureResult,\n    RpcResponseAndContext,\n    Signer,\n    TransactionInstruction,\n    TransactionMessage,\n    ConfirmOptions,\n    TransactionSignature,\n    PublicKey,\n    AddressLookupTableAccount,\n} from '@solana/web3.js';\nimport { Rpc } from '../rpc';\n\n/**\n * Builds a versioned Transaction from instructions.\n *\n * @param instructions          instructions to include\n * @param payerPublicKey        fee payer public key\n * @param blockhash             blockhash to use\n * @param lookupTableAccounts   lookup table accounts to include\n *\n * @return VersionedTransaction\n */\nexport function buildTx(\n    instructions: TransactionInstruction[],\n    payerPublicKey: PublicKey,\n    blockhash: string,\n    lookupTableAccounts?: AddressLookupTableAccount[],\n): VersionedTransaction {\n    const messageV0 = new TransactionMessage({\n        payerKey: payerPublicKey,\n        recentBlockhash: blockhash,\n        instructions,\n    }).compileToV0Message(lookupTableAccounts);\n\n    return new VersionedTransaction(messageV0);\n}\n\n/**\n * Sends a versioned transaction and confirms it.\n *\n * @param rpc               connection to use\n * @param tx                versioned transaction to send\n * @param confirmOptions    confirmation options\n * @param blockHashCtx      blockhash context for confirmation\n *\n * @return TransactionSignature\n */\nexport async function sendAndConfirmTx(\n    rpc: Rpc,\n    tx: VersionedTransaction,\n    confirmOptions?: ConfirmOptions,\n    blockHashCtx?: { blockhash: string; lastValidBlockHeight: number },\n): Promise<TransactionSignature> {\n    const txId = await rpc.sendTransaction(tx, confirmOptions);\n\n    if (!blockHashCtx) blockHashCtx = await rpc.getLatestBlockhash();\n\n    const transactionConfirmationStrategy0: TransactionConfirmationStrategy = {\n        signature: txId,\n        blockhash: blockHashCtx.blockhash,\n        lastValidBlockHeight: blockHashCtx.lastValidBlockHeight,\n    };\n\n    const ctxAndRes = await rpc.confirmTransaction(\n        transactionConfirmationStrategy0,\n        confirmOptions?.commitment || rpc.commitment || 'confirmed',\n    );\n    const slot = ctxAndRes.context.slot;\n    await rpc.confirmTransactionIndexed(slot);\n    return txId;\n}\n\n/**\n * Confirms a transaction with a given txId.\n *\n * @param rpc               connection to use\n * @param txId              transaction signature to confirm\n * @param confirmOptions    confirmation options\n * @param blockHashCtx      blockhash context for confirmation\n * @return SignatureResult\n */\nexport async function confirmTx(\n    rpc: Rpc,\n    txId: string,\n    confirmOptions?: ConfirmOptions,\n    blockHashCtx?: { blockhash: string; lastValidBlockHeight: number },\n): Promise<RpcResponseAndContext<SignatureResult>> {\n    if (!blockHashCtx) blockHashCtx = await rpc.getLatestBlockhash();\n\n    const transactionConfirmationStrategy: TransactionConfirmationStrategy = {\n        signature: txId,\n        blockhash: blockHashCtx.blockhash,\n        lastValidBlockHeight: blockHashCtx.lastValidBlockHeight,\n    };\n    const res = await rpc.confirmTransaction(\n        transactionConfirmationStrategy,\n        confirmOptions?.commitment || rpc.commitment || 'confirmed',\n    );\n    const slot = res.context.slot;\n    await rpc.confirmTransactionIndexed(slot);\n    return res;\n}\n\n/**\n * Builds a versioned Transaction from instructions and signs it.\n *\n * @param instructions          instructions to include in the transaction\n * @param payer                 payer of the transaction\n * @param blockhash             recent blockhash to use in the transaction\n * @param additionalSigners     non-feepayer signers to include in the\n *                              transaction\n * @param lookupTableAccounts   lookup table accounts to include in the\n *                              transaction\n */\nexport function buildAndSignTx(\n    instructions: TransactionInstruction[],\n    payer: Signer,\n    blockhash: string,\n    additionalSigners: Signer[] = [],\n    lookupTableAccounts?: AddressLookupTableAccount[],\n): VersionedTransaction {\n    if (additionalSigners.includes(payer))\n        throw new Error('payer must not be in additionalSigners');\n    const allSigners = [payer, ...additionalSigners];\n\n    const tx = buildTx(\n        instructions,\n        payer.publicKey,\n        blockhash,\n        lookupTableAccounts,\n    );\n\n    tx.sign(allSigners);\n\n    return tx;\n}\n","import {\n    AddressLookupTableProgram,\n    Connection,\n    Keypair,\n    PublicKey,\n    Signer,\n} from '@solana/web3.js';\nimport { buildAndSignTx, sendAndConfirmTx } from './send-and-confirm';\nimport { dedupeSigner } from '../actions';\nimport { ActiveTreeBundle, TreeType } from '../state/types';\n\n/**\n * Create two lookup tables storing all public state tree and queue addresses\n * returns lookup table addresses and txId\n *\n * @internal\n * @param connection - Connection to the Solana network\n * @param payer - Keypair of the payer\n * @param authority - Keypair of the authority\n * @param recentSlot - Slot of the recent block\n */\nexport async function createStateTreeLookupTable({\n    connection,\n    payer,\n    authority,\n    recentSlot,\n}: {\n    connection: Connection;\n    payer: Keypair;\n    authority: Keypair;\n    recentSlot: number;\n}): Promise<{ address: PublicKey; txId: string }> {\n    const [createInstruction1, lookupTableAddress1] =\n        AddressLookupTableProgram.createLookupTable({\n            payer: payer.publicKey,\n            authority: authority.publicKey,\n            recentSlot,\n        });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx(\n        [createInstruction1],\n        payer,\n        blockhash.blockhash,\n        dedupeSigner(payer as Signer, [authority]),\n    );\n    // @ts-expect-error\n    const txId = await sendAndConfirmTx(connection, tx);\n\n    return {\n        address: lookupTableAddress1,\n        txId,\n    };\n}\n\n/**\n * Extend state tree lookup table with new state tree and queue addresses\n * @internal\n * @param connection - Connection to the Solana network\n * @param tableAddress - Address of the lookup table to extend\n * @param newStateTreeAddresses - Addresses of the new state trees to add\n * @param newQueueAddresses - Addresses of the new queues to add\n * @param newCpiContextAddresses - Addresses of the new cpi contexts to add\n * @param payer - Keypair of the payer\n * @param authority - Keypair of the authority\n */\nexport async function extendStateTreeLookupTable({\n    connection,\n    tableAddress,\n    newStateTreeAddresses,\n    newQueueAddresses,\n    newCpiContextAddresses,\n    payer,\n    authority,\n}: {\n    connection: Connection;\n    tableAddress: PublicKey;\n    newStateTreeAddresses: PublicKey[];\n    newQueueAddresses: PublicKey[];\n    newCpiContextAddresses: PublicKey[];\n    payer: Keypair;\n    authority: Keypair;\n}): Promise<{ tableAddress: PublicKey; txId: string }> {\n    const lutState = await connection.getAddressLookupTable(tableAddress);\n    if (!lutState.value) {\n        throw new Error('Lookup table not found');\n    }\n    if (lutState.value.state.addresses.length % 3 !== 0) {\n        throw new Error('Lookup table must have a multiple of 3 addresses');\n    }\n    if (\n        newStateTreeAddresses.length !== newQueueAddresses.length ||\n        newStateTreeAddresses.length !== newCpiContextAddresses.length\n    ) {\n        throw new Error(\n            'Same number of newStateTreeAddresses, newQueueAddresses, and newCpiContextAddresses required',\n        );\n    }\n\n    const instructions = AddressLookupTableProgram.extendLookupTable({\n        payer: payer.publicKey,\n        authority: authority.publicKey,\n        lookupTable: tableAddress,\n        addresses: newStateTreeAddresses.flatMap((addr, index) => [\n            addr,\n            newQueueAddresses[index],\n            newCpiContextAddresses[index],\n        ]),\n    });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx(\n        [instructions],\n        payer,\n        blockhash.blockhash,\n        dedupeSigner(payer as Signer, [authority]),\n    );\n    // we pass a Connection type so we don't have to depend on the Rpc module.\n    // @ts-expect-error\n    const txId = await sendAndConfirmTx(connection, tx);\n\n    return {\n        tableAddress,\n        txId,\n    };\n}\n\n/**\n * Adds state tree address to lookup table. Acts as nullifier lookup for rolled\n * over state trees.\n * @internal\n * @param connection - Connection to the Solana network\n * @param stateTreeAddress - Address of the state tree to nullify\n * @param nullifyTableAddress - Address of the nullifier lookup table to store\n * address in\n * @param stateTreeLookupTableAddress - lookup table storing all state tree\n * addresses\n * @param payer - Keypair of the payer\n * @param authority - Keypair of the authority\n */\nexport async function nullifyLookupTable({\n    connection,\n    fullStateTreeAddress,\n    nullifyTableAddress,\n    stateTreeLookupTableAddress,\n    payer,\n    authority,\n}: {\n    connection: Connection;\n    fullStateTreeAddress: PublicKey;\n    nullifyTableAddress: PublicKey;\n    stateTreeLookupTableAddress: PublicKey;\n    payer: Keypair;\n    authority: Keypair;\n}): Promise<{ txId: string }> {\n    // to be nullified address must be part of stateTreeLookupTable set\n    const stateTreeLookupTable = await connection.getAddressLookupTable(\n        stateTreeLookupTableAddress,\n    );\n\n    if (!stateTreeLookupTable.value) {\n        throw new Error('State tree lookup table not found');\n    }\n\n    if (\n        !stateTreeLookupTable.value.state.addresses.includes(\n            fullStateTreeAddress,\n        )\n    ) {\n        throw new Error(\n            'State tree address not found in lookup table. Pass correct address or stateTreeLookupTable',\n        );\n    }\n\n    const nullifyTable =\n        await connection.getAddressLookupTable(nullifyTableAddress);\n\n    if (!nullifyTable.value) {\n        throw new Error('Nullify table not found');\n    }\n    if (nullifyTable.value.state.addresses.includes(fullStateTreeAddress)) {\n        throw new Error('Address already exists in nullify lookup table');\n    }\n\n    const instructions = AddressLookupTableProgram.extendLookupTable({\n        payer: payer.publicKey,\n        authority: authority.publicKey,\n        lookupTable: nullifyTableAddress,\n        addresses: [fullStateTreeAddress],\n    });\n\n    const blockhash = await connection.getLatestBlockhash();\n\n    const tx = buildAndSignTx([instructions], payer, blockhash.blockhash);\n    // we pass a Connection type so we don't have to depend on the Rpc module.\n    // @ts-expect-error\n    const txId = await sendAndConfirmTx(connection, tx);\n\n    return {\n        txId,\n    };\n}\n\n/**\n *  Get most recent , active state tree data\n * we store in lookup table for each public state tree\n */\nexport async function getLightStateTreeInfo({\n    connection,\n    stateTreeLookupTableAddress,\n    nullifyTableAddress,\n}: {\n    connection: Connection;\n    stateTreeLookupTableAddress: PublicKey;\n    nullifyTableAddress: PublicKey;\n}): Promise<ActiveTreeBundle[]> {\n    const stateTreeLookupTable = await connection.getAddressLookupTable(\n        stateTreeLookupTableAddress,\n    );\n\n    if (!stateTreeLookupTable.value) {\n        throw new Error('State tree lookup table not found');\n    }\n\n    if (stateTreeLookupTable.value.state.addresses.length % 3 !== 0) {\n        throw new Error(\n            'State tree lookup table must have a multiple of 3 addresses',\n        );\n    }\n\n    const nullifyTable =\n        await connection.getAddressLookupTable(nullifyTableAddress);\n    if (!nullifyTable.value) {\n        throw new Error('Nullify table not found');\n    }\n    const stateTreePubkeys = stateTreeLookupTable.value.state.addresses;\n    const nullifyTablePubkeys = nullifyTable.value.state.addresses;\n\n    const bundles: ActiveTreeBundle[] = [];\n\n    for (let i = 0; i < stateTreePubkeys.length; i += 3) {\n        const tree = stateTreePubkeys[i];\n        // Skip rolledover (full or almost full) Merkle trees\n        if (!nullifyTablePubkeys.includes(tree)) {\n            bundles.push({\n                tree,\n                queue: stateTreePubkeys[i + 1],\n                cpiContext: stateTreePubkeys[i + 2],\n                treeType: TreeType.State,\n            });\n        }\n    }\n\n    return bundles;\n}\n","/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports.const = ((value, property) => new Constant(value, property));\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;\nconst buffer_layout_1 = require(\"buffer-layout\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nvar buffer_layout_2 = require(\"buffer-layout\");\nObject.defineProperty(exports, \"u8\", { enumerable: true, get: function () { return buffer_layout_2.u8; } });\nObject.defineProperty(exports, \"i8\", { enumerable: true, get: function () { return buffer_layout_2.s8; } });\nObject.defineProperty(exports, \"u16\", { enumerable: true, get: function () { return buffer_layout_2.u16; } });\nObject.defineProperty(exports, \"i16\", { enumerable: true, get: function () { return buffer_layout_2.s16; } });\nObject.defineProperty(exports, \"u32\", { enumerable: true, get: function () { return buffer_layout_2.u32; } });\nObject.defineProperty(exports, \"i32\", { enumerable: true, get: function () { return buffer_layout_2.s32; } });\nObject.defineProperty(exports, \"f32\", { enumerable: true, get: function () { return buffer_layout_2.f32; } });\nObject.defineProperty(exports, \"f64\", { enumerable: true, get: function () { return buffer_layout_2.f64; } });\nObject.defineProperty(exports, \"struct\", { enumerable: true, get: function () { return buffer_layout_2.struct; } });\nclass BNLayout extends buffer_layout_1.Layout {\n    constructor(span, signed, property) {\n        super(span, property);\n        this.blob = (0, buffer_layout_1.blob)(span);\n        this.signed = signed;\n    }\n    decode(b, offset = 0) {\n        const num = new bn_js_1.default(this.blob.decode(b, offset), 10, \"le\");\n        if (this.signed) {\n            return num.fromTwos(this.span * 8).clone();\n        }\n        return num;\n    }\n    encode(src, b, offset = 0) {\n        if (this.signed) {\n            src = src.toTwos(this.span * 8);\n        }\n        return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n    }\n}\nfunction u64(property) {\n    return new BNLayout(8, false, property);\n}\nexports.u64 = u64;\nfunction i64(property) {\n    return new BNLayout(8, true, property);\n}\nexports.i64 = i64;\nfunction u128(property) {\n    return new BNLayout(16, false, property);\n}\nexports.u128 = u128;\nfunction i128(property) {\n    return new BNLayout(16, true, property);\n}\nexports.i128 = i128;\nfunction u256(property) {\n    return new BNLayout(32, false, property);\n}\nexports.u256 = u256;\nfunction i256(property) {\n    return new BNLayout(32, true, property);\n}\nexports.i256 = i256;\nclass WrappedLayout extends buffer_layout_1.Layout {\n    constructor(layout, decoder, encoder, property) {\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey(property) {\n    return new WrappedLayout((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);\n}\nexports.publicKey = publicKey;\nclass OptionLayout extends buffer_layout_1.Layout {\n    constructor(layout, property) {\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = (0, buffer_layout_1.u8)();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 1) + 1;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        }\n        else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 1);\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n    getSpan(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return 1;\n        }\n        else if (discriminator === 1) {\n            return this.layout.getSpan(b, offset + 1) + 1;\n        }\n        throw new Error(\"Invalid option \" + this.property);\n    }\n}\nfunction option(layout, property) {\n    return new OptionLayout(layout, property);\n}\nexports.option = option;\nfunction bool(property) {\n    return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);\n}\nexports.bool = bool;\nfunction decodeBool(value) {\n    if (value === 0) {\n        return false;\n    }\n    else if (value === 1) {\n        return true;\n    }\n    throw new Error(\"Invalid bool: \" + value);\n}\nfunction encodeBool(value) {\n    return value ? 1 : 0;\n}\nfunction vec(elementLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.vec = vec;\nfunction tagged(tag, layout, property) {\n    const wrappedLayout = (0, buffer_layout_1.struct)([\n        u64(\"tag\"),\n        layout.replicate(\"data\"),\n    ]);\n    function decodeTag({ tag: receivedTag, data }) {\n        if (!receivedTag.eq(tag)) {\n            throw new Error(\"Invalid tag, expected: \" +\n                tag.toString(\"hex\") +\n                \", got: \" +\n                receivedTag.toString(\"hex\"));\n        }\n        return data;\n    }\n    return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\nexports.tagged = tagged;\nfunction vecU8(property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), \"data\"),\n    ]);\n    return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);\n}\nexports.vecU8 = vecU8;\nfunction str(property) {\n    return new WrappedLayout(vecU8(), (data) => data.toString(\"utf-8\"), (s) => Buffer.from(s, \"utf-8\"), property);\n}\nexports.str = str;\nfunction rustEnum(variants, property, discriminant) {\n    const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);\n    variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n    return unionLayout;\n}\nexports.rustEnum = rustEnum;\nfunction array(elementLayout, length, property) {\n    const layout = (0, buffer_layout_1.struct)([\n        (0, buffer_layout_1.seq)(elementLayout, length, \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);\n}\nexports.array = array;\nclass MapEntryLayout extends buffer_layout_1.Layout {\n    constructor(keyLayout, valueLayout, property) {\n        super(keyLayout.span + valueLayout.span, property);\n        this.keyLayout = keyLayout;\n        this.valueLayout = valueLayout;\n    }\n    decode(b, offset) {\n        offset = offset || 0;\n        const key = this.keyLayout.decode(b, offset);\n        const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));\n        return [key, value];\n    }\n    encode(src, b, offset) {\n        offset = offset || 0;\n        const keyBytes = this.keyLayout.encode(src[0], b, offset);\n        const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);\n        return keyBytes + valueBytes;\n    }\n    getSpan(b, offset) {\n        return (this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset));\n    }\n}\nfunction map(keyLayout, valueLayout, property) {\n    const length = (0, buffer_layout_1.u32)(\"length\");\n    const layout = (0, buffer_layout_1.struct)([\n        length,\n        (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), \"values\"),\n    ]);\n    return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);\n}\nexports.map = map;\n//# sourceMappingURL=index.js.map","import { Buffer } from 'buffer';\nimport { PublicKey, AccountMeta } from '@solana/web3.js';\nimport {\n    struct,\n    u8,\n    u64,\n    bool,\n    vec,\n    option,\n    publicKey,\n    array,\n    u16,\n    u32,\n    Layout,\n    vecU8,\n} from '@coral-xyz/borsh';\nimport {\n    InstructionDataInvoke,\n    InstructionDataInvokeCpi,\n    PublicTransactionEvent,\n} from '../state';\nimport { LightSystemProgram } from './system';\nimport { INVOKE_CPI_DISCRIMINATOR, INVOKE_DISCRIMINATOR } from '../constants';\nimport { BN } from 'bn.js';\n\nexport const CompressedAccountLayout = struct(\n    [\n        publicKey('owner'),\n        u64('lamports'),\n        option(array(u8(), 32), 'address'),\n        option(\n            struct([\n                array(u8(), 8, 'discriminator'),\n                vecU8('data'),\n                array(u8(), 32, 'dataHash'),\n            ]),\n            'data',\n        ),\n    ],\n    'compressedAccount',\n);\n\nexport const MerkleContextLayout = struct(\n    [\n        u8('merkleTreePubkeyIndex'),\n        u8('nullifierQueuePubkeyIndex'),\n        u32('leafIndex'),\n        option(struct([u8('queueId'), u16('index')]), 'queueIndex'),\n    ],\n    'merkleContext',\n);\n\nexport const NewAddressParamsLayout = struct(\n    [\n        array(u8(), 32, 'seed'),\n        u8('addressQueueAccountIndex'),\n        u8('addressMerkleTreeAccountIndex'),\n        u16('addressMerkleTreeRootIndex'),\n    ],\n    'newAddressParams',\n);\n\nexport const InstructionDataInvokeLayout: Layout<InstructionDataInvoke> =\n    struct([\n        option(\n            struct([\n                array(u8(), 32, 'a'),\n                array(u8(), 64, 'b'),\n                array(u8(), 32, 'c'),\n            ]),\n            'proof',\n        ),\n        vec(\n            struct([\n                CompressedAccountLayout,\n                MerkleContextLayout,\n                u16('rootIndex'),\n                bool('readOnly'),\n            ]),\n            'inputCompressedAccountsWithMerkleContext',\n        ),\n        vec(\n            struct([CompressedAccountLayout, u8('merkleTreeIndex')]),\n            'outputCompressedAccounts',\n        ),\n        option(u64(), 'relayFee'),\n        vec(NewAddressParamsLayout, 'newAddressParams'),\n        option(u64(), 'compressOrDecompressLamports'),\n        bool('isCompress'),\n    ]);\n\nexport function encodeInstructionDataInvoke(\n    data: InstructionDataInvoke,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = InstructionDataInvokeLayout.encode(data, buffer);\n    const dataBuffer = Buffer.from(buffer.slice(0, len));\n    const lengthBuffer = Buffer.alloc(4);\n    lengthBuffer.writeUInt32LE(len, 0);\n    return Buffer.concat([INVOKE_DISCRIMINATOR, lengthBuffer, dataBuffer]);\n}\n\nexport const InstructionDataInvokeCpiLayout: Layout<InstructionDataInvokeCpi> =\n    struct([\n        option(\n            struct([\n                array(u8(), 32, 'a'),\n                array(u8(), 64, 'b'),\n                array(u8(), 32, 'c'),\n            ]),\n            'proof',\n        ),\n        vec(NewAddressParamsLayout, 'newAddressParams'),\n        vec(\n            struct([\n                CompressedAccountLayout,\n                MerkleContextLayout,\n                u16('rootIndex'),\n                bool('readOnly'),\n            ]),\n            'inputCompressedAccountsWithMerkleContext',\n        ),\n        vec(\n            struct([CompressedAccountLayout, u8('merkleTreeIndex')]),\n            'outputCompressedAccounts',\n        ),\n        option(u64(), 'relayFee'),\n        option(u64(), 'compressOrDecompressLamports'),\n        bool('isCompress'),\n        option(\n            struct([\n                bool('set_context'),\n                bool('first_set_context'),\n                u8('cpi_context_account_index'),\n            ]),\n            'compressedCpiContext',\n        ),\n    ]);\n\nexport function decodeInstructionDataInvoke(\n    buffer: Buffer,\n): InstructionDataInvoke {\n    return InstructionDataInvokeLayout.decode(\n        buffer.slice(INVOKE_DISCRIMINATOR.length + 4),\n    );\n}\n\nexport function decodeInstructionDataInvokeCpi(\n    buffer: Buffer,\n): InstructionDataInvokeCpi {\n    return InstructionDataInvokeCpiLayout.decode(\n        buffer.slice(INVOKE_CPI_DISCRIMINATOR.length + 4),\n    );\n}\n\nexport type invokeAccountsLayoutParams = {\n    feePayer: PublicKey;\n    authority: PublicKey;\n    registeredProgramPda: PublicKey;\n    noopProgram: PublicKey;\n    accountCompressionAuthority: PublicKey;\n    accountCompressionProgram: PublicKey;\n    solPoolPda: PublicKey | null;\n    decompressionRecipient: PublicKey | null;\n    systemProgram: PublicKey;\n};\n\nexport const invokeAccountsLayout = (\n    accounts: invokeAccountsLayoutParams,\n): AccountMeta[] => {\n    const defaultPubkey = LightSystemProgram.programId;\n    const {\n        feePayer,\n        authority,\n        registeredProgramPda,\n        noopProgram,\n        accountCompressionAuthority,\n        accountCompressionProgram,\n        solPoolPda,\n        decompressionRecipient,\n        systemProgram,\n    } = accounts;\n\n    return [\n        { pubkey: feePayer, isSigner: true, isWritable: true },\n        { pubkey: authority, isSigner: true, isWritable: false },\n        { pubkey: registeredProgramPda, isSigner: false, isWritable: false },\n        { pubkey: noopProgram, isSigner: false, isWritable: false },\n        {\n            pubkey: accountCompressionAuthority,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: accountCompressionProgram,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: solPoolPda ?? defaultPubkey,\n            isSigner: false,\n            isWritable: solPoolPda !== null,\n        },\n        {\n            pubkey: decompressionRecipient ?? defaultPubkey,\n            isSigner: false,\n            isWritable: true,\n        },\n        { pubkey: systemProgram, isSigner: false, isWritable: false },\n    ];\n};\n\nexport const PublicTransactionEventLayout: Layout<PublicTransactionEvent> =\n    struct([\n        vec(array(u8(), 32), 'inputCompressedAccountHashes'),\n        vec(array(u8(), 32), 'outputCompressedAccountHashes'),\n        vec(\n            struct([\n                struct(\n                    [\n                        publicKey('owner'),\n                        u64('lamports'),\n                        option(array(u8(), 32), 'address'),\n                        option(\n                            struct([\n                                array(u8(), 8, 'discriminator'),\n                                vecU8('data'),\n                                array(u8(), 32, 'dataHash'),\n                            ]),\n                            'data',\n                        ),\n                    ],\n                    'compressedAccount',\n                ),\n                u8('merkleTreeIndex'),\n            ]),\n            'outputCompressedAccounts',\n        ),\n        vec(u32(), 'outputLeafIndices'),\n        vec(struct([publicKey('pubkey'), u64('seq')]), 'sequenceNumbers'),\n        option(u64(), 'relayFee'),\n        bool('isCompress'),\n        option(u64(), 'compressOrDecompressLamports'),\n        vec(publicKey(), 'pubkeyArray'),\n        option(vecU8(), 'message'),\n    ]);\n\nexport function encodePublicTransactionEvent(\n    data: PublicTransactionEvent,\n): Buffer {\n    const buffer = Buffer.alloc(1000);\n    const len = PublicTransactionEventLayout.encode(data, buffer);\n\n    return buffer.slice(0, len);\n}\n\nexport function decodePublicTransactionEvent(\n    buffer: Buffer,\n): PublicTransactionEvent {\n    return PublicTransactionEventLayout.decode(buffer);\n}\n\nexport const AppendNullifyCreateAddressInputsMetaLayout = struct(\n    [\n        u8('is_invoked_by_program'),\n        u8('bump'),\n        u8('num_queues'),\n        u8('num_output_queues'),\n        u8('start_output_appends'),\n        u8('num_address_queues'),\n        array(u8(), 32, 'tx_hash'),\n    ],\n    'appendNullifyCreateAddressInputsMeta',\n);\n\nexport const AppendLeavesInputLayout = struct(\n    [u8('index'), array(u8(), 32, 'leaf')],\n    'appendLeavesInput',\n);\n\nexport const InsertNullifierInputLayout = struct(\n    [\n        array(u8(), 32, 'account_hash'),\n        u32('leaf_index'),\n        u8('prove_by_index'),\n        u8('tree_index'),\n        u8('queue_index'),\n    ],\n    'insertNullifierInput',\n);\nexport const InsertAddressInputLayout = struct(\n    [array(u8(), 32, 'address'), u8('tree_index'), u8('queue_index')],\n    'insertAddressInput',\n);\n\nexport const MerkleTreeSequenceNumberLayout = struct(\n    [publicKey('pubkey'), u64('seq')],\n    'merkleTreeSequenceNumber',\n);\n\nexport function deserializeAppendNullifyCreateAddressInputsIndexer(\n    buffer: Buffer,\n) {\n    let offset = 0;\n    const meta = AppendNullifyCreateAddressInputsMetaLayout.decode(\n        buffer,\n        offset,\n    );\n    offset += AppendNullifyCreateAddressInputsMetaLayout.span;\n    const leavesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const leaves = [];\n    for (let i = 0; i < leavesCount; i++) {\n        const leaf = AppendLeavesInputLayout.decode(buffer, offset);\n        leaves.push(leaf);\n        offset += AppendLeavesInputLayout.span;\n    }\n    const nullifiersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const nullifiers = [];\n    for (let i = 0; i < nullifiersCount; i++) {\n        const nullifier = InsertNullifierInputLayout.decode(buffer, offset);\n        nullifiers.push(nullifier);\n        offset += InsertNullifierInputLayout.span;\n    }\n    const addressesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const addresses = [];\n    for (let i = 0; i < addressesCount; i++) {\n        const address = InsertAddressInputLayout.decode(buffer, offset);\n        addresses.push(address);\n        offset += InsertAddressInputLayout.span;\n    }\n    const outputSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const output_sequence_numbers = [];\n    for (let i = 0; i < outputSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        output_sequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const inputSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const inputSequence_numbers = [];\n    for (let i = 0; i < inputSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        inputSequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const addressSequenceNumbersCount = buffer.readUInt8(offset);\n    offset += 1;\n    const addressSequence_numbers = [];\n    for (let i = 0; i < addressSequenceNumbersCount; i++) {\n        const seq = MerkleTreeSequenceNumberLayout.decode(buffer, offset);\n        addressSequence_numbers.push(seq);\n        offset += MerkleTreeSequenceNumberLayout.span;\n    }\n    const outputLeafIndicesCount = buffer.readUInt8(offset);\n    offset += 1;\n    const output_leaf_indices = [];\n    for (let i = 0; i < outputLeafIndicesCount; i++) {\n        const index = u32().decode(buffer, offset);\n        output_leaf_indices.push(index);\n        offset += 4;\n    }\n    return {\n        meta,\n        leaves,\n        nullifiers,\n        addresses,\n        sequence_numbers: output_sequence_numbers,\n        output_leaf_indices,\n    };\n}\n\nexport function convertToPublicTransactionEvent(\n    decoded: any,\n    remainingAccounts: PublicKey[],\n    invokeData: InstructionDataInvoke,\n): PublicTransactionEvent {\n    const convertByteArray = (arr: Uint8Array | Buffer): number[] =>\n        Array.from(arr instanceof Buffer ? new Uint8Array(arr) : arr);\n\n    const result = {\n        inputCompressedAccountHashes: decoded.nullifiers.map((n: any) =>\n            convertByteArray(n.account_hash),\n        ),\n        outputCompressedAccountHashes: decoded.leaves.map((l: any) =>\n            convertByteArray(l.leaf),\n        ),\n        outputCompressedAccounts: decoded.leaves.map(\n            (leaf: any, index: number) => ({\n                compressedAccount: {\n                    owner: new PublicKey(\n                        invokeData?.outputCompressedAccounts[index]\n                            ?.compressedAccount.owner || PublicKey.default,\n                    ),\n                    lamports: new BN(\n                        invokeData?.outputCompressedAccounts[index]\n                            ?.compressedAccount.lamports || 0,\n                    ),\n                    address:\n                        invokeData?.outputCompressedAccounts[index]\n                            .compressedAccount.address,\n                    data: invokeData?.outputCompressedAccounts[index]\n                        ?.compressedAccount.data\n                        ? {\n                              discriminator: convertByteArray(\n                                  Buffer.from(\n                                      invokeData.outputCompressedAccounts[index]\n                                          .compressedAccount.data\n                                          ?.discriminator,\n                                  ),\n                              ),\n                              data:\n                                  convertByteArray(\n                                      Buffer.from(\n                                          invokeData.outputCompressedAccounts[\n                                              index\n                                          ].compressedAccount.data.data,\n                                      ),\n                                  ) ?? [],\n                              dataHash: convertByteArray(\n                                  Buffer.from(\n                                      invokeData.outputCompressedAccounts[index]\n                                          .compressedAccount.data?.dataHash,\n                                  ),\n                              ),\n                          }\n                        : null,\n                },\n                merkleTreeIndex: leaf.index,\n            }),\n        ),\n        outputLeafIndices: decoded.output_leaf_indices,\n        sequenceNumbers: decoded.sequence_numbers.map((sn: any) => ({\n            pubkey: new PublicKey(sn.pubkey),\n            seq: new BN(sn.seq),\n        })),\n        pubkeyArray: remainingAccounts\n            .slice(2)\n            .filter(pk => !pk.equals(PublicKey.default)),\n        isCompress: invokeData?.isCompress || false,\n        relayFee: invokeData?.relayFee ? new BN(invokeData.relayFee) : null,\n        compressOrDecompressLamports: invokeData?.compressOrDecompressLamports\n            ? new BN(invokeData.compressOrDecompressLamports)\n            : null,\n        message: null,\n    };\n\n    return result;\n}\n","import BN from 'bn.js';\nimport {\n    PublicKey,\n    TransactionInstruction,\n    SystemProgram,\n} from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport {\n    CompressedAccount,\n    CompressedAccountWithMerkleContext,\n    CompressedProof,\n    InstructionDataInvoke,\n    bn,\n    createCompressedAccount,\n} from '../state';\nimport { packCompressedAccounts, toAccountMetas } from '../instruction';\nimport { defaultStaticAccountsStruct } from '../constants';\nimport {\n    validateSameOwner,\n    validateSufficientBalance,\n} from '../utils/validation';\nimport { packNewAddressParams, NewAddressParams } from '../utils';\nimport { encodeInstructionDataInvoke, invokeAccountsLayout } from './layout';\n\nexport const sumUpLamports = (\n    accounts: CompressedAccountWithMerkleContext[],\n): BN => {\n    return accounts.reduce(\n        (acc, account) => acc.add(bn(account.lamports)),\n        bn(0),\n    );\n};\n\n/**\n * Create compressed account system transaction params\n */\ntype CreateAccountWithSeedParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * Address params for the new compressed account\n     */\n    newAddressParams: NewAddressParams;\n    newAddress: number[];\n    /**\n     * Recent validity proof proving that there's no existing compressed account\n     * registered with newAccountAddress\n     */\n    recentValidityProof: CompressedProof;\n    /**\n     * State tree pubkey. Defaults to a public state tree if unspecified.\n     */\n    outputStateTree?: PublicKey;\n    /**\n     * Public key of the program to assign as the owner of the created account\n     */\n    programId?: PublicKey;\n    /**\n     * Optional input accounts to transfer lamports from into the new compressed\n     * account.\n     */\n    inputCompressedAccounts?: CompressedAccountWithMerkleContext[];\n    /**\n     * Optional input state root indices of 'inputCompressedAccounts'. The\n     * expiry is tied to the 'recentValidityProof'.\n     */\n    inputStateRootIndices?: number[];\n    /**\n     * Optional lamports to transfer into the new compressed account.\n     */\n    lamports?: number | BN;\n};\n\n/**\n * Defines the parameters for the transfer method\n */\ntype TransferParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * The input state to be consumed.\n     */\n    inputCompressedAccounts: CompressedAccountWithMerkleContext[];\n    /**\n     * Recipient address\n     */\n    toAddress: PublicKey;\n    /**\n     * amount of lamports to transfer.\n     */\n    lamports: number | BN;\n    /**\n     * The recent state root indices of the input state. The expiry is tied to\n     * the proof.\n     *\n     * TODO: Add support for passing recent-values after instruction creation.\n     */\n    recentInputStateRootIndices: number[];\n    /**\n     * The recent validity proof for state inclusion of the input state. It\n     * expires after n slots.\n     */\n    recentValidityProof: CompressedProof;\n    /**\n     * The state trees that the tx output should be inserted into. This can be a\n     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree\n     * of input state.\n     */\n    outputStateTrees?: PublicKey[] | PublicKey;\n};\n\n/// TODO:\n/// - add option to compress to another owner\n/// - add option to merge with input state\n/**\n * Defines the parameters for the transfer method\n */\ntype CompressParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * address that the lamports are attached to. also defaults to the recipient owner\n     */\n    toAddress: PublicKey;\n    /**\n     * amount of lamports to compress.\n     */\n    lamports: number | BN;\n    /**\n     * The state tree that the tx output should be inserted into. Defaults to a\n     * public state tree if unspecified.\n     */\n    outputStateTree?: PublicKey;\n};\n\n/**\n * Defines the parameters for the transfer method\n */\ntype DecompressParams = {\n    /**\n     * The payer of the transaction.\n     */\n    payer: PublicKey;\n    /**\n     * The input state to be consumed.\n     */\n    inputCompressedAccounts: CompressedAccountWithMerkleContext[];\n    /**\n     * Recipient address of uncompressed lamports\n     */\n    toAddress: PublicKey;\n    /**\n     * amount of lamports to decompress.\n     */\n    lamports: number | BN;\n    /**\n     * The recent state root indices of the input state. The expiry is tied to\n     * the proof.\n     *\n     * TODO: Add support for passing recent-values after instruction creation.\n     */\n    recentInputStateRootIndices: number[];\n    /**\n     * The recent validity proof for state inclusion of the input state. It\n     * expires after n slots.\n     */\n    recentValidityProof: CompressedProof;\n    /**\n     * The state trees that the tx output should be inserted into. This can be a\n     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree\n     * of input state.\n     */\n    outputStateTree?: PublicKey;\n};\n\nconst SOL_POOL_PDA_SEED = Buffer.from('sol_pool_pda');\n\nexport class LightSystemProgram {\n    /**\n     * @internal\n     */\n    constructor() {}\n\n    /**\n     * Public key that identifies the CompressedPda program\n     */\n    static programId: PublicKey = new PublicKey(\n        'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7',\n    );\n\n    /**\n     * @internal\n     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY\n     *\n     */\n    static deriveCompressedSolPda(): PublicKey {\n        const seeds = [SOL_POOL_PDA_SEED];\n        const [address, _] = PublicKey.findProgramAddressSync(\n            seeds,\n            this.programId,\n        );\n        return address;\n    }\n\n    static createTransferOutputState(\n        inputCompressedAccounts: CompressedAccountWithMerkleContext[],\n        toAddress: PublicKey,\n        lamports: number | BN,\n    ): CompressedAccount[] {\n        lamports = bn(lamports);\n        const inputLamports = sumUpLamports(inputCompressedAccounts);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        if (changeLamports.eq(bn(0))) {\n            return [createCompressedAccount(toAddress, lamports)];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n\n        const outputCompressedAccounts: CompressedAccount[] = [\n            createCompressedAccount(\n                inputCompressedAccounts[0].owner,\n\n                changeLamports,\n            ),\n            createCompressedAccount(toAddress, lamports),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    static createDecompressOutputState(\n        inputCompressedAccounts: CompressedAccountWithMerkleContext[],\n        lamports: number | BN,\n    ): CompressedAccount[] {\n        lamports = bn(lamports);\n        const inputLamports = sumUpLamports(inputCompressedAccounts);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        /// lamports gets decompressed\n        if (changeLamports.eq(bn(0))) {\n            return [];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n\n        const outputCompressedAccounts: CompressedAccount[] = [\n            createCompressedAccount(\n                inputCompressedAccounts[0].owner,\n                changeLamports,\n            ),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    /**\n     * No data by default\n     */\n    static createNewAddressOutputState(\n        address: number[],\n        owner: PublicKey,\n        lamports?: BN | number,\n        inputCompressedAccounts?: CompressedAccountWithMerkleContext[],\n    ): CompressedAccount[] {\n        lamports = bn(lamports ?? 0);\n        const inputLamports = sumUpLamports(inputCompressedAccounts ?? []);\n        const changeLamports = inputLamports.sub(lamports);\n\n        validateSufficientBalance(changeLamports);\n\n        if (changeLamports.eq(bn(0)) || !inputCompressedAccounts) {\n            return [\n                createCompressedAccount(owner, lamports, undefined, address),\n            ];\n        }\n\n        validateSameOwner(inputCompressedAccounts);\n        const outputCompressedAccounts: CompressedAccount[] = [\n            createCompressedAccount(\n                inputCompressedAccounts[0].owner,\n                changeLamports,\n            ),\n            createCompressedAccount(owner, lamports, undefined, address),\n        ];\n        return outputCompressedAccounts;\n    }\n\n    /**\n     * Creates instruction to create compressed account with PDA.\n     * Cannot write data.\n     *\n     * TODO: support transfer of lamports to the new account.\n     */\n    static async createAccount({\n        payer,\n        newAddressParams,\n        newAddress,\n        recentValidityProof,\n        outputStateTree,\n        inputCompressedAccounts,\n        inputStateRootIndices,\n        lamports,\n    }: CreateAccountWithSeedParams): Promise<TransactionInstruction> {\n        const outputCompressedAccounts = this.createNewAddressOutputState(\n            newAddress,\n            payer,\n            lamports,\n            inputCompressedAccounts,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts: _remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts ?? [],\n            inputStateRootIndices ?? [],\n            outputCompressedAccounts,\n            outputStateTree,\n        );\n\n        const { newAddressParamsPacked, remainingAccounts } =\n            packNewAddressParams([newAddressParams], _remainingAccounts);\n\n        const rawData: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: newAddressParamsPacked,\n            compressOrDecompressLamports: null,\n            isCompress: false,\n        };\n        const data = encodeInstructionDataInvoke(rawData);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: null,\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    static async transfer({\n        payer,\n        inputCompressedAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices,\n        recentValidityProof,\n        outputStateTrees,\n    }: TransferParams): Promise<TransactionInstruction> {\n        /// Create output state\n        const outputCompressedAccounts = this.createTransferOutputState(\n            inputCompressedAccounts,\n            toAddress,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts,\n            recentInputStateRootIndices,\n            outputCompressedAccounts,\n            outputStateTrees,\n        );\n\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: [],\n            compressOrDecompressLamports: null,\n            isCompress: false,\n        };\n\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: null,\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    // TODO: add support for non-fee-payer owner\n    static async compress({\n        payer,\n        toAddress,\n        lamports,\n        outputStateTree,\n    }: CompressParams): Promise<TransactionInstruction> {\n        /// Create output state\n        lamports = bn(lamports);\n\n        const outputCompressedAccount = createCompressedAccount(\n            toAddress,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            [],\n            [],\n            [outputCompressedAccount],\n            outputStateTree,\n        );\n\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: null,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            /// TODO: here and on-chain: option<newAddressInputs> or similar.\n            newAddressParams: [],\n            compressOrDecompressLamports: lamports,\n            isCompress: true,\n        };\n\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: LightSystemProgram.deriveCompressedSolPda(),\n            decompressionRecipient: null,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n\n    /**\n     * Creates a transaction instruction that transfers compressed lamports from\n     * one owner to another.\n     */\n    static async decompress({\n        payer,\n        inputCompressedAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices,\n        recentValidityProof,\n        outputStateTree,\n    }: DecompressParams): Promise<TransactionInstruction> {\n        /// Create output state\n        lamports = bn(lamports);\n\n        const outputCompressedAccounts = this.createDecompressOutputState(\n            inputCompressedAccounts,\n            lamports,\n        );\n\n        /// Pack accounts\n        const {\n            packedInputCompressedAccounts,\n            packedOutputCompressedAccounts,\n            remainingAccounts,\n        } = packCompressedAccounts(\n            inputCompressedAccounts,\n            recentInputStateRootIndices,\n            outputCompressedAccounts,\n            outputStateTree,\n        );\n        /// Encode instruction data\n        const rawInputs: InstructionDataInvoke = {\n            proof: recentValidityProof,\n            inputCompressedAccountsWithMerkleContext:\n                packedInputCompressedAccounts,\n            outputCompressedAccounts: packedOutputCompressedAccounts,\n            relayFee: null,\n            newAddressParams: [],\n            compressOrDecompressLamports: lamports,\n            isCompress: false,\n        };\n        const data = encodeInstructionDataInvoke(rawInputs);\n\n        const accounts = invokeAccountsLayout({\n            ...defaultStaticAccountsStruct(),\n            feePayer: payer,\n            authority: payer,\n            solPoolPda: LightSystemProgram.deriveCompressedSolPda(),\n            decompressionRecipient: toAddress,\n            systemProgram: SystemProgram.programId,\n        });\n        const keys = [...accounts, ...toAccountMetas(remainingAccounts)];\n\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys,\n            data,\n        });\n    }\n}\n\n/**\n * Selects the minimal number of compressed SOL accounts for a transfer.\n *\n * 1. Sorts the accounts by amount in descending order\n * 2. Accumulates the amount until it is greater than or equal to the transfer\n *    amount\n */\nexport function selectMinCompressedSolAccountsForTransfer(\n    accounts: CompressedAccountWithMerkleContext[],\n    transferLamports: BN | number,\n): [selectedAccounts: CompressedAccountWithMerkleContext[], total: BN] {\n    let accumulatedLamports = bn(0);\n    transferLamports = bn(transferLamports);\n\n    const selectedAccounts: CompressedAccountWithMerkleContext[] = [];\n\n    accounts.sort((a, b) => b.lamports.cmp(a.lamports));\n\n    for (const account of accounts) {\n        if (accumulatedLamports.gte(bn(transferLamports))) break;\n        accumulatedLamports = accumulatedLamports.add(account.lamports);\n        selectedAccounts.push(account);\n    }\n\n    if (accumulatedLamports.lt(bn(transferLamports))) {\n        throw new Error(\n            `Insufficient balance for transfer. Required: ${transferLamports.toString()}, available: ${accumulatedLamports.toString()}`,\n        );\n    }\n\n    return [selectedAccounts, accumulatedLamports];\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import { PublicKey, MemcmpFilter, DataSlice } from '@solana/web3.js';\nimport {\n    type as pick,\n    number,\n    string,\n    array,\n    literal,\n    union,\n    coerce,\n    instance,\n    create,\n    unknown,\n    any,\n    nullable,\n    Struct,\n} from 'superstruct';\nimport {\n    BN254,\n    createBN254,\n    CompressedProof,\n    CompressedAccountWithMerkleContext,\n    MerkleContextWithMerkleProof,\n    bn,\n    TokenData,\n} from './state';\nimport BN from 'bn.js';\n\nexport interface LatestNonVotingSignatures {\n    context: { slot: number };\n    value: {\n        items: {\n            signature: string;\n            slot: number;\n            blockTime: number;\n            error: string | null;\n        }[];\n    };\n}\n\nexport interface GetCompressedAccountsByOwnerConfig {\n    filters?: GetCompressedAccountsFilter[];\n    dataSlice?: DataSlice;\n    cursor?: string;\n    limit?: BN;\n}\n\nexport interface CompressedMintTokenHolders {\n    balance: BN;\n    owner: PublicKey;\n}\n\nexport interface LatestNonVotingSignaturesPaginated {\n    context: { slot: number };\n    value: {\n        items: {\n            signature: string;\n            slot: number;\n            blockTime: number;\n        }[];\n        cursor: string | null;\n    };\n}\n\nexport interface SignatureWithMetadata {\n    blockTime: number;\n    signature: string;\n    slot: number;\n}\n\nexport interface HashWithTree {\n    hash: BN254;\n    tree: PublicKey;\n    queue: PublicKey;\n}\n\nexport interface AddressWithTree {\n    address: BN254;\n    tree: PublicKey;\n    queue: PublicKey;\n}\n\nexport interface CompressedTransaction {\n    compressionInfo: {\n        closedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[];\n        openedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[];\n        preTokenBalances?: {\n            owner: PublicKey;\n            mint: PublicKey;\n            amount: BN;\n        }[];\n        postTokenBalances?: {\n            owner: PublicKey;\n            mint: PublicKey;\n            amount: BN;\n        }[];\n    };\n    transaction: any;\n}\n\nexport interface HexBatchInputsForProver {\n    'input-compressed-accounts': HexInputsForProver[];\n}\n\nexport interface HexInputsForProver {\n    root: string;\n    pathIndex: number;\n    pathElements: string[];\n    leaf: string;\n}\n\n// TODO: Rename Compressed -> ValidityProof\nexport type CompressedProofWithContext = {\n    compressedProof: CompressedProof;\n    roots: BN[];\n    rootIndices: number[];\n    leafIndices: number[];\n    leaves: BN[];\n    merkleTrees: PublicKey[];\n    nullifierQueues: PublicKey[];\n};\n\nexport interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {\n    mint?: PublicKey;\n    cursor?: string;\n    limit?: BN;\n}\nexport type TokenBalance = { balance: BN; mint: PublicKey };\n\n/**\n * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.\n *\n * **Limit** is the maximum number of results to return per page.\n */\nexport interface PaginatedOptions {\n    cursor?: string;\n    limit?: BN;\n}\n\n/**\n * Note, DataSizeFilter is currently not available.\n */\nexport type GetCompressedAccountsFilter = MemcmpFilter; // | DataSizeFilter;\n\nexport type GetCompressedAccountConfig = {\n    encoding?: string;\n};\n\nexport type GetCompressedAccountsConfig = {\n    dataSlice: DataSlice;\n    filters?: GetCompressedAccountsFilter[];\n};\n\nexport interface ParsedTokenAccount {\n    compressedAccount: CompressedAccountWithMerkleContext;\n    parsed: TokenData;\n}\n\nexport type WithContext<T> = {\n    /** context */\n    context: {\n        slot: number;\n    };\n    /** response value */\n    value: T;\n};\n\nexport type WithCursor<T> = {\n    /** context */\n    cursor: string | null;\n    /** response value */\n    items: T;\n};\n\n/**\n * @internal\n */\nconst PublicKeyFromString = coerce(\n    instance(PublicKey),\n    string(),\n    value => new PublicKey(value),\n);\n\n/**\n * @internal\n */\nconst ArrayFromString = coerce(instance(Array<number>), string(), value =>\n    Array.from(new PublicKey(value).toBytes()),\n);\n\n/**\n * @internal\n */\nconst BN254FromString = coerce(instance(BN), string(), value => {\n    return createBN254(value, 'base58');\n});\n\n/**\n *\n * @internal\n * expects bigints to be supplied as strings.\n */\nconst BNFromStringOrNumber = coerce(\n    instance(BN),\n    union([string(), number()]),\n    value => {\n        if (typeof value === 'number') {\n            if (!Number.isSafeInteger(value)) {\n                throw new Error(`Unsafe integer. Precision loss: ${value}`);\n            }\n            return new BN(value); // Safe number → BN\n        }\n        return new BN(value, 10); // String → BN\n    },\n);\n\n/**\n *\n * @internal\n */\nconst Base64EncodedCompressedAccountDataResult = coerce(\n    string(),\n    string(),\n    value => (value === '' ? null : value),\n);\n/**\n * @internal\n */\nexport function createRpcResult<T, U>(result: Struct<T, U>) {\n    return union([\n        pick({\n            jsonrpc: literal('2.0'),\n            id: string(),\n            result,\n        }),\n        pick({\n            jsonrpc: literal('2.0'),\n            id: string(),\n            error: pick({\n                code: unknown(),\n                message: string(),\n                data: nullable(any()),\n            }),\n        }),\n    ]) as Struct<RpcResult<T>, null>;\n}\n\n/**\n * @internal\n */\nconst UnknownRpcResult = createRpcResult(unknown());\n\n/**\n * @internal\n */\nexport function jsonRpcResult<T, U>(schema: Struct<T, U>) {\n    return coerce(createRpcResult(schema), UnknownRpcResult, value => {\n        if ('error' in value) {\n            return value as RpcResultError;\n        } else {\n            return {\n                ...value,\n                result: create(value.result, schema),\n            } as RpcResultSuccess<T>;\n        }\n    }) as Struct<RpcResult<T>, null>;\n}\n\n// Add this type for the context wrapper\nexport type WithRpcContext<T> = {\n    context: {\n        slot: number;\n    };\n    value: T;\n};\n\n/**\n * @internal\n */\nexport function jsonRpcResultAndContext<T, U>(value: Struct<T, U>) {\n    return jsonRpcResult(\n        pick({\n            context: pick({\n                slot: number(),\n            }),\n            value,\n        }),\n    ) as Struct<RpcResult<WithRpcContext<T>>, null>;\n}\n\n/**\n * @internal\n */\nexport const CompressedAccountResult = pick({\n    address: nullable(ArrayFromString),\n    hash: BN254FromString,\n    data: nullable(\n        pick({\n            data: Base64EncodedCompressedAccountDataResult,\n            dataHash: BN254FromString,\n            discriminator: BNFromStringOrNumber,\n        }),\n    ),\n    lamports: BNFromStringOrNumber,\n    owner: PublicKeyFromString,\n    leafIndex: number(),\n    tree: PublicKeyFromString,\n    seq: nullable(BNFromStringOrNumber),\n    slotCreated: BNFromStringOrNumber,\n});\n\nexport const TokenDataResult = pick({\n    mint: PublicKeyFromString,\n    owner: PublicKeyFromString,\n    amount: BNFromStringOrNumber,\n    delegate: nullable(PublicKeyFromString),\n    state: string(),\n});\n\n/**\n * @internal\n */\nexport const CompressedTokenAccountResult = pick({\n    tokenData: TokenDataResult,\n    account: CompressedAccountResult,\n});\n\n/**\n * @internal\n */\nexport const MultipleCompressedAccountsResult = pick({\n    items: array(CompressedAccountResult),\n});\n\n/**\n * @internal\n */\nexport const CompressedAccountsByOwnerResult = pick({\n    items: array(CompressedAccountResult),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const CompressedTokenAccountsByOwnerOrDelegateResult = pick({\n    items: array(CompressedTokenAccountResult),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const SlotResult = number();\n\n/**\n * @internal\n */\nexport const HealthResult = string();\n\n/**\n * @internal\n */\nexport const LatestNonVotingSignaturesResult = pick({\n    items: array(\n        pick({\n            signature: string(),\n            slot: number(),\n            blockTime: number(),\n            error: nullable(string()),\n        }),\n    ),\n});\n\n/**\n * @internal\n */\nexport const LatestNonVotingSignaturesResultPaginated = pick({\n    items: array(\n        pick({\n            signature: string(),\n            slot: number(),\n            blockTime: number(),\n        }),\n    ),\n    cursor: nullable(string()),\n});\n\n/**\n * @internal\n */\nexport const MerkeProofResult = pick({\n    hash: BN254FromString,\n    leafIndex: number(),\n    merkleTree: PublicKeyFromString,\n    proof: array(BN254FromString),\n    rootSeq: number(),\n    root: BN254FromString,\n});\n\n/**\n * @internal\n */\nexport const NewAddressProofResult = pick({\n    address: BN254FromString,\n    nextIndex: number(),\n    merkleTree: PublicKeyFromString,\n    proof: array(BN254FromString), // this is: merkleProofHashedIndexedElementLeaf\n    rootSeq: number(),\n    root: BN254FromString,\n    lowerRangeAddress: BN254FromString, // this is: leafLowerRangeValue.\n    higherRangeAddress: BN254FromString, // this is: leafHigherRangeValue\n    lowElementLeafIndex: number(), // this is: indexHashedIndexedElementLeaf\n});\n\n/**\n * @internal\n */\nconst CompressedProofResult = pick({\n    a: array(number()),\n    b: array(number()),\n    c: array(number()),\n});\n\n/**\n * @internal\n */\nexport const ValidityProofResult = pick({\n    compressedProof: CompressedProofResult,\n    leafIndices: array(number()),\n    leaves: array(BN254FromString),\n    rootIndices: array(number()),\n    roots: array(BN254FromString),\n    merkleTrees: array(PublicKeyFromString),\n    // TODO: enable nullifierQueues\n    // nullifierQueues: array(PublicKeyFromString),\n});\n\n/**\n * @internal\n */\nexport const MultipleMerkleProofsResult = array(MerkeProofResult);\n\n/**\n * @internal\n */\nexport const BalanceResult = pick({\n    amount: BNFromStringOrNumber,\n});\n\nexport const NativeBalanceResult = BNFromStringOrNumber;\n\nexport const TokenBalanceResult = pick({\n    balance: BNFromStringOrNumber,\n    mint: PublicKeyFromString,\n});\n\nexport const TokenBalanceListResult = pick({\n    tokenBalances: array(TokenBalanceResult),\n    cursor: nullable(string()),\n});\n\nexport const TokenBalanceListResultV2 = pick({\n    items: array(TokenBalanceResult),\n    cursor: nullable(string()),\n});\n\nexport const CompressedMintTokenHoldersResult = pick({\n    cursor: nullable(string()),\n    items: array(\n        pick({\n            balance: BNFromStringOrNumber,\n            owner: PublicKeyFromString,\n        }),\n    ),\n});\n\nexport const AccountProofResult = pick({\n    hash: array(number()),\n    root: array(number()),\n    proof: array(array(number())),\n});\n\nexport const toUnixTimestamp = (blockTime: string): number => {\n    return new Date(blockTime).getTime();\n};\n\nexport const SignatureListResult = pick({\n    items: array(\n        pick({\n            blockTime: number(),\n            signature: string(),\n            slot: number(),\n        }),\n    ),\n});\n\nexport const SignatureListWithCursorResult = pick({\n    items: array(\n        pick({\n            blockTime: number(),\n            signature: string(),\n            slot: number(),\n        }),\n    ),\n    cursor: nullable(string()),\n});\n\nexport const CompressedTransactionResult = pick({\n    compressionInfo: pick({\n        closedAccounts: array(\n            pick({\n                account: CompressedAccountResult,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n        openedAccounts: array(\n            pick({\n                account: CompressedAccountResult,\n                optionalTokenData: nullable(TokenDataResult),\n            }),\n        ),\n    }),\n    /// TODO: add transaction struct\n    /// https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/transaction-status/src/lib.rs#L1061\n    transaction: any(),\n});\n\nexport interface CompressionApiInterface {\n    getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null>;\n\n    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;\n\n    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;\n\n    getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof>;\n\n    getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]>;\n\n    getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]>;\n\n    getValidityProof(\n        hashes: BN254[],\n        newAddresses: BN254[],\n    ): Promise<CompressedProofWithContext>;\n\n    getValidityProofV0(\n        hashes: HashWithTree[],\n        newAddresses: AddressWithTree[],\n    ): Promise<CompressedProofWithContext>;\n\n    getValidityProofAndRpcContext(\n        hashes: HashWithTree[],\n        newAddresses: AddressWithTree[],\n    ): Promise<WithContext<CompressedProofWithContext>>;\n\n    getCompressedAccountsByOwner(\n        owner: PublicKey,\n        config?: GetCompressedAccountsByOwnerConfig,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;\n\n    getCompressedMintTokenHolders(\n        mint: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;\n\n    getCompressedTokenAccountsByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>>;\n\n    getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>>;\n\n    getCompressedTokenAccountBalance(hash: BN254): Promise<{ amount: BN }>;\n\n    getCompressedTokenBalancesByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<TokenBalance[]>>;\n\n    getCompressedTokenBalancesByOwnerV2(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>>;\n\n    getTransactionWithCompressionInfo(\n        signature: string,\n    ): Promise<CompressedTransaction | null>;\n\n    getCompressionSignaturesForAccount(\n        hash: BN254,\n    ): Promise<SignatureWithMetadata[]>;\n\n    getCompressionSignaturesForAddress(\n        address: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getCompressionSignaturesForOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getCompressionSignaturesForTokenOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>>;\n\n    getLatestNonVotingSignatures(\n        limit?: number,\n        cursor?: string,\n    ): Promise<LatestNonVotingSignatures>;\n\n    getLatestCompressionSignatures(\n        cursor?: string,\n        limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated>;\n\n    getIndexerHealth(): Promise<string>;\n\n    getIndexerSlot(): Promise<number>;\n}\n\n// Public types for consumers\nexport type RpcResultSuccess<T> = {\n    jsonrpc: '2.0';\n    id: string;\n    result: T;\n};\n\nexport type RpcResultError = {\n    jsonrpc: '2.0';\n    id: string;\n    error: {\n        code: unknown;\n        message: string;\n        data?: any;\n    };\n};\n\nexport type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;\n","import {\n    Connection,\n    ConnectionConfig,\n    PublicKey,\n    SolanaJSONRPCError,\n} from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport {\n    BalanceResult,\n    CompressedAccountResult,\n    CompressedAccountsByOwnerResult,\n    CompressedProofWithContext,\n    CompressedTokenAccountsByOwnerOrDelegateResult,\n    CompressedTransaction,\n    CompressedTransactionResult,\n    CompressionApiInterface,\n    GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    HealthResult,\n    HexInputsForProver,\n    MerkeProofResult,\n    MultipleCompressedAccountsResult,\n    NativeBalanceResult,\n    ParsedTokenAccount,\n    SignatureListResult,\n    SignatureListWithCursorResult,\n    SignatureWithMetadata,\n    SlotResult,\n    TokenBalanceListResult,\n    jsonRpcResult,\n    jsonRpcResultAndContext,\n    ValidityProofResult,\n    NewAddressProofResult,\n    LatestNonVotingSignaturesResult,\n    LatestNonVotingSignatures,\n    LatestNonVotingSignaturesResultPaginated,\n    LatestNonVotingSignaturesPaginated,\n    WithContext,\n    GetCompressedAccountsByOwnerConfig,\n    WithCursor,\n    AddressWithTree,\n    HashWithTree,\n    CompressedMintTokenHoldersResult,\n    CompressedMintTokenHolders,\n    TokenBalance,\n    TokenBalanceListResultV2,\n    PaginatedOptions,\n} from './rpc-interface';\nimport {\n    MerkleContextWithMerkleProof,\n    BN254,\n    bn,\n    CompressedAccountWithMerkleContext,\n    encodeBN254toBase58,\n    createCompressedAccountWithMerkleContext,\n    createMerkleContext,\n    TokenData,\n    CompressedProof,\n} from './state';\nimport { array, create, nullable } from 'superstruct';\nimport {\n    defaultTestStateTreeAccounts,\n    localTestActiveStateTreeInfo,\n    isLocalTest,\n    defaultStateTreeLookupTables,\n} from './constants';\nimport BN from 'bn.js';\nimport { toCamelCase, toHex } from './utils/conversion';\n\nimport {\n    proofFromJsonStruct,\n    negateAndCompressProof,\n} from './utils/parse-validity-proof';\nimport { LightWasm } from './test-helpers';\nimport { getLightStateTreeInfo } from './utils/get-light-state-tree-info';\nimport { ActiveTreeBundle } from './state/types';\nimport { validateNumbersForProof } from './utils';\n\n/** @internal */\nexport function parseAccountData({\n    discriminator,\n    data,\n    dataHash,\n}: {\n    discriminator: BN;\n    data: string;\n    dataHash: BN;\n}) {\n    return {\n        discriminator: discriminator.toArray('le', 8),\n        data: Buffer.from(data, 'base64'),\n        dataHash: dataHash.toArray('le', 32),\n    };\n}\n\n/** @internal */\nasync function getCompressedTokenAccountsByOwnerOrDelegate(\n    rpc: Rpc,\n    ownerOrDelegate: PublicKey,\n    options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    filterByDelegate: boolean = false,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const endpoint = filterByDelegate\n        ? 'getCompressedTokenAccountsByDelegate'\n        : 'getCompressedTokenAccountsByOwner';\n    const propertyToCheck = filterByDelegate ? 'delegate' : 'owner';\n\n    const unsafeRes = await rpcRequest(rpc.compressionApiEndpoint, endpoint, {\n        [propertyToCheck]: ownerOrDelegate.toBase58(),\n        mint: options.mint?.toBase58(),\n        limit: options.limit?.toNumber(),\n        cursor: options.cursor,\n    });\n\n    const res = create(\n        unsafeRes,\n        jsonRpcResultAndContext(CompressedTokenAccountsByOwnerOrDelegateResult),\n    );\n    if ('error' in res) {\n        throw new SolanaJSONRPCError(\n            res.error,\n            `failed to get info for compressed accounts by ${propertyToCheck} ${ownerOrDelegate.toBase58()}`,\n        );\n    }\n    if (res.result.value === null) {\n        throw new Error('not implemented: NULL result');\n    }\n    const accounts: ParsedTokenAccount[] = [];\n\n    const activeStateTreeInfo = await rpc.getCachedActiveStateTreeInfo();\n\n    res.result.value.items.map(item => {\n        const _account = item.account;\n        const _tokenData = item.tokenData;\n\n        const associatedQueue = getQueueForTree(\n            activeStateTreeInfo,\n            _account.tree!,\n        );\n\n        const compressedAccount: CompressedAccountWithMerkleContext =\n            createCompressedAccountWithMerkleContext(\n                createMerkleContext(\n                    _account.tree!,\n                    associatedQueue,\n                    _account.hash.toArray('be', 32),\n                    _account.leafIndex,\n                ),\n                _account.owner,\n                bn(_account.lamports),\n                _account.data ? parseAccountData(_account.data) : undefined,\n                _account.address || undefined,\n            );\n\n        const parsed: TokenData = {\n            mint: _tokenData.mint,\n            owner: _tokenData.owner,\n            amount: _tokenData.amount,\n            delegate: _tokenData.delegate,\n            state: ['uninitialized', 'initialized', 'frozen'].indexOf(\n                _tokenData.state,\n            ),\n            tlv: null,\n        };\n\n        if (\n            parsed[propertyToCheck]?.toBase58() !== ownerOrDelegate.toBase58()\n        ) {\n            throw new Error(\n                `RPC returned token account with ${propertyToCheck} different from requested ${propertyToCheck}`,\n            );\n        }\n\n        accounts.push({\n            compressedAccount,\n            parsed,\n        });\n    });\n    /// TODO: consider custom or different sort. Most recent here.\n    return {\n        items: accounts.sort(\n            (a, b) =>\n                b.compressedAccount.leafIndex - a.compressedAccount.leafIndex,\n        ),\n        cursor: res.result.value.cursor,\n    };\n}\n\n/** @internal */\nfunction buildCompressedAccountWithMaybeTokenData(\n    accountStructWithOptionalTokenData: any,\n    activeStateTreeInfo: ActiveTreeBundle[],\n): {\n    account: CompressedAccountWithMerkleContext;\n    maybeTokenData: TokenData | null;\n} {\n    const compressedAccountResult = accountStructWithOptionalTokenData.account;\n    const tokenDataResult =\n        accountStructWithOptionalTokenData.optionalTokenData;\n\n    const associatedQueue = getQueueForTree(\n        activeStateTreeInfo,\n        compressedAccountResult.tree!,\n    );\n    const compressedAccount: CompressedAccountWithMerkleContext =\n        createCompressedAccountWithMerkleContext(\n            createMerkleContext(\n                compressedAccountResult.merkleTree,\n                associatedQueue,\n                compressedAccountResult.hash.toArray('be', 32),\n                compressedAccountResult.leafIndex,\n            ),\n            compressedAccountResult.owner,\n            bn(compressedAccountResult.lamports),\n            compressedAccountResult.data\n                ? parseAccountData(compressedAccountResult.data)\n                : undefined,\n            compressedAccountResult.address || undefined,\n        );\n\n    if (tokenDataResult === null) {\n        return { account: compressedAccount, maybeTokenData: null };\n    }\n\n    const parsed: TokenData = {\n        mint: tokenDataResult.mint,\n        owner: tokenDataResult.owner,\n        amount: tokenDataResult.amount,\n        delegate: tokenDataResult.delegate,\n        state: ['uninitialized', 'initialized', 'frozen'].indexOf(\n            tokenDataResult.state,\n        ),\n        tlv: null,\n    };\n\n    return { account: compressedAccount, maybeTokenData: parsed };\n}\n\n/**\n * Establish a Compression-compatible JSON RPC connection\n *\n * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or\n *                                      Connection object\n * @param compressionApiEndpoint        Endpoint to the compression server\n * @param proverEndpoint                Endpoint to the prover server. defaults\n *                                      to endpoint\n * @param connectionConfig              Optional connection config\n */\nexport function createRpc(\n    endpointOrWeb3JsConnection?: string | Connection,\n    compressionApiEndpoint?: string,\n    proverEndpoint?: string,\n    config?: ConnectionConfig,\n): Rpc {\n    const localEndpoint = 'http://127.0.0.1:8899';\n    const localCompressionApiEndpoint = 'http://127.0.0.1:8784';\n    const localProverEndpoint = 'http://127.0.0.1:3001';\n\n    let endpoint: string;\n\n    if (!endpointOrWeb3JsConnection) {\n        // Local as default\n        endpoint = localEndpoint;\n        compressionApiEndpoint =\n            compressionApiEndpoint || localCompressionApiEndpoint;\n        proverEndpoint = proverEndpoint || localProverEndpoint;\n    } else if (typeof endpointOrWeb3JsConnection === 'string') {\n        endpoint = endpointOrWeb3JsConnection;\n        compressionApiEndpoint = compressionApiEndpoint || endpoint;\n        proverEndpoint = proverEndpoint || endpoint;\n    } else if (endpointOrWeb3JsConnection instanceof Connection) {\n        endpoint = endpointOrWeb3JsConnection.rpcEndpoint;\n        compressionApiEndpoint = compressionApiEndpoint || endpoint;\n        proverEndpoint = proverEndpoint || endpoint;\n    }\n    // 3\n    else {\n        throw new Error('Invalid endpoint or connection type');\n    }\n\n    return new Rpc(endpoint, compressionApiEndpoint, proverEndpoint, config);\n}\n\n/**\n * Helper function to preprocess the response to wrap numbers as strings\n * @param {string} text - The JSON string to preprocess\n * @returns {string} - The preprocessed JSON string with numbers wrapped as strings\n */\nexport function wrapBigNumbersAsStrings(text: string): string {\n    return text.replace(/(\":\\s*)(-?\\d+)(\\s*[},])/g, (match, p1, p2, p3) => {\n        const num = Number(p2);\n        if (\n            !Number.isNaN(num) &&\n            (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER)\n        ) {\n            return `${p1}\"${p2}\"${p3}`;\n        }\n        return match;\n    });\n}\n\n/** @internal */\nexport const rpcRequest = async (\n    rpcEndpoint: string,\n    method: string,\n    params: any = [],\n    convertToCamelCase = true,\n    debug = false,\n): Promise<any> => {\n    const body = JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'test-account',\n        method: method,\n        params: params,\n    });\n\n    if (debug) {\n        const generateCurlSnippet = () => {\n            const escapedBody = body.replace(/\"/g, '\\\\\"');\n            return `curl -X POST ${rpcEndpoint} \\\\\n     -H \"Content-Type: application/json\" \\\\\n     -d \"${escapedBody}\"`;\n        };\n\n        console.log('Debug: Stack trace:');\n        console.log(new Error().stack);\n        console.log('\\nDebug: curl:');\n        console.log(generateCurlSnippet());\n        console.log('\\n');\n    }\n\n    const response = await fetch(rpcEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: body,\n    });\n\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const text = await response.text();\n\n    const wrappedJsonString = wrapBigNumbersAsStrings(text);\n\n    if (convertToCamelCase) {\n        return toCamelCase(JSON.parse(wrappedJsonString));\n    }\n\n    return JSON.parse(wrappedJsonString);\n};\n\n/** @internal */\nexport const proverRequest = async (\n    proverEndpoint: string,\n    method: 'inclusion' | 'new-address' | 'combined',\n    params: any = [],\n    log = false,\n    publicInputHash: BN | undefined = undefined,\n): Promise<CompressedProof> => {\n    let logMsg: string = '';\n\n    if (log) {\n        logMsg = `Proof generation for method:${method}`;\n        console.time(logMsg);\n    }\n\n    let body;\n    if (method === 'inclusion') {\n        body = JSON.stringify({\n            circuitType: 'inclusion',\n            stateTreeHeight: 26,\n            inputCompressedAccounts: params,\n            // publicInputHash: publicInputHash.toString('hex'),\n        });\n    } else if (method === 'new-address') {\n        body = JSON.stringify({\n            circuitType: 'non-inclusion',\n            addressTreeHeight: 26,\n            // publicInputHash: publicInputHash.toString('hex'),\n            newAddresses: params,\n        });\n    } else if (method === 'combined') {\n        body = JSON.stringify({\n            circuitType: 'combined',\n            // publicInputHash: publicInputHash.toString('hex'),\n            stateTreeHeight: 26,\n            addressTreeHeight: 26,\n            inputCompressedAccounts: params[0],\n            newAddresses: params[1],\n        });\n    }\n\n    const response = await fetch(`${proverEndpoint}/prove`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: body,\n    });\n\n    if (!response.ok) {\n        throw new Error(`Error fetching proof: ${response.statusText}`);\n    }\n    const data: any = await response.json();\n    const parsed = proofFromJsonStruct(data);\n    const compressedProof = negateAndCompressProof(parsed);\n\n    if (log) console.timeEnd(logMsg);\n\n    return compressedProof;\n};\n\nexport type NonInclusionMerkleProofInputs = {\n    root: BN;\n    value: BN;\n    leaf_lower_range_value: BN;\n    leaf_higher_range_value: BN;\n    nextIndex: BN;\n    merkle_proof_hashed_indexed_element_leaf: BN[];\n    index_hashed_indexed_element_leaf: BN;\n};\n\nexport type MerkleContextWithNewAddressProof = {\n    root: BN;\n    rootIndex: number;\n    value: BN;\n    leafLowerRangeValue: BN;\n    leafHigherRangeValue: BN;\n    nextIndex: BN;\n    merkleProofHashedIndexedElementLeaf: BN[];\n    indexHashedIndexedElementLeaf: BN;\n    merkleTree: PublicKey;\n    nullifierQueue: PublicKey;\n};\n\nexport type NonInclusionJsonStruct = {\n    root: string;\n    value: string;\n    pathIndex: number;\n    pathElements: string[];\n    leafLowerRangeValue: string;\n    leafHigherRangeValue: string;\n    nextIndex: number;\n};\n\nexport function convertMerkleProofsWithContextToHex(\n    merkleProofsWithContext: MerkleContextWithMerkleProof[],\n): HexInputsForProver[] {\n    const inputs: HexInputsForProver[] = [];\n\n    for (let i = 0; i < merkleProofsWithContext.length; i++) {\n        const input: HexInputsForProver = {\n            root: toHex(merkleProofsWithContext[i].root),\n            pathIndex: merkleProofsWithContext[i].leafIndex,\n            pathElements: merkleProofsWithContext[i].merkleProof.map(hex =>\n                toHex(hex),\n            ),\n            leaf: toHex(bn(merkleProofsWithContext[i].hash)),\n        };\n        inputs.push(input);\n    }\n\n    return inputs;\n}\n\nexport function convertNonInclusionMerkleProofInputsToHex(\n    nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[],\n): NonInclusionJsonStruct[] {\n    const inputs: NonInclusionJsonStruct[] = [];\n    for (let i = 0; i < nonInclusionMerkleProofInputs.length; i++) {\n        const input: NonInclusionJsonStruct = {\n            root: toHex(nonInclusionMerkleProofInputs[i].root),\n            value: toHex(nonInclusionMerkleProofInputs[i].value),\n            pathIndex:\n                nonInclusionMerkleProofInputs[\n                    i\n                ].indexHashedIndexedElementLeaf.toNumber(),\n            pathElements: nonInclusionMerkleProofInputs[\n                i\n            ].merkleProofHashedIndexedElementLeaf.map(hex => toHex(hex)),\n            nextIndex: nonInclusionMerkleProofInputs[i].nextIndex.toNumber(),\n            leafLowerRangeValue: toHex(\n                nonInclusionMerkleProofInputs[i].leafLowerRangeValue,\n            ),\n            leafHigherRangeValue: toHex(\n                nonInclusionMerkleProofInputs[i].leafHigherRangeValue,\n            ),\n        };\n        inputs.push(input);\n    }\n    return inputs;\n}\n\nfunction calculateTwoInputsHashChain(\n    hashesFirst: BN[],\n    hashesSecond: BN[],\n    lightWasm: LightWasm,\n): BN {\n    if (hashesFirst.length !== hashesSecond.length) {\n        throw new Error('Input lengths must match.');\n    }\n    if (hashesFirst.length === 0) {\n        return new BN(0);\n    }\n\n    let hashChain = lightWasm.poseidonHashBN([\n        hashesFirst[0].toString(),\n        hashesSecond[0].toString(),\n    ]);\n\n    for (let i = 1; i < hashesFirst.length; i++) {\n        hashChain = lightWasm.poseidonHashBN([\n            hashChain.toString(),\n            hashesFirst[i].toString(),\n            hashesSecond[i].toString(),\n        ]);\n    }\n\n    return hashChain;\n}\n\nexport function getPublicInputHash(\n    accountProofs: MerkleContextWithMerkleProof[],\n    accountHashes: BN254[],\n    newAddressProofs: MerkleContextWithNewAddressProof[],\n    lightWasm: LightWasm,\n): BN {\n    const accountRoots = accountProofs.map(x => x.root);\n    const inclusionHashChain = calculateTwoInputsHashChain(\n        accountRoots,\n        accountHashes,\n        lightWasm,\n    );\n\n    const newAddressHashes = newAddressProofs.map(x => x.value);\n    const newAddressRoots = newAddressProofs.map(x => x.root);\n    const nonInclusionHashChain = calculateTwoInputsHashChain(\n        newAddressRoots,\n        newAddressHashes,\n        lightWasm,\n    );\n\n    if (!nonInclusionHashChain.isZero()) {\n        return nonInclusionHashChain;\n    } else if (!inclusionHashChain.isZero()) {\n        return inclusionHashChain;\n    } else {\n        return calculateTwoInputsHashChain(\n            [inclusionHashChain],\n            [nonInclusionHashChain],\n            lightWasm,\n        );\n    }\n}\n\n/**\n * Get the queue for a given tree\n *\n * @param info - The active state tree addresses\n * @param tree - The tree to get the queue for\n * @returns The queue for the given tree, or undefined if not found\n */\nexport function getQueueForTree(\n    info: ActiveTreeBundle[],\n    tree: PublicKey,\n): PublicKey {\n    const index = info.findIndex(t => t.tree.equals(tree));\n    if (index === -1) {\n        throw new Error(\n            'No associated queue found for tree. Please set activeStateTreeInfo with latest Tree accounts. If you use custom state trees, set manually.',\n        );\n    }\n    if (!info[index].queue) {\n        throw new Error('Queue must not be null for state tree');\n    }\n    return info[index].queue;\n}\n\n/**\n * Get the tree for a given queue\n *\n * @param info - The active state tree addresses\n * @param queue - The queue to get the tree for\n * @returns The tree for the given queue, or undefined if not found\n */\nexport function getTreeForQueue(\n    info: ActiveTreeBundle[],\n    queue: PublicKey,\n): PublicKey {\n    const index = info.findIndex(q => q.queue?.equals(queue));\n    if (index === -1) {\n        throw new Error(\n            'No associated tree found for queue. Please set activeStateTreeInfo with latest Tree accounts. If you use custom state trees, set manually.',\n        );\n    }\n    if (!info[index].tree) {\n        throw new Error('Tree must not be null for state tree');\n    }\n    return info[index].tree;\n}\n\n/**\n * Get a random tree and queue from the active state tree addresses.\n *\n * Prevents write lock contention on state trees.\n *\n * @param info - The active state tree addresses\n * @returns A random tree and queue\n */\nexport function pickRandomTreeAndQueue(info: ActiveTreeBundle[]): {\n    tree: PublicKey;\n    queue: PublicKey;\n} {\n    const length = info.length;\n    const index = Math.floor(Math.random() * length);\n\n    if (!info[index].queue) {\n        throw new Error('Queue must not be null for state tree');\n    }\n    return {\n        tree: info[index].tree,\n        queue: info[index].queue,\n    };\n}\n\n/**\n *\n */\nexport class Rpc extends Connection implements CompressionApiInterface {\n    compressionApiEndpoint: string;\n    proverEndpoint: string;\n    activeStateTreeInfo: ActiveTreeBundle[] | null = null;\n\n    constructor(\n        endpoint: string,\n        compressionApiEndpoint: string,\n        proverEndpoint: string,\n        config?: ConnectionConfig,\n    ) {\n        super(endpoint, config || 'confirmed');\n        this.compressionApiEndpoint = compressionApiEndpoint;\n        this.proverEndpoint = proverEndpoint;\n    }\n\n    /**\n     * Manually set state tree addresses\n     */\n    setStateTreeInfo(info: ActiveTreeBundle[]): void {\n        this.activeStateTreeInfo = info;\n    }\n\n    /**\n     * Get the active state tree addresses from the cluster.\n     * If not already cached, fetches from the cluster.\n     */\n    async getCachedActiveStateTreeInfo(): Promise<ActiveTreeBundle[]> {\n        if (isLocalTest(this.rpcEndpoint)) {\n            return localTestActiveStateTreeInfo();\n        }\n\n        let info: ActiveTreeBundle[] | null = null;\n        if (!this.activeStateTreeInfo) {\n            const { mainnet, devnet } = defaultStateTreeLookupTables();\n            try {\n                info = await getLightStateTreeInfo({\n                    connection: this,\n                    stateTreeLookupTableAddress:\n                        mainnet[0].stateTreeLookupTable,\n                    nullifyTableAddress: mainnet[0].nullifyTable,\n                });\n                this.activeStateTreeInfo = info;\n            } catch {\n                info = await getLightStateTreeInfo({\n                    connection: this,\n                    stateTreeLookupTableAddress: devnet[0].stateTreeLookupTable,\n                    nullifyTableAddress: devnet[0].nullifyTable,\n                });\n                this.activeStateTreeInfo = info;\n            }\n        }\n        if (!this.activeStateTreeInfo) {\n            throw new Error(\n                `activeStateTreeInfo should not be null ${JSON.stringify(\n                    this.activeStateTreeInfo,\n                )}`,\n            );\n        }\n\n        return this.activeStateTreeInfo!;\n    }\n\n    /**\n     * Fetch the latest state tree addresses from the cluster.\n     */\n    async getLatestActiveStateTreeInfo(): Promise<ActiveTreeBundle[]> {\n        this.activeStateTreeInfo = null;\n        return await this.getCachedActiveStateTreeInfo();\n    }\n\n    /**\n     * Fetch the compressed account for the specified account address or hash\n     */\n    async getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null> {\n        if (!hash && !address) {\n            throw new Error('Either hash or address must be provided');\n        }\n        if (hash && address) {\n            throw new Error('Only one of hash or address must be provided');\n        }\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedAccount',\n            {\n                hash: hash ? encodeBN254toBase58(hash) : undefined,\n                address: address ? encodeBN254toBase58(address) : undefined,\n            },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(nullable(CompressedAccountResult)),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`,\n            );\n        }\n        if (res.result.value === null) {\n            return null;\n        }\n\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n        const associatedQueue = getQueueForTree(\n            activeStateTreeInfo,\n            res.result.value.tree!,\n        );\n        const item = res.result.value;\n        const account = createCompressedAccountWithMerkleContext(\n            createMerkleContext(\n                item.tree!,\n                associatedQueue,\n                item.hash.toArray('be', 32),\n                item.leafIndex,\n            ),\n            item.owner,\n            bn(item.lamports),\n            item.data ? parseAccountData(item.data) : undefined,\n            item.address || undefined,\n        );\n        return account;\n    }\n\n    /**\n     * Fetch the compressed balance for the specified account address or hash\n     */\n    async getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN> {\n        if (!hash && !address) {\n            throw new Error('Either hash or address must be provided');\n        }\n        if (hash && address) {\n            throw new Error('Only one of hash or address must be provided');\n        }\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedBalance',\n            {\n                hash: hash ? encodeBN254toBase58(hash) : undefined,\n                address: address ? encodeBN254toBase58(address) : undefined,\n            },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(NativeBalanceResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`,\n            );\n        }\n        if (res.result.value === null) {\n            return bn(0);\n        }\n\n        return bn(res.result.value);\n    }\n\n    /// TODO: validate that this is just for sol accounts\n    /**\n     * Fetch the total compressed balance for the specified owner public key\n     */\n    async getCompressedBalanceByOwner(owner: PublicKey): Promise<BN> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedBalanceByOwner',\n            { owner: owner.toBase58() },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(NativeBalanceResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed account ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            return bn(0);\n        }\n        return bn(res.result.value);\n    }\n\n    /**\n     * Fetch the latest merkle proof for the specified account hash from the\n     * cluster\n     */\n    async getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedAccountProof',\n            { hash: encodeBN254toBase58(hash) },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(MerkeProofResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proof for compressed account ${hash.toString()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proof for compressed account ${hash.toString()}`,\n            );\n        }\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n        const associatedQueue = getQueueForTree(\n            activeStateTreeInfo,\n            res.result.value.merkleTree,\n        );\n\n        const value: MerkleContextWithMerkleProof = {\n            hash: res.result.value.hash.toArray('be', 32),\n            merkleTree: res.result.value.merkleTree,\n            leafIndex: res.result.value.leafIndex,\n            merkleProof: res.result.value.proof,\n            nullifierQueue: associatedQueue, // TODO(photon): support nullifierQueue in response.\n            rootIndex: res.result.value.rootSeq % 2400,\n            root: res.result.value.root,\n        };\n        return value;\n    }\n\n    /**\n     * Fetch all the account info for multiple compressed accounts specified by\n     * an array of account hashes\n     */\n    async getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getMultipleCompressedAccounts',\n            { hashes: hashes.map(hash => encodeBN254toBase58(hash)) },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(MultipleCompressedAccountsResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n        const accounts: CompressedAccountWithMerkleContext[] = [];\n        res.result.value.items.map(item => {\n            const associatedQueue = getQueueForTree(\n                activeStateTreeInfo,\n                item.tree!,\n            );\n            const account = createCompressedAccountWithMerkleContext(\n                createMerkleContext(\n                    item.tree!,\n                    associatedQueue,\n                    item.hash.toArray('be', 32),\n                    item.leafIndex,\n                ),\n                item.owner,\n                bn(item.lamports),\n                item.data ? parseAccountData(item.data) : undefined,\n                item.address || undefined,\n            );\n            accounts.push(account);\n        });\n\n        return accounts.sort((a, b) => b.leafIndex - a.leafIndex);\n    }\n\n    /**\n     * Fetch the latest merkle proofs for multiple compressed accounts specified\n     * by an array account hashes\n     */\n    async getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getMultipleCompressedAccountProofs',\n            hashes.map(hash => encodeBN254toBase58(hash)),\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(array(MerkeProofResult)),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`,\n            );\n        }\n\n        const merkleProofs: MerkleContextWithMerkleProof[] = [];\n\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n        for (const proof of res.result.value) {\n            const associatedQueue = getQueueForTree(\n                activeStateTreeInfo,\n                proof.merkleTree,\n            );\n            const value: MerkleContextWithMerkleProof = {\n                hash: proof.hash.toArray('be', 32),\n                merkleTree: proof.merkleTree,\n                leafIndex: proof.leafIndex,\n                merkleProof: proof.proof,\n                nullifierQueue: associatedQueue,\n                rootIndex: proof.rootSeq % 2400,\n                root: proof.root,\n            };\n            merkleProofs.push(value);\n        }\n        return merkleProofs;\n    }\n\n    /**\n     * Fetch all the compressed accounts owned by the specified public key.\n     * Owner can be a program or user account\n     */\n    async getCompressedAccountsByOwner(\n        owner: PublicKey,\n        config?: GetCompressedAccountsByOwnerConfig | undefined,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedAccountsByOwner',\n            {\n                owner: owner.toBase58(),\n                filters: config?.filters || [],\n                dataSlice: config?.dataSlice,\n                cursor: config?.cursor,\n                limit: config?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(CompressedAccountsByOwnerResult),\n        );\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get info for compressed accounts owned by ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            return {\n                items: [],\n                cursor: null,\n            };\n        }\n        const accounts: CompressedAccountWithMerkleContext[] = [];\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n\n        res.result.value.items.map(item => {\n            const associatedQueue = getQueueForTree(\n                activeStateTreeInfo,\n                item.tree!,\n            );\n            const account = createCompressedAccountWithMerkleContext(\n                createMerkleContext(\n                    item.tree!,\n                    associatedQueue,\n                    item.hash.toArray('be', 32),\n                    item.leafIndex,\n                ),\n                item.owner,\n                bn(item.lamports),\n                item.data ? parseAccountData(item.data) : undefined,\n                item.address || undefined,\n            );\n\n            accounts.push(account);\n        });\n\n        return {\n            items: accounts.sort((a, b) => b.leafIndex - a.leafIndex),\n            cursor: res.result.value.cursor,\n        };\n    }\n\n    /**\n     * Fetch all the compressed token accounts owned by the specified public\n     * key. Owner can be a program or user account\n     */\n    async getCompressedTokenAccountsByOwner(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        if (!options) options = {};\n\n        return await getCompressedTokenAccountsByOwnerOrDelegate(\n            this,\n            owner,\n            options,\n            false,\n        );\n    }\n\n    /**\n     * Fetch all the compressed accounts delegated to the specified public key.\n     */\n    async getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        if (!options) options = {};\n\n        return await getCompressedTokenAccountsByOwnerOrDelegate(\n            this,\n            delegate,\n            options,\n            true,\n        );\n    }\n\n    /**\n     * Fetch the compressed token balance for the specified account hash\n     */\n    async getCompressedTokenAccountBalance(\n        hash: BN254,\n    ): Promise<{ amount: BN }> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenAccountBalance',\n            { hash: encodeBN254toBase58(hash) },\n        );\n        const res = create(unsafeRes, jsonRpcResultAndContext(BalanceResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get balance for compressed token account ${hash.toString()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get balance for compressed token account ${hash.toString()}`,\n            );\n        }\n\n        return { amount: bn(res.result.value.amount) };\n    }\n\n    /**\n     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.\n     *\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint. Returns without context.\n     */\n    async getCompressedTokenBalancesByOwner(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<TokenBalance[]>> {\n        if (!options) options = {};\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenBalancesByOwner',\n            {\n                owner: owner.toBase58(),\n                mint: options.mint?.toBase58(),\n                limit: options.limit?.toNumber(),\n                cursor: options.cursor,\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(TokenBalanceListResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n\n        const maybeFiltered = options.mint\n            ? res.result.value.tokenBalances.filter(\n                  tokenBalance =>\n                      tokenBalance.mint.toBase58() === options.mint!.toBase58(),\n              )\n            : res.result.value.tokenBalances;\n\n        return {\n            items: maybeFiltered,\n            cursor: res.result.value.cursor,\n        };\n    }\n\n    /**\n     * Fetch the compressed token balances owned by the specified public\n     * key. Paginated. Can filter by mint. Returns with context.\n     */\n    async getCompressedTokenBalancesByOwnerV2(\n        owner: PublicKey,\n        options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>> {\n        if (!options) options = {};\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedTokenBalancesByOwnerV2',\n            {\n                owner: owner.toBase58(),\n                mint: options.mint?.toBase58(),\n                limit: options.limit?.toNumber(),\n                cursor: options.cursor,\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(TokenBalanceListResultV2),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get compressed token balances for owner ${owner.toBase58()}`,\n            );\n        }\n\n        const maybeFiltered = options.mint\n            ? res.result.value.items.filter(\n                  tokenBalance =>\n                      tokenBalance.mint.toBase58() === options.mint!.toBase58(),\n              )\n            : res.result.value.items;\n\n        return {\n            context: res.result.context,\n            value: {\n                items: maybeFiltered,\n                cursor: res.result.value.cursor,\n            },\n        };\n    }\n\n    /**\n     * Returns confirmed compression signatures for transactions involving the specified\n     * account hash forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param hash queried account hash\n     */\n    async getCompressionSignaturesForAccount(\n        hash: BN254,\n    ): Promise<SignatureWithMetadata[]> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForAccount',\n            { hash: encodeBN254toBase58(hash) },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListResult),\n        );\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for compressed account ${hash.toString()}`,\n            );\n        }\n        return res.result.value.items;\n    }\n\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster. Return with\n     * CompressionInfo\n     */\n    async getTransactionWithCompressionInfo(\n        signature: string,\n    ): Promise<CompressedTransaction | null> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getTransactionWithCompressionInfo',\n            { signature },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResult(CompressedTransactionResult),\n        );\n\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n        }\n\n        if (res.result.transaction === null) return null;\n\n        const closedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[] = [];\n\n        const openedAccounts: {\n            account: CompressedAccountWithMerkleContext;\n            maybeTokenData: TokenData | null;\n        }[] = [];\n\n        const activeStateTreeInfo = await this.getCachedActiveStateTreeInfo();\n\n        res.result.compressionInfo.closedAccounts.map(item => {\n            closedAccounts.push(\n                buildCompressedAccountWithMaybeTokenData(\n                    item,\n                    activeStateTreeInfo,\n                ),\n            );\n        });\n        res.result.compressionInfo.openedAccounts.map(item => {\n            openedAccounts.push(\n                buildCompressedAccountWithMaybeTokenData(\n                    item,\n                    activeStateTreeInfo,\n                ),\n            );\n        });\n\n        const calculateTokenBalances = (\n            accounts: Array<{\n                account: CompressedAccountWithMerkleContext;\n                maybeTokenData: TokenData | null;\n            }>,\n        ):\n            | Array<{\n                  owner: PublicKey;\n                  mint: PublicKey;\n                  amount: BN;\n              }>\n            | undefined => {\n            const balances = Object.values(\n                accounts.reduce(\n                    (acc, { maybeTokenData }) => {\n                        if (maybeTokenData) {\n                            const { owner, mint, amount } = maybeTokenData;\n                            const key = `${owner.toBase58()}_${mint.toBase58()}`;\n                            if (key in acc) {\n                                acc[key].amount = acc[key].amount.add(amount);\n                            } else {\n                                acc[key] = { owner, mint, amount };\n                            }\n                        }\n                        return acc;\n                    },\n                    {} as {\n                        [key: string]: {\n                            owner: PublicKey;\n                            mint: PublicKey;\n                            amount: BN;\n                        };\n                    },\n                ),\n            );\n            return balances.length > 0 ? balances : undefined;\n        };\n\n        const preTokenBalances = calculateTokenBalances(closedAccounts);\n        const postTokenBalances = calculateTokenBalances(openedAccounts);\n\n        return {\n            compressionInfo: {\n                closedAccounts,\n                openedAccounts,\n                preTokenBalances,\n                postTokenBalances,\n            },\n            transaction: res.result.transaction,\n        };\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * address forward in time from genesis to the most recent confirmed block\n     *\n     * @param address queried compressed account address\n     */\n    async getCompressionSignaturesForAddress(\n        address: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForAddress',\n            {\n                address: address.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for address ${address.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for address ${address.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified account owner forward in time from genesis to the\n     * most recent confirmed block\n     *\n     * @param owner queried owner public key\n     */\n    async getCompressionSignaturesForOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForOwner',\n            {\n                owner: owner.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified token account owner forward in time from genesis to the most\n     * recent confirmed block\n     */\n    async getCompressionSignaturesForTokenOwner(\n        owner: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressionSignaturesForTokenOwner',\n            {\n                owner: owner.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(SignatureListWithCursorResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get signatures for owner ${owner.toBase58()}`,\n            );\n        }\n\n        return res.result.value;\n    }\n\n    /**\n     * Fetch the current indexer health status\n     */\n    async getIndexerHealth(): Promise<string> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getIndexerHealth',\n        );\n        const res = create(unsafeRes, jsonRpcResult(HealthResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get health');\n        }\n        return res.result;\n    }\n\n    /**\n     * Ensure that the Compression Indexer has already indexed the transaction\n     */\n    async confirmTransactionIndexed(slot: number): Promise<boolean> {\n        const startTime = Date.now();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const indexerSlot = await this.getIndexerSlot();\n\n            if (indexerSlot >= slot) {\n                return true;\n            }\n            if (Date.now() - startTime > 20000) {\n                // 20 seconds\n                throw new Error(\n                    'Timeout: Indexer slot did not reach the required slot within 20 seconds',\n                );\n            }\n            await new Promise(resolve => setTimeout(resolve, 200));\n        }\n    }\n\n    /**\n     * Fetch the current slot that the node is processing\n     */\n    async getIndexerSlot(): Promise<number> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getIndexerSlot',\n        );\n        const res = create(unsafeRes, jsonRpcResult(SlotResult));\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch all the compressed token holders for a given mint. Paginated.\n     */\n    async getCompressedMintTokenHolders(\n        mint: PublicKey,\n        options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getCompressedMintTokenHolders',\n            {\n                mint: mint.toBase58(),\n                cursor: options?.cursor,\n                limit: options?.limit?.toNumber(),\n            },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(CompressedMintTokenHoldersResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get mint token holders',\n            );\n        }\n\n        return res.result;\n    }\n    /**\n     * Fetch the latest compression signatures on the cluster. Results are\n     * paginated.\n     */\n    async getLatestCompressionSignatures(\n        cursor?: string,\n        limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getLatestCompressionSignatures',\n            { limit, cursor },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(LatestNonVotingSignaturesResultPaginated),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get latest non-voting signatures',\n            );\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch all non-voting signatures\n     */\n    async getLatestNonVotingSignatures(\n        limit?: number,\n        cursor?: string,\n    ): Promise<LatestNonVotingSignatures> {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getLatestNonVotingSignatures',\n            { limit, cursor },\n        );\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(LatestNonVotingSignaturesResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                'failed to get latest non-voting signatures',\n            );\n        }\n        return res.result;\n    }\n\n    /**\n     * Fetch the latest address proofs for new unique addresses specified by an\n     * array of addresses.\n     *\n     * the proof states that said address have not yet been created in\n     * respective address tree.\n     * @param addresses Array of BN254 new addresses\n     * @returns Array of validity proofs for new addresses\n     */\n    async getMultipleNewAddressProofs(addresses: BN254[]) {\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getMultipleNewAddressProofs',\n            addresses.map(address => encodeBN254toBase58(address)),\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(array(NewAddressProofResult)),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`,\n            );\n        }\n        if (res.result.value === null) {\n            throw new Error(\n                `failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`,\n            );\n        }\n\n        /// Creates proof for each address\n        const newAddressProofs: MerkleContextWithNewAddressProof[] = [];\n\n        for (const proof of res.result.value) {\n            const _proof: MerkleContextWithNewAddressProof = {\n                root: proof.root,\n                rootIndex: proof.rootSeq % 2400,\n                value: proof.address,\n                leafLowerRangeValue: proof.lowerRangeAddress,\n                leafHigherRangeValue: proof.higherRangeAddress,\n                nextIndex: bn(proof.nextIndex),\n                merkleProofHashedIndexedElementLeaf: proof.proof,\n                indexHashedIndexedElementLeaf: bn(proof.lowElementLeafIndex),\n                merkleTree: proof.merkleTree,\n                nullifierQueue: defaultTestStateTreeAccounts().addressQueue,\n            };\n            newAddressProofs.push(_proof);\n        }\n        return newAddressProofs;\n    }\n\n    /**\n     * Advanced usage of getValidityProof: fetches ZKP directly from a custom\n     * non-rpcprover. Note: This uses the proverEndpoint specified in the\n     * constructor. For normal usage, please use {@link getValidityProof}\n     * instead.\n     *\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses.\n     * @returns             validity proof with context\n     */\n    async getValidityProofDirect(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<CompressedProofWithContext> {\n        let validityProof: CompressedProofWithContext;\n\n        if (hashes.length === 0 && newAddresses.length === 0) {\n            throw new Error(\n                'Empty input. Provide hashes and/or new addresses.',\n            );\n        } else if (hashes.length > 0 && newAddresses.length === 0) {\n            /// inclusion\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            const inputs = convertMerkleProofsWithContextToHex(\n                merkleProofsWithContext,\n            );\n            // const lightWasm = await WasmFactory.getInstance();\n            // const publicInputHash = getPublicInputHash(\n            //     merkleProofsWithContext,\n            //     hashes,\n            //     [],\n            //     lightWasm,\n            // );\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'inclusion',\n                inputs,\n                false,\n                // publicInputHash,\n            );\n            validityProof = {\n                compressedProof,\n                roots: merkleProofsWithContext.map(proof => proof.root),\n                rootIndices: merkleProofsWithContext.map(\n                    proof => proof.rootIndex,\n                ),\n                leafIndices: merkleProofsWithContext.map(\n                    proof => proof.leafIndex,\n                ),\n                leaves: merkleProofsWithContext.map(proof => bn(proof.hash)),\n                merkleTrees: merkleProofsWithContext.map(\n                    proof => proof.merkleTree,\n                ),\n                nullifierQueues: merkleProofsWithContext.map(\n                    proof => proof.nullifierQueue,\n                ),\n            };\n        } else if (hashes.length === 0 && newAddresses.length > 0) {\n            /// new-address\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const inputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n            // const lightWasm = await WasmFactory.getInstance();\n            // const publicInputHash = getPublicInputHash(\n            //     [],\n            //     [],\n            //     newAddressProofs,\n            //     lightWasm,\n            // );\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'new-address',\n                inputs,\n                false,\n                // publicInputHash,\n            );\n\n            validityProof = {\n                compressedProof,\n                roots: newAddressProofs.map(proof => proof.root),\n                rootIndices: newAddressProofs.map(proof => proof.rootIndex),\n                leafIndices: newAddressProofs.map(proof =>\n                    proof.nextIndex.toNumber(),\n                ),\n                leaves: newAddressProofs.map(proof => bn(proof.value)),\n                merkleTrees: newAddressProofs.map(proof => proof.merkleTree),\n                nullifierQueues: newAddressProofs.map(\n                    proof => proof.nullifierQueue,\n                ),\n            };\n        } else if (hashes.length > 0 && newAddresses.length > 0) {\n            /// combined\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            const inputs = convertMerkleProofsWithContextToHex(\n                merkleProofsWithContext,\n            );\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const newAddressInputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n            // const lightWasm = await WasmFactory.getInstance();\n            // const publicInputHash = getPublicInputHash(\n            //     merkleProofsWithContext,\n            //     hashes,\n            //     newAddressProofs,\n            //     lightWasm,\n            // );\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'combined',\n                [inputs, newAddressInputs],\n                false,\n                // publicInputHash,\n            );\n\n            validityProof = {\n                compressedProof,\n                roots: merkleProofsWithContext\n                    .map(proof => proof.root)\n                    .concat(newAddressProofs.map(proof => proof.root)),\n                rootIndices: merkleProofsWithContext\n                    .map(proof => proof.rootIndex)\n                    .concat(newAddressProofs.map(proof => proof.rootIndex)),\n                leafIndices: merkleProofsWithContext\n                    .map(proof => proof.leafIndex)\n                    .concat(\n                        newAddressProofs.map(\n                            proof => proof.nextIndex.toNumber(), // TODO: support >32bit\n                        ),\n                    ),\n                leaves: merkleProofsWithContext\n                    .map(proof => bn(proof.hash))\n                    .concat(newAddressProofs.map(proof => bn(proof.value))),\n                merkleTrees: merkleProofsWithContext\n                    .map(proof => proof.merkleTree)\n                    .concat(newAddressProofs.map(proof => proof.merkleTree)),\n                nullifierQueues: merkleProofsWithContext\n                    .map(proof => proof.nullifierQueue)\n                    .concat(\n                        newAddressProofs.map(proof => proof.nullifierQueue),\n                    ),\n            };\n        } else throw new Error('Invalid input');\n\n        return validityProof;\n    }\n\n    /**\n     * @deprecated use {@link getValidityProofV0} instead.\n     *\n     *\n     *\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses.\n     * @returns             validity proof with context\n     */\n    async getValidityProof(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<CompressedProofWithContext> {\n        const accs = await this.getMultipleCompressedAccounts(hashes);\n        const trees = accs.map(acc => acc.merkleTree);\n        const queues = accs.map(acc => acc.nullifierQueue);\n\n        // TODO: add dynamic address tree support here\n        const defaultAddressTreePublicKey =\n            defaultTestStateTreeAccounts().addressTree;\n        const defaultAddressQueuePublicKey =\n            defaultTestStateTreeAccounts().addressQueue;\n\n        const formattedHashes = hashes.map((item, index) => {\n            return {\n                hash: item,\n                tree: trees[index],\n                queue: queues[index],\n            };\n        });\n\n        const formattedNewAddresses = newAddresses.map(item => {\n            return {\n                address: item,\n                tree: defaultAddressTreePublicKey,\n                queue: defaultAddressQueuePublicKey,\n            };\n        });\n\n        return this.getValidityProofV0(formattedHashes, formattedNewAddresses);\n    }\n\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.\n     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.\n     * @returns             validity proof with context\n     */\n    async getValidityProofV0(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<CompressedProofWithContext> {\n        const { value } = await this.getValidityProofAndRpcContext(\n            hashes,\n            newAddresses,\n        );\n        return value;\n    }\n\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses. Returns with context slot.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses. Optionally specify the\n     *                      tree and queue for each address. Default to public\n     *                      state tree/queue.\n     * @returns             validity proof with context\n     */\n    async getValidityProofAndRpcContext(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<WithContext<CompressedProofWithContext>> {\n        validateNumbersForProof(hashes.length, newAddresses.length);\n\n        const unsafeRes = await rpcRequest(\n            this.compressionApiEndpoint,\n            'getValidityProof',\n            {\n                hashes: hashes.map(({ hash }) => encodeBN254toBase58(hash)),\n                newAddressesWithTrees: newAddresses.map(\n                    ({ address, tree }) => ({\n                        address: encodeBN254toBase58(address),\n                        tree: tree.toBase58(),\n                    }),\n                ),\n            },\n        );\n\n        const res = create(\n            unsafeRes,\n            jsonRpcResultAndContext(ValidityProofResult),\n        );\n        if ('error' in res) {\n            throw new SolanaJSONRPCError(\n                res.error,\n                `failed to get ValidityProof for compressed accounts ${hashes.map(hash => hash.toString())}`,\n            );\n        }\n\n        const result = res.result.value;\n\n        if (result === null) {\n            throw new Error(\n                `failed to get ValidityProof for compressed accounts ${hashes.map(hash => hash.toString())}`,\n            );\n        }\n\n        const value: CompressedProofWithContext = {\n            compressedProof: result.compressedProof,\n            merkleTrees: result.merkleTrees,\n            leafIndices: result.leafIndices,\n            nullifierQueues: [\n                ...hashes.map(({ queue }) => queue),\n                ...newAddresses.map(({ queue }) => queue),\n            ],\n            rootIndices: result.rootIndices,\n            roots: result.roots,\n            leaves: result.leaves,\n        };\n        return { value, context: res.result.context };\n    }\n}\n","import { Signer } from '@solana/web3.js';\n\n/** @internal remove signer from signers if part of signers */\nexport function dedupeSigner(signer: Signer, signers: Signer[]): Signer[] {\n    if (signers.includes(signer)) {\n        return signers.filter(\n            s => s.publicKey.toString() !== signer.publicKey.toString(),\n        );\n    }\n    return signers;\n}\n","// TODO: Clean up\nexport enum UtxoErrorCode {\n    NEGATIVE_LAMPORTS = 'NEGATIVE_LAMPORTS',\n    NOT_U64 = 'NOT_U64',\n    BLINDING_EXCEEDS_FIELD_SIZE = 'BLINDING_EXCEEDS_FIELD_SIZE',\n}\n\nexport enum SelectInUtxosErrorCode {\n    FAILED_TO_FIND_UTXO_COMBINATION = 'FAILED_TO_FIND_UTXO_COMBINATION',\n    INVALID_NUMBER_OF_IN_UTXOS = 'INVALID_NUMBER_OF_IN_UTXOS',\n}\n\nexport enum CreateUtxoErrorCode {\n    OWNER_UNDEFINED = 'OWNER_UNDEFINED',\n    INVALID_OUTPUT_UTXO_LENGTH = 'INVALID_OUTPUT_UTXO_LENGTH',\n    UTXO_DATA_UNDEFINED = 'UTXO_DATA_UNDEFINED',\n}\n\nexport enum RpcErrorCode {\n    CONNECTION_UNDEFINED = 'CONNECTION_UNDEFINED',\n    RPC_PUBKEY_UNDEFINED = 'RPC_PUBKEY_UNDEFINED',\n    RPC_METHOD_NOT_IMPLEMENTED = 'RPC_METHOD_NOT_IMPLEMENTED',\n    RPC_INVALID = 'RPC_INVALID',\n}\n\nexport enum LookupTableErrorCode {\n    LOOK_UP_TABLE_UNDEFINED = 'LOOK_UP_TABLE_UNDEFINED',\n    LOOK_UP_TABLE_NOT_INITIALIZED = 'LOOK_UP_TABLE_NOT_INITIALIZED',\n}\n\nexport enum HashErrorCode {\n    NO_POSEIDON_HASHER_PROVIDED = 'NO_POSEIDON_HASHER_PROVIDED',\n}\n\nexport enum ProofErrorCode {\n    INVALID_PROOF = 'INVALID_PROOF',\n    PROOF_INPUT_UNDEFINED = 'PROOF_INPUT_UNDEFINED',\n    PROOF_GENERATION_FAILED = 'PROOF_GENERATION_FAILED',\n}\n\nexport enum MerkleTreeErrorCode {\n    MERKLE_TREE_NOT_INITIALIZED = 'MERKLE_TREE_NOT_INITIALIZED',\n    SOL_MERKLE_TREE_UNDEFINED = 'SOL_MERKLE_TREE_UNDEFINED',\n    MERKLE_TREE_UNDEFINED = 'MERKLE_TREE_UNDEFINED',\n    INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE = 'INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE',\n    MERKLE_TREE_INDEX_UNDEFINED = 'MERKLE_TREE_INDEX_UNDEFINED',\n    MERKLE_TREE_SET_SPACE_UNDEFINED = 'MERKLE_TREE_SET_SPACE_UNDEFINED',\n}\n\nexport enum UtilsErrorCode {\n    ACCOUNT_NAME_UNDEFINED_IN_IDL = 'ACCOUNT_NAME_UNDEFINED_IN_IDL',\n    PROPERTY_UNDEFINED = 'PROPERTY_UNDEFINED',\n    LOOK_UP_TABLE_CREATION_FAILED = 'LOOK_UP_TABLE_CREATION_FAILED',\n    UNSUPPORTED_ARCHITECTURE = 'UNSUPPORTED_ARCHITECTURE',\n    UNSUPPORTED_PLATFORM = 'UNSUPPORTED_PLATFORM',\n    ACCOUNTS_UNDEFINED = 'ACCOUNTS_UNDEFINED',\n    INVALID_NUMBER = 'INVALID_NUMBER',\n}\n\nclass MetaError extends Error {\n    code: string;\n    functionName: string;\n    codeMessage?: string;\n\n    constructor(code: string, functionName: string, codeMessage?: string) {\n        super(`${code}: ${codeMessage}`);\n        this.code = code;\n        this.functionName = functionName;\n        this.codeMessage = codeMessage;\n    }\n}\n\nexport class UtxoError extends MetaError {}\n\nexport class SelectInUtxosError extends MetaError {}\n\nexport class CreateUtxoError extends MetaError {}\n\nexport class RpcError extends MetaError {}\n\nexport class LookupTableError extends MetaError {}\n\nexport class HashError extends MetaError {}\n\nexport class ProofError extends MetaError {}\n\nexport class MerkleTreeError extends MetaError {}\n\nexport class UtilsError extends MetaError {}\n","import { LightWasm } from '../test-rpc/test-rpc';\nimport BN from 'bn.js';\nimport { bn } from '../../state';\nimport { HIGHEST_ADDRESS_PLUS_ONE } from '../../constants';\n\nexport class IndexedElement {\n    public index: number;\n    public value: BN;\n    public nextIndex: number;\n\n    constructor(index: number, value: BN, nextIndex: number) {\n        this.index = index;\n        this.value = value;\n        this.nextIndex = nextIndex;\n    }\n\n    public equals(other: IndexedElement): boolean {\n        return this.value.eq(other.value);\n    }\n\n    public compareTo(other: IndexedElement): number {\n        return this.value.cmp(other.value);\n    }\n\n    public hash(lightWasm: LightWasm, nextValue: BN): Uint8Array {\n        try {\n            const hash = lightWasm.poseidonHash([\n                bn(this.value.toArray('be', 32)).toString(),\n                bn(this.nextIndex).toString(),\n                bn(nextValue.toArray('be', 32)).toString(),\n            ]);\n            return hash;\n        } catch (error) {\n            throw new Error('Hashing failed');\n        }\n    }\n}\n\nexport class IndexedElementBundle {\n    public newLowElement: IndexedElement;\n    public newElement: IndexedElement;\n    public newElementNextValue: BN;\n\n    constructor(\n        newLowElement: IndexedElement,\n        newElement: IndexedElement,\n        newElementNextValue: BN,\n    ) {\n        this.newLowElement = newLowElement;\n        this.newElement = newElement;\n        this.newElementNextValue = newElementNextValue;\n    }\n}\n\n/**\n * This indexed array implementation mirrors the rust implementation of the\n * indexed merkle tree. It stores the elements of the indexed merkle tree.\n */\nexport class IndexedArray {\n    public elements: Array<IndexedElement>;\n    public currentNodeIndex: number;\n    public highestElementIndex: number;\n\n    constructor(\n        elements: Array<IndexedElement>,\n        currentNodeIndex: number,\n        highestElementIndex: number,\n    ) {\n        this.elements = elements;\n        this.currentNodeIndex = currentNodeIndex;\n        this.highestElementIndex = highestElementIndex;\n    }\n\n    public static default(): IndexedArray {\n        return new IndexedArray([new IndexedElement(0, bn(0), 0)], 0, 0);\n    }\n\n    public get(index: number): IndexedElement | undefined {\n        return this.elements[index];\n    }\n\n    public length(): number {\n        return Number(this.currentNodeIndex);\n    }\n\n    public isEmpty(): boolean {\n        return this.currentNodeIndex === 0;\n    }\n\n    public findElement(value: BN): IndexedElement | undefined {\n        return this.elements\n            .slice(0, this.length() + 1)\n            .find(node => node.value === value);\n    }\n\n    public init(): IndexedElementBundle {\n        try {\n            const init_value = HIGHEST_ADDRESS_PLUS_ONE;\n            return this.append(init_value);\n        } catch (error) {\n            throw new Error(`Failed to initialize IndexedArray: ${error}`);\n        }\n    }\n\n    /**\n     * Finds the index of the low element for the given `value` which should not be part of the array.\n     * Low element is the greatest element which still has a lower value than the provided one.\n     * Low elements are used in non-membership proofs.\n     */\n    public findLowElementIndex(value: BN): number | undefined {\n        // Try to find element whose next element is higher than the provided value.\n        for (let i = 0; i <= this.length(); i++) {\n            const node = this.elements[i];\n            if (\n                this.elements[node.nextIndex].value.gt(value) &&\n                node.value.lt(value)\n            ) {\n                return i;\n            } else if (node.value.eq(value)) {\n                throw new Error('Element already exists in the array');\n            }\n        }\n        // If no such element was found, it means that our value is going to be the greatest in the array.\n        // This means that the currently greatest element is going to be the low element of our value.\n        return this.highestElementIndex;\n    }\n\n    /**\n     * Returns the low element for the given value and the next value for that low element.\n     * Low element is the greatest element which still has lower value than the provided one.\n     * Low elements are used in non-membership proofs.\n     */\n    public findLowElement(\n        value: BN,\n    ): [IndexedElement | undefined, BN | undefined] {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) return [undefined, undefined];\n        const lowElement = this.elements[lowElementIndex];\n        return [lowElement, this.elements[lowElement.nextIndex].value];\n    }\n\n    // /**\n    //  * Returns the index of the low element for the given `value`, which should be the part of the array.\n    //  * Low element is the greatest element which still has lower value than the provided one.\n    //  * Low elements are used in non-membership proofs.\n    //  */\n    // public findLowElementIndexForExistingElement(\n    //     value: BN,\n    // ): number | undefined {\n    //     for (let i = 0; i <= this.length(); i++) {\n    //         const node = this.elements[i];\n    //         if (this.elements[node.nextIndex].value === value) {\n    //             return i;\n    //         }\n    //     }\n    //     return undefined;\n    // }\n\n    /**\n     * Returns the hash of the given element. That hash consists of:\n     * - The value of the given element.\n     * - The `nextIndex` of the given element.\n     * - The value of the element pointed by `nextIndex`.\n     */\n    public hashElement(\n        lightWasm: LightWasm,\n        index: number,\n    ): Uint8Array | undefined {\n        const element = this.elements[index];\n        if (!element) return undefined;\n        const nextElement = this.elements[element.nextIndex];\n        if (!nextElement) return undefined;\n\n        const hash = lightWasm.poseidonHash([\n            bn(element.value.toArray('be', 32)).toString(),\n            bn(element.nextIndex).toString(),\n            bn(nextElement.value.toArray('be', 32)).toString(),\n        ]);\n\n        return hash;\n    }\n\n    /**\n     * Appends a new element with the given value to the indexed array.\n     * It finds the low element index and uses it to append the new element correctly.\n     * @param value The value of the new element to append.\n     * @returns The new element and its low element after insertion.\n     */\n    public append(value: BN): IndexedElementBundle {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) {\n            throw new Error('Low element index not found.');\n        }\n        return this.appendWithLowElementIndex(lowElementIndex, value);\n    }\n\n    /**\n     * Appends a new element with the given value to the indexed array using a specific low element index.\n     * This method ensures the new element is placed correctly relative to the low element.\n     * @param lowElementIndex The index of the low element.\n     * @param value The value of the new element to append.\n     * @returns The new element and its updated low element.\n     */\n    public appendWithLowElementIndex(\n        lowElementIndex: number,\n        value: BN,\n    ): IndexedElementBundle {\n        const lowElement = this.elements[lowElementIndex];\n\n        if (lowElement.nextIndex === 0) {\n            if (value.lte(lowElement.value)) {\n                throw new Error(\n                    'New element value must be greater than the low element value.',\n                );\n            }\n        } else {\n            const nextElement = this.elements[lowElement.nextIndex];\n\n            if (value.lte(lowElement.value)) {\n                throw new Error(\n                    'New element value must be greater than the low element value.',\n                );\n            }\n\n            if (value.gte(nextElement.value)) {\n                throw new Error(\n                    'New element value must be less than the next element value.',\n                );\n            }\n        }\n\n        const newElementBundle = this.newElementWithLowElementIndex(\n            lowElementIndex,\n            value,\n        );\n\n        // If the old low element wasn't pointing to any element, it means that:\n        //\n        // * It used to be the highest element.\n        // * Our new element, which we are appending, is going the be the\n        //   highest element.\n        //\n        // Therefore, we need to save the new element index as the highest\n        // index.\n        if (lowElement.nextIndex === 0) {\n            this.highestElementIndex = newElementBundle.newElement.index;\n        }\n\n        // Insert new node.\n        this.currentNodeIndex = newElementBundle.newElement.index;\n        this.elements[this.length()] = newElementBundle.newElement;\n\n        // Update low element.\n        this.elements[lowElementIndex] = newElementBundle.newLowElement;\n\n        return newElementBundle;\n    }\n\n    /**\n     * Finds the lowest element in the array.\n     * @returns The lowest element or undefined if the array is empty.\n     */\n    public lowest(): IndexedElement | undefined {\n        return this.elements.length > 0 ? this.elements[0] : undefined;\n    }\n\n    /**\n     * Creates a new element with the specified value and updates the low element index accordingly.\n     * @param lowElementIndex The index of the low element.\n     * @param value The value for the new element.\n     * @returns A bundle containing the new element, the updated low element, and the value of the next element.\n     */\n    public newElementWithLowElementIndex(\n        lowElementIndex: number,\n        value: BN,\n    ): IndexedElementBundle {\n        const newLowElement = this.elements[lowElementIndex];\n\n        const newElementIndex = this.currentNodeIndex + 1;\n        const newElement = new IndexedElement(\n            newElementIndex,\n            value,\n            newLowElement.nextIndex,\n        );\n        newLowElement.nextIndex = newElementIndex;\n\n        const newElementNextValue = this.elements[newElement.nextIndex].value;\n\n        return new IndexedElementBundle(\n            newLowElement,\n            newElement,\n            newElementNextValue,\n        );\n    }\n\n    /**\n     * Creates a new element with the specified value by first finding the appropriate low element index.\n     * @param value The value for the new element.\n     * @returns A bundle containing the new element, the updated low element, and the value of the next element.\n     */\n    public newElement(value: BN): IndexedElementBundle {\n        const lowElementIndex = this.findLowElementIndex(value);\n        if (lowElementIndex === undefined) {\n            throw new Error('Low element index not found.');\n        }\n        return this.newElementWithLowElementIndex(lowElementIndex, value);\n    }\n}\n","import { LightWasm } from '../test-rpc/test-rpc';\n\nexport const DEFAULT_ZERO = '0';\n\n/**\n * @callback hashFunction\n * @param left Left leaf\n * @param right Right leaf\n */\n/**\n * Merkle tree\n */\nexport class MerkleTree {\n    /**\n     * Constructor\n     * @param {number} levels Number of levels in the tree\n     * @param {Array} [elements] Initial elements\n     * @param {Object} options\n     * @param {hashFunction} [options.hashFunction] Function used to hash 2 leaves\n     * @param [options.zeroElement] Value for non-existent leaves\n     */\n    levels: number;\n    capacity: number;\n    zeroElement;\n    _zeros: string[];\n    _layers: string[][];\n    _lightWasm: LightWasm;\n\n    constructor(\n        levels: number,\n        lightWasm: LightWasm,\n        elements: string[] = [],\n        { zeroElement = DEFAULT_ZERO } = {},\n    ) {\n        this.levels = levels;\n        this.capacity = 2 ** levels;\n        this.zeroElement = zeroElement;\n        this._lightWasm = lightWasm;\n        if (elements.length > this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this._zeros = [];\n        this._layers = [];\n        this._layers[0] = elements;\n        this._zeros[0] = this.zeroElement;\n\n        for (let i = 1; i <= levels; i++) {\n            this._zeros[i] = this._lightWasm.poseidonHashString([\n                this._zeros[i - 1],\n                this._zeros[i - 1],\n            ]);\n        }\n        this._rebuild();\n    }\n\n    _rebuild() {\n        for (let level = 1; level <= this.levels; level++) {\n            this._layers[level] = [];\n            for (\n                let i = 0;\n                i < Math.ceil(this._layers[level - 1].length / 2);\n                i++\n            ) {\n                this._layers[level][i] = this._lightWasm.poseidonHashString([\n                    this._layers[level - 1][i * 2],\n                    i * 2 + 1 < this._layers[level - 1].length\n                        ? this._layers[level - 1][i * 2 + 1]\n                        : this._zeros[level - 1],\n                ]);\n            }\n        }\n    }\n\n    /**\n     * Get tree root\n     * @returns {*}\n     */\n    root() {\n        return this._layers[this.levels].length > 0\n            ? this._layers[this.levels][0]\n            : this._zeros[this.levels];\n    }\n\n    /**\n     * Insert new element into the tree\n     * @param element Element to insert\n     */\n\n    insert(element: string) {\n        if (this._layers[0].length >= this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this.update(this._layers[0].length, element);\n    }\n\n    /**\n     * Insert multiple elements into the tree. Tree will be fully rebuilt during this operation.\n     * @param {Array} elements Elements to insert\n     */\n    bulkInsert(elements: string[]) {\n        if (this._layers[0].length + elements.length > this.capacity) {\n            throw new Error('Tree is full');\n        }\n        this._layers[0].push(...elements);\n        this._rebuild();\n    }\n\n    // TODO: update does not work debug\n    /**\n     * Change an element in the tree\n     * @param {number} index Index of element to change\n     * @param element Updated element value\n     */\n    update(index: number, element: string) {\n        // index 0 and 1 and element is the commitment hash\n        if (\n            isNaN(Number(index)) ||\n            index < 0 ||\n            index > this._layers[0].length ||\n            index >= this.capacity\n        ) {\n            throw new Error('Insert index out of bounds: ' + index);\n        }\n        this._layers[0][index] = element;\n        for (let level = 1; level <= this.levels; level++) {\n            index >>= 1;\n            this._layers[level][index] = this._lightWasm.poseidonHashString([\n                this._layers[level - 1][index * 2],\n                index * 2 + 1 < this._layers[level - 1].length\n                    ? this._layers[level - 1][index * 2 + 1]\n                    : this._zeros[level - 1],\n            ]);\n        }\n    }\n\n    /**\n     * Get merkle path to a leaf\n     * @param {number} index Leaf index to generate path for\n     * @returns {{pathElements: number[], pathIndex: number[]}} An object containing adjacent elements and left-right index\n     */\n    path(index: number) {\n        if (\n            isNaN(Number(index)) ||\n            index < 0 ||\n            index >= this._layers[0].length\n        ) {\n            throw new Error('Index out of bounds: ' + index);\n        }\n        const pathElements: string[] = [];\n        const pathIndices: number[] = [];\n        for (let level = 0; level < this.levels; level++) {\n            pathIndices[level] = index % 2;\n            pathElements[level] =\n                (index ^ 1) < this._layers[level].length\n                    ? this._layers[level][index ^ 1]\n                    : this._zeros[level];\n            index >>= 1;\n        }\n        return {\n            pathElements,\n            pathIndices,\n        };\n    }\n\n    /**\n     * Find an element in the tree\n     * @param element An element to find\n     * @param comparator A function that checks leaf value equality\n     * @returns {number} Index if element is found, otherwise -1\n     */\n    indexOf(\n        element: string,\n        comparator: ((element: string, el: string) => boolean) | null = null,\n    ) {\n        if (comparator) {\n            return this._layers[0].findIndex((el: string) =>\n                comparator(element, el),\n            );\n        } else {\n            return this._layers[0].indexOf(element);\n        }\n    }\n\n    /**\n     * Returns a copy of non-zero tree elements\n     * @returns {Object[]}\n     */\n    elements() {\n        return this._layers[0].slice();\n    }\n\n    /**\n     * Serialize entire tree state including intermediate layers into a plain object\n     * Deserializing it back will not require to recompute any hashes\n     * Elements are not converted to a plain type, this is responsibility of the caller\n     */\n    serialize() {\n        return {\n            levels: this.levels,\n            _zeros: this._zeros,\n            _layers: this._layers,\n        };\n    }\n\n    /**\n     * Deserialize data into a MerkleTree instance\n     * Make sure to provide the same hashFunction as was used in the source tree,\n     * otherwise the tree state will be invalid\n     *\n     * @param data\n     * @param hashFunction\n     * @returns {MerkleTree}\n     */\n    static deserialize(\n        data: any,\n        hashFunction: (left: string, right: string) => string,\n    ) {\n        const instance = Object.assign(Object.create(this.prototype), data);\n        instance._hash = hashFunction;\n        instance.capacity = 2 ** instance.levels;\n        instance.zeroElement = instance._zeros[0];\n        return instance;\n    }\n}\n","import {\n    GetVersionedTransactionConfig,\n    MessageV0,\n    ParsedMessageAccount,\n    ParsedTransactionWithMeta,\n    PublicKey,\n    VersionedTransactionResponse,\n} from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport {\n    COMPUTE_BUDGET_PATTERN,\n    defaultStaticAccountsStruct,\n    INSERT_INTO_QUEUES_DISCRIMINATOR,\n    INVOKE_CPI_DISCRIMINATOR,\n    INVOKE_DISCRIMINATOR,\n} from '../../constants';\nimport {\n    convertToPublicTransactionEvent,\n    decodeInstructionDataInvoke,\n    decodeInstructionDataInvokeCpi,\n    deserializeAppendNullifyCreateAddressInputsIndexer,\n} from '../../programs';\nimport { Rpc } from '../../rpc';\nimport { InstructionDataInvoke, PublicTransactionEvent } from '../../state';\nimport { decodePublicTransactionEvent } from '../../programs/layout';\nimport { Buffer } from 'buffer';\n\ntype Deserializer<T> = (data: Buffer, tx: ParsedTransactionWithMeta) => T;\n\n/**\n * @internal\n * Returns newest first.\n *\n * */\nexport async function getParsedEvents(\n    rpc: Rpc,\n): Promise<PublicTransactionEvent[]> {\n    const events: PublicTransactionEvent[] = [];\n\n    const { noopProgram, accountCompressionProgram } =\n        defaultStaticAccountsStruct();\n\n    const signatures = (\n        await rpc.getConfirmedSignaturesForAddress2(\n            accountCompressionProgram,\n            undefined,\n            'confirmed',\n        )\n    ).map(s => s.signature);\n    const txs = await rpc.getParsedTransactions(signatures, {\n        maxSupportedTransactionVersion: 0,\n        commitment: 'confirmed',\n    });\n\n    for (const txParsed of txs) {\n        if (!txParsed || !txParsed.transaction || !txParsed.meta) continue;\n\n        if (\n            !txParsed.meta.innerInstructions ||\n            txParsed.meta.innerInstructions.length == 0\n        ) {\n            continue;\n        }\n\n        const messageV0 = txParsed.transaction.message;\n        const accKeys = messageV0.accountKeys;\n\n        const allAccounts = accKeys.map(a => a.pubkey);\n        const dataVec: Uint8Array[] = [];\n\n        // get tx wth sig\n        const txRaw = await rpc.getTransaction(\n            txParsed.transaction.signatures[0],\n            {\n                commitment: 'confirmed',\n                maxSupportedTransactionVersion: 0,\n            },\n        );\n\n        for (const ix of txRaw?.transaction.message.compiledInstructions ||\n            []) {\n            if (ix.data && ix.data.length > 0) {\n                const decodedData = Uint8Array.from(ix.data);\n                if (\n                    decodedData.length === COMPUTE_BUDGET_PATTERN.length &&\n                    COMPUTE_BUDGET_PATTERN.every(\n                        (byte, idx) => byte === decodedData[idx],\n                    )\n                ) {\n                    continue;\n                }\n                dataVec.push(decodedData);\n            }\n        }\n\n        const groupedAccountVec: PublicKey[][] = [];\n\n        if (\n            txRaw!.meta!.innerInstructions &&\n            txRaw!.meta!.innerInstructions.length > 0\n        ) {\n            for (const innerGroup of txRaw!.meta!.innerInstructions) {\n                for (const ix of innerGroup.instructions) {\n                    const group = ix.accounts.map(\n                        (accountIdx: number) => allAccounts[accountIdx],\n                    );\n                    groupedAccountVec.push(group);\n                    if (ix.data && ix.data.length > 0) {\n                        const decodedData = bs58.decode(ix.data);\n                        dataVec.push(decodedData);\n                    }\n                }\n            }\n        }\n\n        const event = parseLightTransaction(dataVec, groupedAccountVec);\n        if (event) {\n            events.push(event);\n        }\n    }\n\n    if (events.length > 0) {\n        return events;\n    }\n\n    /// Filter by NOOP program\n    const transactionEvents = txs.filter(\n        (tx: ParsedTransactionWithMeta | null) => {\n            if (!tx) {\n                return false;\n            }\n            const accountKeys = tx.transaction.message.accountKeys;\n\n            const hasSplNoopAddress = accountKeys.some(\n                (item: ParsedMessageAccount) => {\n                    const itemStr =\n                        typeof item === 'string'\n                            ? item\n                            : item.pubkey.toBase58();\n                    return itemStr === noopProgram.toBase58();\n                },\n            );\n\n            return hasSplNoopAddress;\n        },\n    );\n\n    return parseEvents(transactionEvents, parsePublicTransactionEventWithIdl);\n}\n\nexport const parseEvents = <T>(\n    indexerEventsTransactions: (ParsedTransactionWithMeta | null)[],\n    deserializeFn: Deserializer<T>,\n): NonNullable<T>[] => {\n    const { noopProgram } = defaultStaticAccountsStruct();\n\n    const transactions: NonNullable<T>[] = [];\n    indexerEventsTransactions.forEach(tx => {\n        if (\n            !tx ||\n            !tx.meta ||\n            tx.meta.err ||\n            !tx.meta.innerInstructions ||\n            tx.meta.innerInstructions.length <= 0\n        ) {\n            return;\n        }\n\n        /// We only care about the very last inner instruction as it contains the\n        /// PublicTransactionEvent\n        tx.meta.innerInstructions.forEach(ix => {\n            if (ix.instructions.length > 0) {\n                const ixInner = ix.instructions[ix.instructions.length - 1];\n                // Type guard for partially parsed web3js types.\n                if (\n                    'data' in ixInner &&\n                    ixInner.data &&\n                    ixInner.programId.toBase58() === noopProgram.toBase58()\n                ) {\n                    const data = bs58.decode(ixInner.data);\n\n                    const decodedEvent = deserializeFn(Buffer.from(data), tx);\n\n                    if (decodedEvent !== null && decodedEvent !== undefined) {\n                        transactions.push(decodedEvent as NonNullable<T>);\n                    }\n                }\n            }\n        });\n    });\n\n    return transactions;\n};\n\n// TODO: make it type safe. have to reimplement the types from the IDL.\nexport const parsePublicTransactionEventWithIdl = (\n    data: Buffer,\n): PublicTransactionEvent | null => {\n    const numericData = Buffer.from(data.map(byte => byte));\n\n    try {\n        return decodePublicTransactionEvent(numericData);\n    } catch (error) {\n        console.error('Error deserializing event:', error);\n        return null;\n    }\n};\n\nexport function parseLightTransaction(\n    dataVec: Uint8Array[],\n    accountKeys: PublicKey[][],\n): PublicTransactionEvent | null | undefined {\n    let foundSystemInstruction = false;\n\n    let invokeData: InstructionDataInvoke | null = null;\n    let appendInputsData = null;\n\n    // First pass for system instructions\n    for (const data of dataVec) {\n        const discriminator = data.slice(0, 8);\n        const discriminatorStr = bs58.encode(discriminator);\n        const invokeDiscriminatorStr = bs58.encode(INVOKE_DISCRIMINATOR);\n        const invokeCpiDiscriminatorStr = bs58.encode(INVOKE_CPI_DISCRIMINATOR);\n        if (discriminatorStr === invokeDiscriminatorStr) {\n            invokeData = decodeInstructionDataInvoke(Buffer.from(data));\n            foundSystemInstruction = true;\n            break;\n        }\n        if (discriminatorStr == invokeCpiDiscriminatorStr) {\n            invokeData = decodeInstructionDataInvokeCpi(Buffer.from(data));\n            foundSystemInstruction = true;\n            break;\n        }\n    }\n    if (!foundSystemInstruction) return null;\n\n    for (const data of dataVec) {\n        const discriminator = data.slice(0, 8);\n        const discriminatorStr = bs58.encode(discriminator);\n        const insertIntoQueuesDiscriminatorStr = bs58.encode(\n            INSERT_INTO_QUEUES_DISCRIMINATOR,\n        );\n        if (discriminatorStr !== insertIntoQueuesDiscriminatorStr) {\n            console.log('discriminator does not match');\n        } else {\n            const dataSlice = data.slice(12);\n            appendInputsData =\n                deserializeAppendNullifyCreateAddressInputsIndexer(\n                    Buffer.from(dataSlice),\n                );\n        }\n    }\n\n    if (invokeData) {\n        return convertToPublicTransactionEvent(\n            appendInputsData,\n            accountKeys[accountKeys.length - 1],\n            invokeData,\n        );\n    } else {\n        return null;\n    }\n}\n","import { PublicKey } from '@solana/web3.js';\n\nimport BN from 'bn.js';\nimport { getParsedEvents } from './get-parsed-events';\nimport { defaultTestStateTreeAccounts } from '../../constants';\nimport { Rpc } from '../../rpc';\nimport {\n    CompressedAccountWithMerkleContext,\n    bn,\n    MerkleContext,\n    createCompressedAccountWithMerkleContext,\n} from '../../state';\n\nexport async function getCompressedAccountsByOwnerTest(\n    rpc: Rpc,\n    owner: PublicKey,\n) {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    const byOwner = unspentAccounts.filter(acc => acc.owner.equals(owner));\n    return byOwner;\n}\n\nexport async function getCompressedAccountByHashTest(\n    rpc: Rpc,\n    hash: BN,\n): Promise<CompressedAccountWithMerkleContext | undefined> {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    return unspentAccounts.find(acc => bn(acc.hash).eq(hash));\n}\n\nexport async function getMultipleCompressedAccountsByHashTest(\n    rpc: Rpc,\n    hashes: BN[],\n): Promise<CompressedAccountWithMerkleContext[]> {\n    const unspentAccounts = await getCompressedAccountsForTest(rpc);\n    return unspentAccounts\n        .filter(acc => hashes.some(hash => bn(acc.hash).eq(hash)))\n        .sort((a, b) => b.leafIndex - a.leafIndex);\n}\n\n/// Returns all unspent compressed accounts\nasync function getCompressedAccountsForTest(rpc: Rpc) {\n    const events = (await getParsedEvents(rpc)).reverse();\n    const allOutputAccounts: CompressedAccountWithMerkleContext[] = [];\n    const allInputAccountHashes: BN[] = [];\n\n    for (const event of events) {\n        for (\n            let index = 0;\n            index < event.outputCompressedAccounts.length;\n            index++\n        ) {\n            const account = event.outputCompressedAccounts[index];\n            const merkleContext: MerkleContext = {\n                merkleTree: defaultTestStateTreeAccounts().merkleTree,\n                nullifierQueue: defaultTestStateTreeAccounts().nullifierQueue,\n                hash: event.outputCompressedAccountHashes[index],\n                leafIndex: event.outputLeafIndices[index],\n            };\n            const withCtx: CompressedAccountWithMerkleContext =\n                createCompressedAccountWithMerkleContext(\n                    merkleContext,\n                    account.compressedAccount.owner,\n                    account.compressedAccount.lamports,\n                    account.compressedAccount.data ?? undefined,\n                    account.compressedAccount.address ?? undefined,\n                );\n            allOutputAccounts.push(withCtx);\n        }\n        for (\n            let index = 0;\n            index < event.inputCompressedAccountHashes.length;\n            index++\n        ) {\n            const hash = event.inputCompressedAccountHashes[index];\n            allInputAccountHashes.push(bn(hash));\n        }\n    }\n\n    const unspentAccounts = allOutputAccounts.filter(\n        account =>\n            !allInputAccountHashes.some(hash => hash.eq(bn(account.hash))),\n    );\n    unspentAccounts.sort((a, b) => b.leafIndex - a.leafIndex);\n\n    return unspentAccounts;\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { getParsedEvents } from './get-parsed-events';\nimport BN from 'bn.js';\nimport { defaultTestStateTreeAccounts } from '../../constants';\nimport { Rpc } from '../../rpc';\nimport { ParsedTokenAccount, WithCursor } from '../../rpc-interface';\nimport {\n    CompressedAccount,\n    PublicTransactionEvent,\n    MerkleContext,\n    createCompressedAccountWithMerkleContext,\n    bn,\n} from '../../state';\nimport {\n    struct,\n    publicKey,\n    u64,\n    option,\n    vecU8,\n    u8,\n    Layout,\n} from '@coral-xyz/borsh';\n\nconst tokenProgramId: PublicKey = new PublicKey(\n    'cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m',\n);\n\ntype TokenData = {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: BN;\n    delegate: PublicKey | null;\n    state: number;\n    tlv: Buffer | null;\n};\n\n// for test-rpc\nexport const TokenDataLayout: Layout<TokenData> = struct([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    option(publicKey(), 'delegate'),\n    u8('state'),\n    option(vecU8(), 'tlv'),\n]);\n\nexport type EventWithParsedTokenTlvData = {\n    inputCompressedAccountHashes: number[][];\n    outputCompressedAccounts: ParsedTokenAccount[];\n};\n/**\n * Manually parse the compressed token layout for a given compressed account.\n * @param compressedAccount - The compressed account\n * @returns The parsed token data\n */\nexport function parseTokenLayoutWithIdl(\n    compressedAccount: CompressedAccount,\n    programId: PublicKey = tokenProgramId,\n): TokenData | null {\n    if (compressedAccount.data === null) return null;\n\n    const { data } = compressedAccount.data;\n\n    if (data.length === 0) return null;\n    if (compressedAccount.owner.toBase58() !== programId.toBase58()) {\n        throw new Error(\n            `Invalid owner ${compressedAccount.owner.toBase58()} for token layout`,\n        );\n    }\n    return TokenDataLayout.decode(Buffer.from(data));\n}\n\n/**\n * parse compressed accounts of an event with token layout\n * @internal\n * TODO: refactor\n */\nasync function parseEventWithTokenTlvData(\n    event: PublicTransactionEvent,\n): Promise<EventWithParsedTokenTlvData> {\n    const pubkeyArray = event.pubkeyArray;\n\n    const outputHashes = event.outputCompressedAccountHashes;\n    const outputCompressedAccountsWithParsedTokenData: ParsedTokenAccount[] =\n        event.outputCompressedAccounts.map((compressedAccount, i) => {\n            const merkleContext: MerkleContext = {\n                merkleTree:\n                    pubkeyArray[\n                        event.outputCompressedAccounts[i].merkleTreeIndex\n                    ],\n                nullifierQueue:\n                    // FIXME: fix make dynamic\n                    defaultTestStateTreeAccounts().nullifierQueue,\n                hash: outputHashes[i],\n                leafIndex: event.outputLeafIndices[i],\n            };\n\n            if (!compressedAccount.compressedAccount.data)\n                throw new Error('No data');\n\n            const parsedData = parseTokenLayoutWithIdl(\n                compressedAccount.compressedAccount,\n            );\n\n            if (!parsedData) throw new Error('Invalid token data');\n\n            const withMerkleContext = createCompressedAccountWithMerkleContext(\n                merkleContext,\n                compressedAccount.compressedAccount.owner,\n                compressedAccount.compressedAccount.lamports,\n                compressedAccount.compressedAccount.data,\n                compressedAccount.compressedAccount.address ?? undefined,\n            );\n            return {\n                compressedAccount: withMerkleContext,\n                parsed: parsedData,\n            };\n        });\n\n    return {\n        inputCompressedAccountHashes: event.inputCompressedAccountHashes,\n        outputCompressedAccounts: outputCompressedAccountsWithParsedTokenData,\n    };\n}\n\n/**\n * Retrieves all compressed token accounts for a given mint and owner.\n *\n * Note: This function is intended for testing purposes only. For production, use rpc.getCompressedTokenAccounts.\n *\n * @param events    Public transaction events\n * @param owner     PublicKey of the token owner\n * @param mint      PublicKey of the token mint\n */\nexport async function getCompressedTokenAccounts(\n    events: PublicTransactionEvent[],\n): Promise<ParsedTokenAccount[]> {\n    const eventsWithParsedTokenTlvData: EventWithParsedTokenTlvData[] =\n        await Promise.all(\n            events.map(event => parseEventWithTokenTlvData(event)),\n        );\n\n    /// strip spent compressed accounts if an output compressed account of tx n is\n    /// an input compressed account of tx n+m, it is spent\n    const allOutCompressedAccounts = eventsWithParsedTokenTlvData.flatMap(\n        event => event.outputCompressedAccounts,\n    );\n    const allInCompressedAccountHashes = eventsWithParsedTokenTlvData.flatMap(\n        event => event.inputCompressedAccountHashes,\n    );\n    const unspentCompressedAccounts = allOutCompressedAccounts.filter(\n        outputCompressedAccount =>\n            !allInCompressedAccountHashes.some(hash => {\n                return (\n                    JSON.stringify(hash) ===\n                    JSON.stringify(\n                        outputCompressedAccount.compressedAccount.hash,\n                    )\n                );\n            }),\n    );\n\n    return unspentCompressedAccounts;\n}\n\n/** @internal */\nexport async function getCompressedTokenAccountsByOwnerTest(\n    rpc: Rpc,\n    owner: PublicKey,\n    mint: PublicKey,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const events = await getParsedEvents(rpc);\n    const compressedTokenAccounts = await getCompressedTokenAccounts(events);\n    const accounts = compressedTokenAccounts.filter(\n        acc => acc.parsed.owner.equals(owner) && acc.parsed.mint.equals(mint),\n    );\n    return {\n        items: accounts.sort(\n            (a, b) =>\n                b.compressedAccount.leafIndex - a.compressedAccount.leafIndex,\n        ),\n        cursor: null,\n    };\n}\n\nexport async function getCompressedTokenAccountsByDelegateTest(\n    rpc: Rpc,\n    delegate: PublicKey,\n    mint: PublicKey,\n): Promise<WithCursor<ParsedTokenAccount[]>> {\n    const events = await getParsedEvents(rpc);\n\n    const compressedTokenAccounts = await getCompressedTokenAccounts(events);\n    return {\n        items: compressedTokenAccounts.filter(\n            acc =>\n                acc.parsed.delegate?.equals(delegate) &&\n                acc.parsed.mint.equals(mint),\n        ),\n        cursor: null,\n    };\n}\n\nexport async function getCompressedTokenAccountByHashTest(\n    rpc: Rpc,\n    hash: BN,\n): Promise<ParsedTokenAccount> {\n    const events = await getParsedEvents(rpc);\n\n    const compressedTokenAccounts = await getCompressedTokenAccounts(events);\n\n    const filtered = compressedTokenAccounts.filter(acc =>\n        bn(acc.compressedAccount.hash).eq(hash),\n    );\n    if (filtered.length === 0) {\n        throw new Error('No compressed account found');\n    }\n    return filtered[0];\n}\n","import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport {\n    getCompressedAccountByHashTest,\n    getCompressedAccountsByOwnerTest,\n    getMultipleCompressedAccountsByHashTest,\n} from './get-compressed-accounts';\nimport {\n    getCompressedTokenAccountByHashTest,\n    getCompressedTokenAccountsByDelegateTest,\n    getCompressedTokenAccountsByOwnerTest,\n} from './get-compressed-token-accounts';\n\nimport { MerkleTree } from '../merkle-tree/merkle-tree';\nimport { getParsedEvents } from './get-parsed-events';\nimport {\n    defaultTestStateTreeAccounts,\n    localTestActiveStateTreeInfo,\n} from '../../constants';\nimport {\n    AddressWithTree,\n    CompressedMintTokenHolders,\n    CompressedTransaction,\n    GetCompressedAccountsByOwnerConfig,\n    PaginatedOptions,\n    HashWithTree,\n    LatestNonVotingSignatures,\n    LatestNonVotingSignaturesPaginated,\n    SignatureWithMetadata,\n    WithContext,\n    WithCursor,\n} from '../../rpc-interface';\nimport {\n    CompressedProofWithContext,\n    CompressionApiInterface,\n    GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ParsedTokenAccount,\n    TokenBalance,\n} from '../../rpc-interface';\nimport {\n    BN254,\n    CompressedAccountWithMerkleContext,\n    MerkleContextWithMerkleProof,\n    PublicTransactionEvent,\n    bn,\n} from '../../state';\nimport { IndexedArray } from '../merkle-tree';\nimport {\n    MerkleContextWithNewAddressProof,\n    convertMerkleProofsWithContextToHex,\n    convertNonInclusionMerkleProofInputsToHex,\n    proverRequest,\n} from '../../rpc';\nimport { ActiveTreeBundle } from '../../state/types';\n\nexport interface TestRpcConfig {\n    /**\n     * Address of the state tree to index. Default: public default test state\n     * tree.\n     */\n    merkleTreeAddress?: PublicKey;\n    /**\n     * Nullifier queue associated with merkleTreeAddress\n     */\n    nullifierQueueAddress?: PublicKey;\n    /**\n     * Depth of state tree. Defaults to the public default test state tree depth\n     */\n    depth?: number;\n    /**\n     * Log proof generation time\n     */\n    log?: boolean;\n    /**\n     * Address of the address tree to index. Default: public default test\n     * address tree.\n     */\n    addressTreeAddress?: PublicKey;\n    /**\n     * Address queue associated with addressTreeAddress\n     */\n    addressQueueAddress?: PublicKey;\n}\n\nexport type ClientSubscriptionId = number;\nexport interface LightWasm {\n    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;\n    poseidonHash(input: string[] | BN[]): Uint8Array;\n    poseidonHashString(input: string[] | BN[]): string;\n    poseidonHashBN(input: string[] | BN[]): BN;\n}\n\n/**\n * Returns a mock RPC instance for use in unit tests.\n *\n * @param lightWasm               Wasm hasher instance.\n * @param endpoint                RPC endpoint URL. Defaults to\n *                                'http://127.0.0.1:8899'.\n * @param proverEndpoint          Prover server endpoint URL. Defaults to\n *                                'http://localhost:3001'.\n * @param merkleTreeAddress       Address of the merkle tree to index. Defaults\n *                                to the public default test state tree.\n * @param nullifierQueueAddress   Optional address of the associated nullifier\n *                                queue.\n * @param depth                   Depth of the merkle tree.\n * @param log                     Log proof generation time.\n */\nexport async function getTestRpc(\n    lightWasm: LightWasm,\n    endpoint: string = 'http://127.0.0.1:8899',\n    compressionApiEndpoint: string = 'http://127.0.0.1:8784',\n    proverEndpoint: string = 'http://127.0.0.1:3001',\n    merkleTreeAddress?: PublicKey,\n    nullifierQueueAddress?: PublicKey,\n    depth?: number,\n    log = false,\n) {\n    const defaultAccounts = defaultTestStateTreeAccounts();\n\n    return new TestRpc(\n        endpoint,\n        lightWasm,\n        compressionApiEndpoint,\n        proverEndpoint,\n        undefined,\n        {\n            merkleTreeAddress: merkleTreeAddress || defaultAccounts.merkleTree,\n            nullifierQueueAddress:\n                nullifierQueueAddress || defaultAccounts.nullifierQueue,\n            depth: depth || defaultAccounts.merkleTreeHeight,\n            log,\n        },\n    );\n}\n/**\n * Simple mock rpc for unit tests that simulates the compression rpc interface.\n * Fetches, parses events and builds merkletree on-demand, i.e. it does not persist state.\n * Constraints:\n * - Can only index 1 merkletree\n * - Can only index up to 1000 transactions\n *\n * For advanced testing use photon: https://github.com/helius-labs/photon\n */\nexport class TestRpc extends Connection implements CompressionApiInterface {\n    compressionApiEndpoint: string;\n    proverEndpoint: string;\n    merkleTreeAddress: PublicKey;\n    nullifierQueueAddress: PublicKey;\n    addressTreeAddress: PublicKey;\n    addressQueueAddress: PublicKey;\n    lightWasm: LightWasm;\n    depth: number;\n    log = false;\n    activeStateTreeInfo: ActiveTreeBundle[] | null = null;\n\n    /**\n     * Establish a Compression-compatible JSON RPC mock-connection\n     *\n     * @param endpoint                  endpoint to the solana cluster (use for\n     *                                  localnet only)\n     * @param hasher                    light wasm hasher instance\n     * @param compressionApiEndpoint    Endpoint to the compression server.\n     * @param proverEndpoint            Endpoint to the prover server. defaults\n     *                                  to endpoint\n     * @param connectionConfig          Optional connection config\n     * @param testRpcConfig             Config for the mock rpc\n     */\n    constructor(\n        endpoint: string,\n        hasher: LightWasm,\n        compressionApiEndpoint: string,\n        proverEndpoint: string,\n        connectionConfig?: ConnectionConfig,\n        testRpcConfig?: TestRpcConfig,\n    ) {\n        super(endpoint, connectionConfig || 'confirmed');\n\n        this.compressionApiEndpoint = compressionApiEndpoint;\n        this.proverEndpoint = proverEndpoint;\n\n        const {\n            merkleTreeAddress,\n            nullifierQueueAddress,\n            depth,\n            log,\n            addressTreeAddress,\n            addressQueueAddress,\n        } = testRpcConfig ?? {};\n\n        const {\n            merkleTree,\n            nullifierQueue,\n            merkleTreeHeight,\n            addressQueue,\n            addressTree,\n        } = defaultTestStateTreeAccounts();\n\n        this.lightWasm = hasher;\n        this.merkleTreeAddress = merkleTreeAddress ?? merkleTree;\n        this.nullifierQueueAddress = nullifierQueueAddress ?? nullifierQueue;\n        this.addressTreeAddress = addressTreeAddress ?? addressTree;\n        this.addressQueueAddress = addressQueueAddress ?? addressQueue;\n        this.depth = depth ?? merkleTreeHeight;\n        this.log = log ?? false;\n    }\n\n    /**\n     * Manually set state tree addresses\n     */\n    setStateTreeInfo(info: ActiveTreeBundle[]): void {\n        this.activeStateTreeInfo = info;\n    }\n\n    /**\n     * Returns local test state trees.\n     */\n    async getCachedActiveStateTreeInfo(): Promise<ActiveTreeBundle[]> {\n        return localTestActiveStateTreeInfo();\n    }\n\n    /**\n     * Returns local test state trees.\n     */\n    async getLatestActiveStateTreeInfo(): Promise<ActiveTreeBundle[]> {\n        return localTestActiveStateTreeInfo();\n    }\n\n    /**\n     * Fetch the compressed account for the specified account hash\n     */\n    async getCompressedAccount(\n        address?: BN254,\n        hash?: BN254,\n    ): Promise<CompressedAccountWithMerkleContext | null> {\n        if (address) {\n            throw new Error('address is not supported in test-rpc');\n        }\n        if (!hash) {\n            throw new Error('hash is required');\n        }\n\n        const account = await getCompressedAccountByHashTest(this, hash);\n        return account ?? null;\n    }\n\n    /**\n     * Fetch the compressed balance for the specified account hash\n     */\n    async getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN> {\n        if (address) {\n            throw new Error('address is not supported in test-rpc');\n        }\n        if (!hash) {\n            throw new Error('hash is required');\n        }\n\n        const account = await getCompressedAccountByHashTest(this, hash);\n        if (!account) {\n            throw new Error('Account not found');\n        }\n        return bn(account.lamports);\n    }\n\n    /**\n     * Fetch the total compressed balance for the specified owner public key\n     */\n    async getCompressedBalanceByOwner(owner: PublicKey): Promise<BN> {\n        const accounts = await this.getCompressedAccountsByOwner(owner);\n        return accounts.items.reduce(\n            (acc, account) => acc.add(account.lamports),\n            bn(0),\n        );\n    }\n\n    /**\n     * Fetch the latest merkle proof for the specified account hash from the\n     * cluster\n     */\n    async getCompressedAccountProof(\n        hash: BN254,\n    ): Promise<MerkleContextWithMerkleProof> {\n        const proofs = await this.getMultipleCompressedAccountProofs([hash]);\n        return proofs[0];\n    }\n\n    /**\n     * Fetch all the account info for multiple compressed accounts specified by\n     * an array of account hashes\n     */\n    async getMultipleCompressedAccounts(\n        hashes: BN254[],\n    ): Promise<CompressedAccountWithMerkleContext[]> {\n        return await getMultipleCompressedAccountsByHashTest(this, hashes);\n    }\n    /**\n     * Ensure that the Compression Indexer has already indexed the transaction\n     */\n    async confirmTransactionIndexed(_slot: number): Promise<boolean> {\n        return true;\n    }\n    /**\n     * Fetch the latest merkle proofs for multiple compressed accounts specified\n     * by an array account hashes\n     */\n    async getMultipleCompressedAccountProofs(\n        hashes: BN254[],\n    ): Promise<MerkleContextWithMerkleProof[]> {\n        /// Build tree\n        const events: PublicTransactionEvent[] = await getParsedEvents(\n            this,\n        ).then(events => events.reverse());\n        const allLeaves: number[][] = [];\n        const allLeafIndices: number[] = [];\n        for (const event of events) {\n            for (\n                let index = 0;\n                index < event.outputCompressedAccounts.length;\n                index++\n            ) {\n                const hash = event.outputCompressedAccountHashes[index];\n\n                allLeaves.push(hash);\n                allLeafIndices.push(event.outputLeafIndices[index]);\n            }\n        }\n        const tree = new MerkleTree(\n            this.depth,\n            this.lightWasm,\n            allLeaves.map(leaf => bn(leaf).toString()),\n        );\n\n        /// create merkle proofs and assemble return type\n        const merkleProofs: MerkleContextWithMerkleProof[] = [];\n\n        for (let i = 0; i < hashes.length; i++) {\n            const leafIndex = tree.indexOf(hashes[i].toString());\n            const pathElements = tree.path(leafIndex).pathElements;\n            const bnPathElements = pathElements.map(value => bn(value));\n            const root = bn(tree.root());\n            const merkleProof: MerkleContextWithMerkleProof = {\n                hash: hashes[i].toArray('be', 32),\n                merkleTree: this.merkleTreeAddress,\n                leafIndex: leafIndex,\n                merkleProof: bnPathElements,\n                nullifierQueue: this.nullifierQueueAddress,\n                rootIndex: allLeaves.length,\n                root: root,\n            };\n            merkleProofs.push(merkleProof);\n        }\n\n        /// Validate\n        merkleProofs.forEach((proof, index) => {\n            const leafIndex = proof.leafIndex;\n            const computedHash = tree.elements()[leafIndex];\n            const hashArr = bn(computedHash).toArray('be', 32);\n            if (!hashArr.every((val, index) => val === proof.hash[index])) {\n                throw new Error(\n                    `Mismatch at index ${index}: expected ${proof.hash.toString()}, got ${hashArr.toString()}`,\n                );\n            }\n        });\n\n        return merkleProofs;\n    }\n\n    /**\n     * Fetch all the compressed accounts owned by the specified public key.\n     * Owner can be a program or user account\n     */\n    async getCompressedAccountsByOwner(\n        owner: PublicKey,\n        _config?: GetCompressedAccountsByOwnerConfig,\n    ): Promise<WithCursor<CompressedAccountWithMerkleContext[]>> {\n        const accounts = await getCompressedAccountsByOwnerTest(this, owner);\n        return {\n            items: accounts,\n            cursor: null,\n        };\n    }\n\n    /**\n     * Fetch the latest compression signatures on the cluster. Results are\n     * paginated.\n     */\n    async getLatestCompressionSignatures(\n        _cursor?: string,\n        _limit?: number,\n    ): Promise<LatestNonVotingSignaturesPaginated> {\n        throw new Error(\n            'getLatestNonVotingSignaturesWithContext not supported in test-rpc',\n        );\n    }\n    /**\n     * Fetch the latest non-voting signatures on the cluster. Results are\n     * not paginated.\n     */\n    async getLatestNonVotingSignatures(\n        _limit?: number,\n    ): Promise<LatestNonVotingSignatures> {\n        throw new Error(\n            'getLatestNonVotingSignaturesWithContext not supported in test-rpc',\n        );\n    }\n    /**\n     * Fetch all the compressed token accounts owned by the specified public\n     * key. Owner can be a program or user account\n     */\n    async getCompressedTokenAccountsByOwner(\n        owner: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        return await getCompressedTokenAccountsByOwnerTest(\n            this,\n            owner,\n            options!.mint!,\n        );\n    }\n\n    /**\n     * Fetch all the compressed accounts delegated to the specified public key.\n     */\n    async getCompressedTokenAccountsByDelegate(\n        delegate: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<ParsedTokenAccount[]>> {\n        return await getCompressedTokenAccountsByDelegateTest(\n            this,\n            delegate,\n            options.mint!,\n        );\n    }\n\n    /**\n     * Fetch the compressed token balance for the specified account hash\n     */\n    async getCompressedTokenAccountBalance(\n        hash: BN254,\n    ): Promise<{ amount: BN }> {\n        const account = await getCompressedTokenAccountByHashTest(this, hash);\n        return { amount: bn(account.parsed.amount) };\n    }\n\n    /**\n     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint.\n     */\n    async getCompressedTokenBalancesByOwner(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithCursor<{ balance: BN; mint: PublicKey }[]>> {\n        const accounts = await getCompressedTokenAccountsByOwnerTest(\n            this,\n            publicKey,\n            options.mint!,\n        );\n        return {\n            items: accounts.items.map(account => ({\n                balance: bn(account.parsed.amount),\n                mint: account.parsed.mint,\n            })),\n            cursor: null,\n        };\n    }\n\n    /**\n     * Fetch all the compressed token balances owned by the specified public\n     * key. Can filter by mint. Uses context.\n     */\n    async getCompressedTokenBalancesByOwnerV2(\n        publicKey: PublicKey,\n        options: GetCompressedTokenAccountsByOwnerOrDelegateOptions,\n    ): Promise<WithContext<WithCursor<TokenBalance[]>>> {\n        const accounts = await getCompressedTokenAccountsByOwnerTest(\n            this,\n            publicKey,\n            options.mint!,\n        );\n        return {\n            context: { slot: 1 },\n            value: {\n                items: accounts.items.map(account => ({\n                    balance: bn(account.parsed.amount),\n                    mint: account.parsed.mint,\n                })),\n                cursor: null,\n            },\n        };\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * account hash forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param hash queried account hash\n     */\n    async getCompressionSignaturesForAccount(\n        _hash: BN254,\n    ): Promise<SignatureWithMetadata[]> {\n        throw new Error(\n            'getCompressionSignaturesForAccount not implemented in test-rpc',\n        );\n    }\n\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster. Return with\n     * CompressionInfo\n     */\n    async getTransactionWithCompressionInfo(\n        _signature: string,\n    ): Promise<CompressedTransaction | null> {\n        throw new Error('getCompressedTransaction not implemented in test-rpc');\n    }\n\n    /**\n     * Returns confirmed signatures for transactions involving the specified\n     * address forward in time from genesis to the most recent confirmed\n     * block\n     *\n     * @param address queried compressed account address\n     */\n    async getCompressionSignaturesForAddress(\n        _address: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForAddress3 not implemented');\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified account owner forward in time from genesis to the\n     * most recent confirmed block\n     *\n     * @param owner queried owner public key\n     */\n    async getCompressionSignaturesForOwner(\n        _owner: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForOwner not implemented');\n    }\n\n    /**\n     * Returns confirmed signatures for compression transactions involving the\n     * specified token account owner forward in time from genesis to the most\n     * recent confirmed block\n     */\n    async getCompressionSignaturesForTokenOwner(\n        _owner: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithCursor<SignatureWithMetadata[]>> {\n        throw new Error('getSignaturesForTokenOwner not implemented');\n    }\n\n    /**\n     * Fetch the current indexer health status\n     */\n    async getIndexerHealth(): Promise<string> {\n        return 'ok';\n    }\n\n    /**\n     * Fetch the current slot that the node is processing\n     */\n    async getIndexerSlot(): Promise<number> {\n        return 1;\n    }\n\n    /**\n     * Fetch the latest address proofs for new unique addresses specified by an\n     * array of addresses.\n     *\n     * the proof states that said address have not yet been created in respective address tree.\n     * @param addresses Array of BN254 new addresses\n     * @returns Array of validity proofs for new addresses\n     */\n    async getMultipleNewAddressProofs(addresses: BN254[]) {\n        /// Build tree\n        const indexedArray = IndexedArray.default();\n        const allAddresses: BN[] = [];\n        indexedArray.init();\n        const hashes: BN[] = [];\n        // TODO(crank): add support for cranked address tree in 'allAddresses'.\n        // The Merkle tree root doesnt actually advance beyond init() unless we\n        // start emptying the address queue.\n        for (let i = 0; i < allAddresses.length; i++) {\n            indexedArray.append(bn(allAddresses[i]));\n        }\n        for (let i = 0; i < indexedArray.elements.length; i++) {\n            const hash = indexedArray.hashElement(this.lightWasm, i);\n            hashes.push(bn(hash!));\n        }\n        const tree = new MerkleTree(\n            this.depth,\n            this.lightWasm,\n            hashes.map(hash => bn(hash).toString()),\n        );\n\n        /// Creates proof for each address\n        const newAddressProofs: MerkleContextWithNewAddressProof[] = [];\n\n        for (let i = 0; i < addresses.length; i++) {\n            const [lowElement] = indexedArray.findLowElement(addresses[i]);\n            if (!lowElement) throw new Error('Address not found');\n\n            const leafIndex = lowElement.index;\n\n            const pathElements: string[] = tree.path(leafIndex).pathElements;\n            const bnPathElements = pathElements.map(value => bn(value));\n\n            const higherRangeValue = indexedArray.get(\n                lowElement.nextIndex,\n            )!.value;\n            const root = bn(tree.root());\n\n            const proof: MerkleContextWithNewAddressProof = {\n                root,\n                rootIndex: 3,\n                value: addresses[i],\n                leafLowerRangeValue: lowElement.value,\n                leafHigherRangeValue: higherRangeValue,\n                nextIndex: bn(lowElement.nextIndex),\n                merkleProofHashedIndexedElementLeaf: bnPathElements,\n                indexHashedIndexedElementLeaf: bn(lowElement.index),\n                merkleTree: this.addressTreeAddress,\n                nullifierQueue: this.addressQueueAddress,\n            };\n            newAddressProofs.push(proof);\n        }\n        return newAddressProofs;\n    }\n\n    async getCompressedMintTokenHolders(\n        _mint: PublicKey,\n        _options?: PaginatedOptions,\n    ): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>> {\n        throw new Error(\n            'getCompressedMintTokenHolders not implemented in test-rpc',\n        );\n    }\n\n    /**\n     * Advanced usage of getValidityProof: fetches ZKP directly from a custom\n     * non-rpcprover. Note: This uses the proverEndpoint specified in the\n     * constructor. For normal usage, please use {@link getValidityProof}\n     * instead.\n     *\n     * Note: Use RPC class for forested trees. TestRpc is only for custom\n     * testing purposes.\n     */\n    async getValidityProofDirect(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<CompressedProofWithContext> {\n        return this.getValidityProof(hashes, newAddresses);\n    }\n    /**\n     * @deprecated This method is not available for TestRpc. Please use\n     * {@link getValidityProof} instead.\n     */\n    async getValidityProofAndRpcContext(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<WithContext<CompressedProofWithContext>> {\n        if (newAddresses.some(address => !(address instanceof BN))) {\n            throw new Error('AddressWithTree is not supported in test-rpc');\n        }\n        return {\n            value: await this.getValidityProofV0(hashes, newAddresses),\n            context: { slot: 1 },\n        };\n    }\n    /**\n     * Fetch the latest validity proof for (1) compressed accounts specified by\n     * an array of account hashes. (2) new unique addresses specified by an\n     * array of addresses.\n     *\n     * Validity proofs prove the presence of compressed accounts in state trees\n     * and the non-existence of addresses in address trees, respectively. They\n     * enable verification without recomputing the merkle proof path, thus\n     * lowering verification and data costs.\n     *\n     * @param hashes        Array of BN254 hashes.\n     * @param newAddresses  Array of BN254 new addresses.\n     * @returns             validity proof with context\n     */\n    async getValidityProof(\n        hashes: BN254[] = [],\n        newAddresses: BN254[] = [],\n    ): Promise<CompressedProofWithContext> {\n        if (newAddresses.some(address => !(address instanceof BN))) {\n            throw new Error('AddressWithTree is not supported in test-rpc');\n        }\n        let validityProof: CompressedProofWithContext;\n\n        if (hashes.length === 0 && newAddresses.length === 0) {\n            throw new Error(\n                'Empty input. Provide hashes and/or new addresses.',\n            );\n        } else if (hashes.length > 0 && newAddresses.length === 0) {\n            /// inclusion\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            const inputs = convertMerkleProofsWithContextToHex(\n                merkleProofsWithContext,\n            );\n\n            // TODO: reactivate to handle proofs of height 32\n            // const publicInputHash = getPublicInputHash(\n            //     merkleProofsWithContext,\n            //     hashes,\n            //     [],\n            //     this.lightWasm,\n            // );\n\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'inclusion',\n                inputs,\n                this.log,\n                // publicInputHash,\n            );\n            validityProof = {\n                compressedProof,\n                roots: merkleProofsWithContext.map(proof => proof.root),\n                rootIndices: merkleProofsWithContext.map(\n                    proof => proof.rootIndex,\n                ),\n                leafIndices: merkleProofsWithContext.map(\n                    proof => proof.leafIndex,\n                ),\n                leaves: merkleProofsWithContext.map(proof => bn(proof.hash)),\n                merkleTrees: merkleProofsWithContext.map(\n                    proof => proof.merkleTree,\n                ),\n                nullifierQueues: merkleProofsWithContext.map(\n                    proof => proof.nullifierQueue,\n                ),\n            };\n        } else if (hashes.length === 0 && newAddresses.length > 0) {\n            /// new-address\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const inputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n            // const publicInputHash = getPublicInputHash(\n            //     [],\n            //     [],\n            //     newAddressProofs,\n            //     this.lightWasm,\n            // );\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'new-address',\n                inputs,\n                this.log,\n                // publicInputHash,\n            );\n\n            validityProof = {\n                compressedProof,\n                roots: newAddressProofs.map(proof => proof.root),\n                // TODO(crank): make dynamic to enable forester support in\n                // test-rpc.ts. Currently this is a static root because the\n                // address tree doesn't advance.\n                rootIndices: newAddressProofs.map(_ => 3),\n                leafIndices: newAddressProofs.map(proof =>\n                    proof.indexHashedIndexedElementLeaf.toNumber(),\n                ),\n                leaves: newAddressProofs.map(proof => bn(proof.value)),\n                merkleTrees: newAddressProofs.map(proof => proof.merkleTree),\n                nullifierQueues: newAddressProofs.map(\n                    proof => proof.nullifierQueue,\n                ),\n            };\n        } else if (hashes.length > 0 && newAddresses.length > 0) {\n            /// combined\n            const merkleProofsWithContext =\n                await this.getMultipleCompressedAccountProofs(hashes);\n            const inputs = convertMerkleProofsWithContextToHex(\n                merkleProofsWithContext,\n            );\n            const newAddressProofs: MerkleContextWithNewAddressProof[] =\n                await this.getMultipleNewAddressProofs(newAddresses);\n\n            const newAddressInputs =\n                convertNonInclusionMerkleProofInputsToHex(newAddressProofs);\n            // const publicInputHash = getPublicInputHash(\n            //     merkleProofsWithContext,\n            //     hashes,\n            //     newAddressProofs,\n            //     this.lightWasm,\n            // );\n            const compressedProof = await proverRequest(\n                this.proverEndpoint,\n                'combined',\n                [inputs, newAddressInputs],\n                this.log,\n                // publicInputHash,\n            );\n\n            validityProof = {\n                compressedProof,\n                roots: merkleProofsWithContext\n                    .map(proof => proof.root)\n                    .concat(newAddressProofs.map(proof => proof.root)),\n                rootIndices: merkleProofsWithContext\n                    .map(proof => proof.rootIndex)\n                    // TODO(crank): make dynamic to enable forester support in\n                    // test-rpc.ts. Currently this is a static root because the\n                    // address tree doesn't advance.\n                    .concat(newAddressProofs.map(_ => 3)),\n                leafIndices: merkleProofsWithContext\n                    .map(proof => proof.leafIndex)\n                    .concat(\n                        newAddressProofs.map(\n                            proof =>\n                                proof.indexHashedIndexedElementLeaf.toNumber(), // TODO: support >32bit\n                        ),\n                    ),\n                leaves: merkleProofsWithContext\n                    .map(proof => bn(proof.hash))\n                    .concat(newAddressProofs.map(proof => bn(proof.value))),\n                merkleTrees: merkleProofsWithContext\n                    .map(proof => proof.merkleTree)\n                    .concat(newAddressProofs.map(proof => proof.merkleTree)),\n                nullifierQueues: merkleProofsWithContext\n                    .map(proof => proof.nullifierQueue)\n                    .concat(\n                        newAddressProofs.map(proof => proof.nullifierQueue),\n                    ),\n            };\n        } else throw new Error('Invalid input');\n\n        return validityProof;\n    }\n\n    async getValidityProofV0(\n        hashes: HashWithTree[] = [],\n        newAddresses: AddressWithTree[] = [],\n    ): Promise<CompressedProofWithContext> {\n        /// TODO(swen): add support for custom trees\n        return this.getValidityProof(\n            hashes.map(hash => hash.hash),\n            newAddresses.map(address => address.address),\n        );\n    }\n}\n","import { Connection, Keypair, Signer } from '@solana/web3.js';\nimport { confirmTx } from '../utils/send-and-confirm';\nimport { Rpc } from '../rpc';\nimport BN from 'bn.js';\n\nlet c = 1;\n\nexport const ALICE = getTestKeypair(255);\nexport const BOB = getTestKeypair(254);\nexport const CHARLIE = getTestKeypair(253);\nexport const DAVE = getTestKeypair(252);\n\n/**\n * Deep comparison of two objects. Handles BN comparison correctly.\n *\n * @param ref - The reference object to compare.\n * @param val - The value object to compare.\n * @returns True if the objects are deeply equal, false otherwise.\n */\nexport function deepEqual(ref: any, val: any) {\n    if (typeof ref !== typeof val) {\n        console.log(`Type mismatch: ${typeof ref} !== ${typeof val}`);\n        return false;\n    }\n\n    if (ref instanceof BN && val instanceof BN) {\n        return ref.eq(val);\n    }\n\n    if (typeof ref === 'object' && ref !== null && val !== null) {\n        const refKeys = Object.keys(ref);\n        const valKeys = Object.keys(val);\n\n        if (refKeys.length !== valKeys.length) {\n            console.log(\n                `Key length mismatch: ${refKeys.length} !== ${valKeys.length}`,\n            );\n            return false;\n        }\n\n        for (const key of refKeys) {\n            if (!valKeys.includes(key)) {\n                console.log(`Key ${key} not found in value`);\n                return false;\n            }\n            if (!deepEqual(ref[key], val[key])) {\n                console.log(`Value mismatch at key ${key}`);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    if (ref !== val) {\n        console.log(`Value mismatch: ${ref} !== ${val}`);\n    }\n\n    return ref === val;\n}\n\n/**\n * Create a new account and airdrop lamports to it\n *\n * @param rpc       connection to use\n * @param lamports  amount of lamports to airdrop\n * @param counter   counter to use for generating the keypair.\n *                  If undefined or >255, generates random keypair.\n */\nexport async function newAccountWithLamports(\n    rpc: Rpc,\n    lamports = 1000000000,\n    counter: number | undefined = undefined,\n): Promise<Signer> {\n    /// get random keypair\n    if (counter === undefined || counter > 255) {\n        counter = 256;\n    }\n\n    const account = getTestKeypair(counter);\n    const sig = await rpc.requestAirdrop(account.publicKey, lamports);\n    await confirmTx(rpc, sig);\n    return account;\n}\n\nexport function getConnection(): Connection {\n    const url = 'http://127.0.0.1:8899';\n    const connection = new Connection(url, 'confirmed');\n    return connection;\n}\n\n/**\n * For use in tests.\n * Generate a unique keypair by passing in a counter <255. If no counter\n * is supplied, it uses and increments a global counter.\n * if counter > 255, generates random keypair\n */\nexport function getTestKeypair(\n    counter: number | undefined = undefined,\n): Keypair {\n    if (!counter) {\n        counter = c;\n        c++;\n    }\n    if (counter > 255) {\n        return Keypair.generate();\n    }\n    const seed = new Uint8Array(32);\n    seed[31] = counter; // le\n\n    return Keypair.fromSeed(seed);\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { describe, it, expect } = import.meta.vitest;\n\n    describe('getTestKeypair', () => {\n        it('should generate a keypair with a specific counter', () => {\n            const keypair = getTestKeypair(10);\n            const keypair2 = getTestKeypair(10);\n            expect(keypair).toEqual(keypair2);\n            expect(keypair).toBeInstanceOf(Keypair);\n            expect(keypair.publicKey).toBeDefined();\n            expect(keypair.secretKey).toBeDefined();\n        });\n\n        it('should generate random keypair if counter is greater than 255', () => {\n            const testFn = () => getTestKeypair(256);\n            const kp1 = testFn();\n            const kp2 = testFn();\n            expect(kp1).not.toEqual(kp2);\n        });\n\n        it('should increment the global counter if no counter is provided', () => {\n            const initialKeypair = getTestKeypair();\n            const nextKeypair = getTestKeypair();\n            const nextNextKeypair = getTestKeypair();\n            const nextNextNextKeypair = getTestKeypair(3);\n            expect(initialKeypair).not.toEqual(nextKeypair);\n            expect(nextKeypair).not.toEqual(nextNextKeypair);\n            expect(nextNextKeypair).toEqual(nextNextNextKeypair);\n        });\n    });\n}\n","export type LightSystemProgram = {\n    version: '1.2.0';\n    name: 'light_system_program';\n    constants: [\n        {\n            name: 'SOL_POOL_PDA_SEED';\n            type: 'bytes';\n            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]';\n        },\n    ];\n    instructions: [\n        {\n            name: 'initCpiContextAccount';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                },\n                {\n                    name: 'associatedMerkleTree';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [];\n        },\n        {\n            name: 'invoke';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ];\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['Merkle trees.'];\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ];\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'invokeCpi';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'invokingProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'invokeCpiWithReadOnly';\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'invokingProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'cpiContextAccount';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs';\n                    type: 'bytes';\n                },\n            ];\n        },\n        {\n            name: 'stubIdlBuild';\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ];\n            accounts: [\n                {\n                    name: 'feePayer';\n                    isMut: true;\n                    isSigner: true;\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ];\n                },\n                {\n                    name: 'authority';\n                    isMut: false;\n                    isSigner: true;\n                },\n                {\n                    name: 'registeredProgramPda';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'noopProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n                {\n                    name: 'accountCompressionAuthority';\n                    isMut: false;\n                    isSigner: false;\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ];\n                },\n                {\n                    name: 'accountCompressionProgram';\n                    isMut: false;\n                    isSigner: false;\n                    docs: ['Merkle trees.'];\n                },\n                {\n                    name: 'solPoolPda';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ];\n                },\n                {\n                    name: 'decompressionRecipient';\n                    isMut: true;\n                    isSigner: false;\n                    isOptional: true;\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ];\n                },\n                {\n                    name: 'systemProgram';\n                    isMut: false;\n                    isSigner: false;\n                },\n            ];\n            args: [\n                {\n                    name: 'inputs1';\n                    type: {\n                        defined: 'InstructionDataInvoke';\n                    };\n                },\n                {\n                    name: 'inputs2';\n                    type: {\n                        defined: 'InstructionDataInvokeCpi';\n                    };\n                },\n                {\n                    name: 'inputs3';\n                    type: {\n                        defined: 'PublicTransactionEvent';\n                    };\n                },\n            ];\n        },\n    ];\n    accounts: [\n        {\n            name: 'cpiContextAccount';\n            docs: [\n                'Collects instruction data without executing a compressed transaction.',\n                'Signer checks are performed on instruction data.',\n                'Collected instruction data is combined with the instruction data of the executing cpi,',\n                'and executed as a single transaction.',\n                'This enables to use input compressed accounts that are owned by multiple programs,',\n                'with one zero-knowledge proof.',\n            ];\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'feePayer';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'associatedMerkleTree';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'context';\n                        type: {\n                            vec: {\n                                defined: 'InstructionDataInvokeCpi';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n    ];\n    types: [\n        {\n            name: 'InstructionDataInvoke';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'NewAddressParamsPacked';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'seed';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'addressQueueAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex';\n                        type: 'u16';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleTreeIndex';\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedProof';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'a';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                    {\n                        name: 'b';\n                        type: {\n                            array: ['u8', 64];\n                        };\n                    },\n                    {\n                        name: 'c';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'InstructionDataInvokeCpi';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'proof';\n                        type: {\n                            option: {\n                                defined: 'CompressedProof';\n                            };\n                        };\n                    },\n                    {\n                        name: 'newAddressParams';\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked';\n                            };\n                        };\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext';\n                        type: {\n                            vec: {\n                                defined: 'PackedCompressedAccountWithMerkleContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContext';\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedCpiContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'setContext';\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'firstSetContext';\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ];\n                        type: 'bool';\n                    },\n                    {\n                        name: 'cpiContextAccountIndex';\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ];\n                        type: 'u8';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccount';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'owner';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'lamports';\n                        type: 'u64';\n                    },\n                    {\n                        name: 'address';\n                        type: {\n                            option: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'CompressedAccountData';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'discriminator';\n                        type: {\n                            array: ['u8', 8];\n                        };\n                    },\n                    {\n                        name: 'data';\n                        type: 'bytes';\n                    },\n                    {\n                        name: 'dataHash';\n                        type: {\n                            array: ['u8', 32];\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'compressedAccount';\n                        type: {\n                            defined: 'CompressedAccount';\n                        };\n                    },\n                    {\n                        name: 'merkleContext';\n                        type: {\n                            defined: 'PackedMerkleContext';\n                        };\n                    },\n                    {\n                        name: 'rootIndex';\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ];\n                        type: 'u16';\n                    },\n                    {\n                        name: 'readOnly';\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ];\n                        type: 'bool';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PackedMerkleContext';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'nullifierQueuePubkeyIndex';\n                        type: 'u8';\n                    },\n                    {\n                        name: 'leafIndex';\n                        type: 'u32';\n                    },\n                    {\n                        name: 'queueIndex';\n                        type: {\n                            option: {\n                                defined: 'QueueIndex';\n                            };\n                        };\n                    },\n                ];\n            };\n        },\n        {\n            name: 'QueueIndex';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'queueId';\n                        docs: ['Id of queue in queue account.'];\n                        type: 'u8';\n                    },\n                    {\n                        name: 'index';\n                        docs: ['Index of compressed account hash in queue.'];\n                        type: 'u16';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'MerkleTreeSequenceNumber';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'pubkey';\n                        type: 'publicKey';\n                    },\n                    {\n                        name: 'seq';\n                        type: 'u64';\n                    },\n                ];\n            };\n        },\n        {\n            name: 'PublicTransactionEvent';\n            type: {\n                kind: 'struct';\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes';\n                        type: {\n                            vec: {\n                                array: ['u8', 32];\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputCompressedAccounts';\n                        type: {\n                            vec: {\n                                defined: 'OutputCompressedAccountWithPackedContext';\n                            };\n                        };\n                    },\n                    {\n                        name: 'outputLeafIndices';\n                        type: {\n                            vec: 'u32';\n                        };\n                    },\n                    {\n                        name: 'sequenceNumbers';\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber';\n                            };\n                        };\n                    },\n                    {\n                        name: 'relayFee';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'isCompress';\n                        type: 'bool';\n                    },\n                    {\n                        name: 'compressOrDecompressLamports';\n                        type: {\n                            option: 'u64';\n                        };\n                    },\n                    {\n                        name: 'pubkeyArray';\n                        type: {\n                            vec: 'publicKey';\n                        };\n                    },\n                    {\n                        name: 'message';\n                        type: {\n                            option: 'bytes';\n                        };\n                    },\n                ];\n            };\n        },\n    ];\n    errors: [\n        {\n            code: 6000;\n            name: 'SumCheckFailed';\n            msg: 'Sum check failed';\n        },\n        {\n            code: 6001;\n            name: 'SignerCheckFailed';\n            msg: 'Signer check failed';\n        },\n        {\n            code: 6002;\n            name: 'CpiSignerCheckFailed';\n            msg: 'Cpi signer check failed';\n        },\n        {\n            code: 6003;\n            name: 'ComputeInputSumFailed';\n            msg: 'Computing input sum failed.';\n        },\n        {\n            code: 6004;\n            name: 'ComputeOutputSumFailed';\n            msg: 'Computing output sum failed.';\n        },\n        {\n            code: 6005;\n            name: 'ComputeRpcSumFailed';\n            msg: 'Computing rpc sum failed.';\n        },\n        {\n            code: 6006;\n            name: 'InvalidAddress';\n            msg: 'InvalidAddress';\n        },\n        {\n            code: 6007;\n            name: 'DeriveAddressError';\n            msg: 'DeriveAddressError';\n        },\n        {\n            code: 6008;\n            name: 'CompressedSolPdaUndefinedForCompressSol';\n            msg: 'CompressedSolPdaUndefinedForCompressSol';\n        },\n        {\n            code: 6009;\n            name: 'DeCompressLamportsUndefinedForCompressSol';\n            msg: 'DeCompressLamportsUndefinedForCompressSol';\n        },\n        {\n            code: 6010;\n            name: 'CompressedSolPdaUndefinedForDecompressSol';\n            msg: 'CompressedSolPdaUndefinedForDecompressSol';\n        },\n        {\n            code: 6011;\n            name: 'DeCompressLamportsUndefinedForDecompressSol';\n            msg: 'DeCompressLamportsUndefinedForDecompressSol';\n        },\n        {\n            code: 6012;\n            name: 'DecompressRecipientUndefinedForDecompressSol';\n            msg: 'DecompressRecipientUndefinedForDecompressSol';\n        },\n        {\n            code: 6013;\n            name: 'WriteAccessCheckFailed';\n            msg: 'WriteAccessCheckFailed';\n        },\n        {\n            code: 6014;\n            name: 'InvokingProgramNotProvided';\n            msg: 'InvokingProgramNotProvided';\n        },\n        {\n            code: 6015;\n            name: 'InvalidCapacity';\n            msg: 'InvalidCapacity';\n        },\n        {\n            code: 6016;\n            name: 'InvalidMerkleTreeOwner';\n            msg: 'InvalidMerkleTreeOwner';\n        },\n        {\n            code: 6017;\n            name: 'ProofIsNone';\n            msg: 'ProofIsNone';\n        },\n        {\n            code: 6018;\n            name: 'ProofIsSome';\n            msg: 'Proof is some but no input compressed accounts or new addresses provided.';\n        },\n        {\n            code: 6019;\n            name: 'EmptyInputs';\n            msg: 'EmptyInputs';\n        },\n        {\n            code: 6020;\n            name: 'CpiContextAccountUndefined';\n            msg: 'CpiContextAccountUndefined';\n        },\n        {\n            code: 6021;\n            name: 'CpiContextEmpty';\n            msg: 'CpiContextEmpty';\n        },\n        {\n            code: 6022;\n            name: 'CpiContextMissing';\n            msg: 'CpiContextMissing';\n        },\n        {\n            code: 6023;\n            name: 'DecompressionRecipientDefined';\n            msg: 'DecompressionRecipientDefined';\n        },\n        {\n            code: 6024;\n            name: 'SolPoolPdaDefined';\n            msg: 'SolPoolPdaDefined';\n        },\n        {\n            code: 6025;\n            name: 'AppendStateFailed';\n            msg: 'AppendStateFailed';\n        },\n        {\n            code: 6026;\n            name: 'InstructionNotCallable';\n            msg: 'The instruction is not callable';\n        },\n        {\n            code: 6027;\n            name: 'CpiContextFeePayerMismatch';\n            msg: 'CpiContextFeePayerMismatch';\n        },\n        {\n            code: 6028;\n            name: 'CpiContextAssociatedMerkleTreeMismatch';\n            msg: 'CpiContextAssociatedMerkleTreeMismatch';\n        },\n        {\n            code: 6029;\n            name: 'NoInputs';\n            msg: 'NoInputs';\n        },\n        {\n            code: 6030;\n            name: 'InputMerkleTreeIndicesNotInOrder';\n            msg: 'Input merkle tree indices are not in ascending order.';\n        },\n        {\n            code: 6031;\n            name: 'OutputMerkleTreeIndicesNotInOrder';\n            msg: 'Output merkle tree indices are not in ascending order.';\n        },\n        {\n            code: 6032;\n            name: 'OutputMerkleTreeNotUnique';\n        },\n        {\n            code: 6033;\n            name: 'DataFieldUndefined';\n        },\n        {\n            code: 6034;\n            name: 'ReadOnlyAddressAlreadyExists';\n        },\n        {\n            code: 6035;\n            name: 'ReadOnlyAccountDoesNotExist';\n        },\n        {\n            code: 6036;\n            name: 'HashChainInputsLenghtInconsistent';\n        },\n        {\n            code: 6037;\n            name: 'InvalidAddressTreeHeight';\n        },\n        {\n            code: 6038;\n            name: 'InvalidStateTreeHeight';\n        },\n    ];\n};\n\nexport const IDL: LightSystemProgram = {\n    version: '1.2.0',\n    name: 'light_system_program',\n    constants: [\n        {\n            name: 'SOL_POOL_PDA_SEED',\n            type: 'bytes',\n            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]',\n        },\n    ],\n    instructions: [\n        {\n            name: 'initCpiContextAccount',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                },\n                {\n                    name: 'associatedMerkleTree',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [],\n        },\n        {\n            name: 'invoke',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ],\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['Merkle trees.'],\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ],\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'invokeCpi',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'invokingProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'invokeCpiWithReadOnly',\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'invokingProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'cpiContextAccount',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'stubIdlBuild',\n            docs: [\n                'This function is a stub to allow Anchor to include the input types in',\n                'the IDL. It should not be included in production builds nor be called in',\n                'practice.',\n            ],\n            accounts: [\n                {\n                    name: 'feePayer',\n                    isMut: true,\n                    isSigner: true,\n                    docs: [\n                        'Fee payer needs to be mutable to pay rollover and protocol fees.',\n                    ],\n                },\n                {\n                    name: 'authority',\n                    isMut: false,\n                    isSigner: true,\n                },\n                {\n                    name: 'registeredProgramPda',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'noopProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n                {\n                    name: 'accountCompressionAuthority',\n                    isMut: false,\n                    isSigner: false,\n                    docs: [\n                        'This pda is used to invoke the account compression program.',\n                    ],\n                },\n                {\n                    name: 'accountCompressionProgram',\n                    isMut: false,\n                    isSigner: false,\n                    docs: ['Merkle trees.'],\n                },\n                {\n                    name: 'solPoolPda',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Sol pool pda is used to store the native sol that has been compressed.',\n                        \"It's only required when compressing or decompressing sol.\",\n                    ],\n                },\n                {\n                    name: 'decompressionRecipient',\n                    isMut: true,\n                    isSigner: false,\n                    isOptional: true,\n                    docs: [\n                        'Only needs to be provided for decompression as a recipient for the',\n                        'decompressed sol.',\n                        'Compressed sol originate from authority.',\n                    ],\n                },\n                {\n                    name: 'systemProgram',\n                    isMut: false,\n                    isSigner: false,\n                },\n            ],\n            args: [\n                {\n                    name: 'inputs1',\n                    type: {\n                        defined: 'InstructionDataInvoke',\n                    },\n                },\n                {\n                    name: 'inputs2',\n                    type: {\n                        defined: 'InstructionDataInvokeCpi',\n                    },\n                },\n                {\n                    name: 'inputs3',\n                    type: {\n                        defined: 'PublicTransactionEvent',\n                    },\n                },\n            ],\n        },\n    ],\n    accounts: [\n        {\n            name: 'cpiContextAccount',\n            docs: [\n                'Collects instruction data without executing a compressed transaction.',\n                'Signer checks are performed on instruction data.',\n                'Collected instruction data is combined with the instruction data of the executing cpi,',\n                'and executed as a single transaction.',\n                'This enables to use input compressed accounts that are owned by multiple programs,',\n                'with one zero-knowledge proof.',\n            ],\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'feePayer',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'associatedMerkleTree',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'context',\n                        type: {\n                            vec: {\n                                defined: 'InstructionDataInvokeCpi',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n    types: [\n        {\n            name: 'InstructionDataInvoke',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'NewAddressParamsPacked',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'seed',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'addressQueueAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeAccountIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'addressMerkleTreeRootIndex',\n                        type: 'u16',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'OutputCompressedAccountWithPackedContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleTreeIndex',\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedProof',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'a',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                    {\n                        name: 'b',\n                        type: {\n                            array: ['u8', 64],\n                        },\n                    },\n                    {\n                        name: 'c',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'InstructionDataInvokeCpi',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'proof',\n                        type: {\n                            option: {\n                                defined: 'CompressedProof',\n                            },\n                        },\n                    },\n                    {\n                        name: 'newAddressParams',\n                        type: {\n                            vec: {\n                                defined: 'NewAddressParamsPacked',\n                            },\n                        },\n                    },\n                    {\n                        name: 'inputCompressedAccountsWithMerkleContext',\n                        type: {\n                            vec: {\n                                defined:\n                                    'PackedCompressedAccountWithMerkleContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContext',\n                        type: {\n                            option: {\n                                defined: 'CompressedCpiContext',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedCpiContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'setContext',\n                        docs: [\n                            'Is set by the program that is invoking the CPI to signal that is should',\n                            'set the cpi context.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'firstSetContext',\n                        docs: [\n                            'Is set to wipe the cpi context since someone could have set it before',\n                            'with unrelated data.',\n                        ],\n                        type: 'bool',\n                    },\n                    {\n                        name: 'cpiContextAccountIndex',\n                        docs: [\n                            'Index of cpi context account in remaining accounts.',\n                        ],\n                        type: 'u8',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccount',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'owner',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'lamports',\n                        type: 'u64',\n                    },\n                    {\n                        name: 'address',\n                        type: {\n                            option: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: {\n                            option: {\n                                defined: 'CompressedAccountData',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'CompressedAccountData',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'discriminator',\n                        type: {\n                            array: ['u8', 8],\n                        },\n                    },\n                    {\n                        name: 'data',\n                        type: 'bytes',\n                    },\n                    {\n                        name: 'dataHash',\n                        type: {\n                            array: ['u8', 32],\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedCompressedAccountWithMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'compressedAccount',\n                        type: {\n                            defined: 'CompressedAccount',\n                        },\n                    },\n                    {\n                        name: 'merkleContext',\n                        type: {\n                            defined: 'PackedMerkleContext',\n                        },\n                    },\n                    {\n                        name: 'rootIndex',\n                        docs: [\n                            'Index of root used in inclusion validity proof.',\n                        ],\n                        type: 'u16',\n                    },\n                    {\n                        name: 'readOnly',\n                        docs: [\n                            'Placeholder to mark accounts read-only unimplemented set to false.',\n                        ],\n                        type: 'bool',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PackedMerkleContext',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'merkleTreePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'nullifierQueuePubkeyIndex',\n                        type: 'u8',\n                    },\n                    {\n                        name: 'leafIndex',\n                        type: 'u32',\n                    },\n                    {\n                        name: 'queueIndex',\n                        type: {\n                            option: {\n                                defined: 'QueueIndex',\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        {\n            name: 'QueueIndex',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'queueId',\n                        docs: ['Id of queue in queue account.'],\n                        type: 'u8',\n                    },\n                    {\n                        name: 'index',\n                        docs: ['Index of compressed account hash in queue.'],\n                        type: 'u16',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'MerkleTreeSequenceNumber',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'pubkey',\n                        type: 'publicKey',\n                    },\n                    {\n                        name: 'seq',\n                        type: 'u64',\n                    },\n                ],\n            },\n        },\n        {\n            name: 'PublicTransactionEvent',\n            type: {\n                kind: 'struct',\n                fields: [\n                    {\n                        name: 'inputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccountHashes',\n                        type: {\n                            vec: {\n                                array: ['u8', 32],\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputCompressedAccounts',\n                        type: {\n                            vec: {\n                                defined:\n                                    'OutputCompressedAccountWithPackedContext',\n                            },\n                        },\n                    },\n                    {\n                        name: 'outputLeafIndices',\n                        type: {\n                            vec: 'u32',\n                        },\n                    },\n                    {\n                        name: 'sequenceNumbers',\n                        type: {\n                            vec: {\n                                defined: 'MerkleTreeSequenceNumber',\n                            },\n                        },\n                    },\n                    {\n                        name: 'relayFee',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'isCompress',\n                        type: 'bool',\n                    },\n                    {\n                        name: 'compressOrDecompressLamports',\n                        type: {\n                            option: 'u64',\n                        },\n                    },\n                    {\n                        name: 'pubkeyArray',\n                        type: {\n                            vec: 'publicKey',\n                        },\n                    },\n                    {\n                        name: 'message',\n                        type: {\n                            option: 'bytes',\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n    errors: [\n        {\n            code: 6000,\n            name: 'SumCheckFailed',\n            msg: 'Sum check failed',\n        },\n        {\n            code: 6001,\n            name: 'SignerCheckFailed',\n            msg: 'Signer check failed',\n        },\n        {\n            code: 6002,\n            name: 'CpiSignerCheckFailed',\n            msg: 'Cpi signer check failed',\n        },\n        {\n            code: 6003,\n            name: 'ComputeInputSumFailed',\n            msg: 'Computing input sum failed.',\n        },\n        {\n            code: 6004,\n            name: 'ComputeOutputSumFailed',\n            msg: 'Computing output sum failed.',\n        },\n        {\n            code: 6005,\n            name: 'ComputeRpcSumFailed',\n            msg: 'Computing rpc sum failed.',\n        },\n        {\n            code: 6006,\n            name: 'InvalidAddress',\n            msg: 'InvalidAddress',\n        },\n        {\n            code: 6007,\n            name: 'DeriveAddressError',\n            msg: 'DeriveAddressError',\n        },\n        {\n            code: 6008,\n            name: 'CompressedSolPdaUndefinedForCompressSol',\n            msg: 'CompressedSolPdaUndefinedForCompressSol',\n        },\n        {\n            code: 6009,\n            name: 'DeCompressLamportsUndefinedForCompressSol',\n            msg: 'DeCompressLamportsUndefinedForCompressSol',\n        },\n        {\n            code: 6010,\n            name: 'CompressedSolPdaUndefinedForDecompressSol',\n            msg: 'CompressedSolPdaUndefinedForDecompressSol',\n        },\n        {\n            code: 6011,\n            name: 'DeCompressLamportsUndefinedForDecompressSol',\n            msg: 'DeCompressLamportsUndefinedForDecompressSol',\n        },\n        {\n            code: 6012,\n            name: 'DecompressRecipientUndefinedForDecompressSol',\n            msg: 'DecompressRecipientUndefinedForDecompressSol',\n        },\n        {\n            code: 6013,\n            name: 'WriteAccessCheckFailed',\n            msg: 'WriteAccessCheckFailed',\n        },\n        {\n            code: 6014,\n            name: 'InvokingProgramNotProvided',\n            msg: 'InvokingProgramNotProvided',\n        },\n        {\n            code: 6015,\n            name: 'InvalidCapacity',\n            msg: 'InvalidCapacity',\n        },\n        {\n            code: 6016,\n            name: 'InvalidMerkleTreeOwner',\n            msg: 'InvalidMerkleTreeOwner',\n        },\n        {\n            code: 6017,\n            name: 'ProofIsNone',\n            msg: 'ProofIsNone',\n        },\n        {\n            code: 6018,\n            name: 'ProofIsSome',\n            msg: 'Proof is some but no input compressed accounts or new addresses provided.',\n        },\n        {\n            code: 6019,\n            name: 'EmptyInputs',\n            msg: 'EmptyInputs',\n        },\n        {\n            code: 6020,\n            name: 'CpiContextAccountUndefined',\n            msg: 'CpiContextAccountUndefined',\n        },\n        {\n            code: 6021,\n            name: 'CpiContextEmpty',\n            msg: 'CpiContextEmpty',\n        },\n        {\n            code: 6022,\n            name: 'CpiContextMissing',\n            msg: 'CpiContextMissing',\n        },\n        {\n            code: 6023,\n            name: 'DecompressionRecipientDefined',\n            msg: 'DecompressionRecipientDefined',\n        },\n        {\n            code: 6024,\n            name: 'SolPoolPdaDefined',\n            msg: 'SolPoolPdaDefined',\n        },\n        {\n            code: 6025,\n            name: 'AppendStateFailed',\n            msg: 'AppendStateFailed',\n        },\n        {\n            code: 6026,\n            name: 'InstructionNotCallable',\n            msg: 'The instruction is not callable',\n        },\n        {\n            code: 6027,\n            name: 'CpiContextFeePayerMismatch',\n            msg: 'CpiContextFeePayerMismatch',\n        },\n        {\n            code: 6028,\n            name: 'CpiContextAssociatedMerkleTreeMismatch',\n            msg: 'CpiContextAssociatedMerkleTreeMismatch',\n        },\n        {\n            code: 6029,\n            name: 'NoInputs',\n            msg: 'NoInputs',\n        },\n        {\n            code: 6030,\n            name: 'InputMerkleTreeIndicesNotInOrder',\n            msg: 'Input merkle tree indices are not in ascending order.',\n        },\n        {\n            code: 6031,\n            name: 'OutputMerkleTreeIndicesNotInOrder',\n            msg: 'Output merkle tree indices are not in ascending order.',\n        },\n        {\n            code: 6032,\n            name: 'OutputMerkleTreeNotUnique',\n        },\n        {\n            code: 6033,\n            name: 'DataFieldUndefined',\n        },\n        {\n            code: 6034,\n            name: 'ReadOnlyAddressAlreadyExists',\n        },\n        {\n            code: 6035,\n            name: 'ReadOnlyAccountDoesNotExist',\n        },\n        {\n            code: 6036,\n            name: 'HashChainInputsLenghtInconsistent',\n        },\n        {\n            code: 6037,\n            name: 'InvalidAddressTreeHeight',\n        },\n        {\n            code: 6038,\n            name: 'InvalidStateTreeHeight',\n        },\n    ],\n};\n","/**\n * @param targetLamports - Target priority fee in lamports\n * @param computeUnits - Expected compute units used by the transaction\n * @returns microLamports per compute unit (use in\n * `ComputeBudgetProgram.setComputeUnitPrice`)\n */\nexport function calculateComputeUnitPrice(\n    targetLamports: number,\n    computeUnits: number,\n): number {\n    return Math.ceil((targetLamports * 1_000_000) / computeUnits);\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\n\nimport { LightSystemProgram } from '../programs';\nimport { pickRandomTreeAndQueue, Rpc } from '../rpc';\nimport { buildAndSignTx, sendAndConfirmTx } from '../utils';\nimport BN from 'bn.js';\n\n/**\n * Compress lamports to a solana address\n *\n * @param rpc             RPC to use\n * @param payer           Payer of the transaction and initialization fees\n * @param lamports        Amount of lamports to compress\n * @param toAddress       Address of the recipient compressed account\n * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.\n * @param confirmOptions  Options for confirming the transaction\n *\n * @return Transaction signature\n */\n/// TODO: add multisig support\n/// TODO: add support for payer != owner\nexport async function compress(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    toAddress: PublicKey,\n    outputStateTree?: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    if (!outputStateTree) {\n        const stateTreeInfo = await rpc.getCachedActiveStateTreeInfo();\n        const { tree } = pickRandomTreeAndQueue(stateTreeInfo);\n        outputStateTree = tree;\n    }\n\n    const ix = await LightSystemProgram.compress({\n        payer: payer.publicKey,\n        toAddress,\n        lamports,\n        outputStateTree,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport {\n    LightSystemProgram,\n    selectMinCompressedSolAccountsForTransfer,\n} from '../programs';\nimport { pickRandomTreeAndQueue, Rpc } from '../rpc';\nimport {\n    NewAddressParams,\n    buildAndSignTx,\n    deriveAddress,\n    deriveAddressSeed,\n    sendAndConfirmTx,\n} from '../utils';\nimport { defaultTestStateTreeAccounts } from '../constants';\nimport { bn } from '../state';\nimport BN from 'bn.js';\n\n/**\n * Create compressed account with address\n *\n * @param rpc               RPC to use\n * @param payer             Payer of the transaction and initialization fees\n * @param seeds             Seeds to derive the new account address\n * @param programId         Owner of the new account\n * @param addressTree       Optional address tree. Defaults to a current shared\n *                          address tree.\n * @param addressQueue      Optional address queue. Defaults to a current shared\n *                          address queue.\n * @param outputStateTree   Optional output state tree. Defaults to a current\n *                          shared state tree.\n * @param confirmOptions    Options for confirming the transaction\n *\n * @return                  Transaction signature\n */\nexport async function createAccount(\n    rpc: Rpc,\n    payer: Signer,\n    seeds: Uint8Array[],\n    programId: PublicKey,\n    addressTree?: PublicKey,\n    addressQueue?: PublicKey,\n    outputStateTree?: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    addressTree = addressTree ?? defaultTestStateTreeAccounts().addressTree;\n    addressQueue = addressQueue ?? defaultTestStateTreeAccounts().addressQueue;\n\n    const seed = deriveAddressSeed(seeds, programId);\n    const address = deriveAddress(seed, addressTree);\n\n    if (!outputStateTree) {\n        const stateTreeInfo = await rpc.getCachedActiveStateTreeInfo();\n        const { tree } = pickRandomTreeAndQueue(stateTreeInfo);\n        outputStateTree = tree;\n    }\n\n    const proof = await rpc.getValidityProofV0(undefined, [\n        {\n            address: bn(address.toBytes()),\n            tree: addressTree,\n            queue: addressQueue,\n        },\n    ]);\n\n    const params: NewAddressParams = {\n        seed: seed,\n        addressMerkleTreeRootIndex: proof.rootIndices[0],\n        addressMerkleTreePubkey: proof.merkleTrees[0],\n        addressQueuePubkey: proof.nullifierQueues[0],\n    };\n\n    const ix = await LightSystemProgram.createAccount({\n        payer: payer.publicKey,\n        newAddressParams: params,\n        newAddress: Array.from(address.toBytes()),\n        recentValidityProof: proof.compressedProof,\n        programId,\n        outputStateTree,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n\n/**\n * Create compressed account with address and lamports\n *\n * @param rpc               RPC to use\n * @param payer             Payer of the transaction and initialization fees\n * @param seeds             Seeds to derive the new account address\n * @param lamports          Number of compressed lamports to initialize the\n *                          account with\n * @param programId         Owner of the new account\n * @param addressTree       Optional address tree. Defaults to a current shared\n *                          address tree.\n * @param addressQueue      Optional address queue. Defaults to a current shared\n *                          address queue.\n * @param outputStateTree   Optional output state tree. Defaults to a current\n *                          shared state tree.\n * @param confirmOptions    Options for confirming the transaction\n *\n * @return                  Transaction signature\n */\n// TODO: add support for payer != user owner\nexport async function createAccountWithLamports(\n    rpc: Rpc,\n    payer: Signer,\n    seeds: Uint8Array[],\n    lamports: number | BN,\n    programId: PublicKey,\n    addressTree?: PublicKey,\n    addressQueue?: PublicKey,\n    outputStateTree?: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    lamports = bn(lamports);\n\n    const compressedAccounts = await rpc.getCompressedAccountsByOwner(\n        payer.publicKey,\n    );\n\n    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(\n        compressedAccounts.items,\n        lamports,\n    );\n\n    if (!outputStateTree) {\n        const stateTreeInfo = await rpc.getCachedActiveStateTreeInfo();\n        const { tree } = pickRandomTreeAndQueue(stateTreeInfo);\n        outputStateTree = tree;\n    }\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n\n    addressTree = addressTree ?? defaultTestStateTreeAccounts().addressTree;\n    addressQueue = addressQueue ?? defaultTestStateTreeAccounts().addressQueue;\n\n    const seed = deriveAddressSeed(seeds, programId);\n    const address = deriveAddress(seed, addressTree);\n\n    const proof = await rpc.getValidityProof(\n        inputAccounts.map(account => bn(account.hash)),\n        [bn(address.toBytes())],\n    );\n\n    /// TODO(crank): Adapt before supporting addresses in rpc / cranked address trees.\n    /// Currently expects address roots to be consistent with one another and\n    /// static. See test-rpc.ts for more details.\n    const params: NewAddressParams = {\n        seed: seed,\n        addressMerkleTreeRootIndex:\n            proof.rootIndices[proof.rootIndices.length - 1],\n        addressMerkleTreePubkey:\n            proof.merkleTrees[proof.merkleTrees.length - 1],\n        addressQueuePubkey:\n            proof.nullifierQueues[proof.nullifierQueues.length - 1],\n    };\n\n    const ix = await LightSystemProgram.createAccount({\n        payer: payer.publicKey,\n        newAddressParams: params,\n        newAddress: Array.from(address.toBytes()),\n        recentValidityProof: proof.compressedProof,\n        inputCompressedAccounts: inputAccounts,\n        inputStateRootIndices: proof.rootIndices,\n        programId,\n        outputStateTree,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport { LightSystemProgram, sumUpLamports } from '../programs';\nimport { Rpc } from '../rpc';\nimport { buildAndSignTx, sendAndConfirmTx } from '../utils';\nimport BN from 'bn.js';\nimport { CompressedAccountWithMerkleContext, bn } from '../state';\n\n/**\n * Decompress lamports into a solana account\n *\n * @param rpc             RPC to use\n * @param payer           Payer of the transaction and initialization fees\n * @param lamports        Amount of lamports to compress\n * @param toAddress       Address of the recipient compressed account\n * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.\n * @param confirmOptions  Options for confirming the transaction\n *\n * @return Transaction signature\n */\n/// TODO: add multisig support\n/// TODO: add support for payer != owner\nexport async function decompress(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    recipient: PublicKey,\n    outputStateTree?: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    /// TODO: use dynamic state tree and nullifier queue\n\n    const userCompressedAccountsWithMerkleContext: CompressedAccountWithMerkleContext[] =\n        (await rpc.getCompressedAccountsByOwner(payer.publicKey)).items;\n\n    lamports = bn(lamports);\n\n    const inputLamports = sumUpLamports(\n        userCompressedAccountsWithMerkleContext,\n    );\n\n    if (lamports.gt(inputLamports)) {\n        throw new Error(\n            `Not enough compressed lamports. Expected ${lamports}, got ${inputLamports}`,\n        );\n    }\n\n    const proof = await rpc.getValidityProof(\n        userCompressedAccountsWithMerkleContext.map(x => bn(x.hash)),\n    );\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const ix = await LightSystemProgram.decompress({\n        payer: payer.publicKey,\n        toAddress: recipient,\n        outputStateTree: outputStateTree,\n        inputCompressedAccounts: userCompressedAccountsWithMerkleContext,\n        recentValidityProof: proof.compressedProof,\n        recentInputStateRootIndices: proof.rootIndices,\n        lamports,\n    });\n\n    const tx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n        [],\n    );\n\n    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);\n\n    return txId;\n}\n","/** pipe function */\nexport function pipe<T, R>(\n    initialFunction: (arg: T) => R,\n    ...functions: ((arg: R) => R)[]\n): (initialValue: T) => R {\n    return (initialValue: T): R =>\n        functions.reduce(\n            (currentValue, currentFunction) => currentFunction(currentValue),\n            initialFunction(initialValue),\n        );\n}\n\n//@ts-ignore\nif (import.meta.vitest) {\n    //@ts-ignore\n    const { it, expect, describe } = import.meta.vitest;\n\n    describe('pipe', () => {\n        it('should return the result of applying all fns to the initial value', () => {\n            const addOne = (x: number) => x + 1;\n            const multiplyByTwo = (x: number) => x * 2;\n            const subtractThree = (x: number) => x - 3;\n            const addOneMultiplyByTwoSubtractThree = pipe(\n                addOne,\n                multiplyByTwo,\n                subtractThree,\n            );\n            expect(addOneMultiplyByTwoSubtractThree(5)).toBe(9);\n        });\n    });\n}\n","// zzz\nexport function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import {\n    ComputeBudgetProgram,\n    ConfirmOptions,\n    PublicKey,\n    Signer,\n    TransactionSignature,\n} from '@solana/web3.js';\n\nimport BN from 'bn.js';\nimport {\n    LightSystemProgram,\n    selectMinCompressedSolAccountsForTransfer,\n} from '../programs';\nimport { Rpc } from '../rpc';\n\nimport { bn, CompressedAccountWithMerkleContext } from '../state';\nimport { buildAndSignTx, sendAndConfirmTx } from '../utils';\nimport { GetCompressedAccountsByOwnerConfig } from '../rpc-interface';\n\n/**\n * Transfer compressed lamports from one owner to another\n *\n * @param rpc            Rpc to use\n * @param payer          Payer of transaction fees\n * @param lamports       Number of lamports to transfer\n * @param owner          Owner of the compressed lamports\n * @param toAddress      Destination address of the recipient\n * @param merkleTree     State tree account that the compressed lamports should be\n *                       inserted into. Defaults to the default state tree account.\n * @param confirmOptions Options for confirming the transaction\n * @param config         Configuration for fetching compressed accounts\n *\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    rpc: Rpc,\n    payer: Signer,\n    lamports: number | BN,\n    owner: Signer,\n    toAddress: PublicKey,\n    merkleTree?: PublicKey,\n    confirmOptions?: ConfirmOptions,\n): Promise<TransactionSignature> {\n    let accumulatedLamports = bn(0);\n    const compressedAccounts: CompressedAccountWithMerkleContext[] = [];\n    let cursor: string | undefined;\n    const batchSize = 1000; // Maximum allowed by the API\n    lamports = bn(lamports);\n\n    while (accumulatedLamports.lt(lamports)) {\n        const batchConfig: GetCompressedAccountsByOwnerConfig = {\n            filters: undefined,\n            dataSlice: undefined,\n            cursor,\n            limit: new BN(batchSize),\n        };\n\n        const batch = await rpc.getCompressedAccountsByOwner(\n            owner.publicKey,\n            batchConfig,\n        );\n\n        for (const account of batch.items) {\n            if (account.lamports.gt(new BN(0))) {\n                compressedAccounts.push(account);\n                accumulatedLamports = accumulatedLamports.add(account.lamports);\n            }\n        }\n\n        cursor = batch.cursor ?? undefined;\n        if (batch.items.length < batchSize || accumulatedLamports.gte(lamports))\n            break;\n    }\n\n    if (accumulatedLamports.lt(lamports)) {\n        throw new Error(\n            `Insufficient balance for transfer. Required: ${lamports.toString()}, available: ${accumulatedLamports.toString()}`,\n        );\n    }\n\n    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(\n        compressedAccounts,\n        lamports,\n    );\n\n    const proof = await rpc.getValidityProof(\n        inputAccounts.map(account => bn(account.hash)),\n    );\n\n    const ix = await LightSystemProgram.transfer({\n        payer: payer.publicKey,\n        inputCompressedAccounts: inputAccounts,\n        toAddress,\n        lamports,\n        recentInputStateRootIndices: proof.rootIndices,\n        recentValidityProof: proof.compressedProof,\n        outputStateTrees: merkleTree,\n    });\n\n    const { blockhash } = await rpc.getLatestBlockhash();\n    const signedTx = buildAndSignTx(\n        [ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix],\n        payer,\n        blockhash,\n    );\n\n    const txId = await sendAndConfirmTx(rpc, signedTx, confirmOptions);\n    return txId;\n}\n"],"names":["module","exports","assert","val","msg","Error","inherits","ctor","superCtor","super_","TempCtor","prototype","constructor","BN","number","base","endian","isBN","this","negative","words","length","red","_init","Buffer","wordSize","window","require","e","parseHex4Bits","string","index","c","charCodeAt","parseHexByte","lowerBound","r","parseBase","str","start","end","mul","b","len","Math","min","i","move","dest","src","num","Array","isArray","max","left","right","cmp","_initNumber","_initArray","toString","replace","_parseHex","_parseBase","toArray","ceil","j","w","off","_strip","limbLen","limbPow","total","mod","word","imuln","_iaddn","pow","copy","_move","clone","_expand","size","_normSign","Symbol","for","inspect","zeros","groupSizes","groupBases","smallMulTo","self","out","a","lo","carry","k","ncarry","rword","maxJ","padding","groupSize","groupBase","isZero","modrn","idivn","toNumber","ret","toJSON","toBuffer","toArrayLike","ArrayType","byteLength","reqLength","res","allocUnsafe","allocate","_toArrayLikeLE","position","shift","_toArrayLikeBE","clz32","_countBits","t","_zeroBits","bitLength","hi","zeroBits","toTwos","width","abs","inotn","iaddn","fromTwos","testn","notn","ineg","isNeg","neg","iuor","ior","or","uor","iuand","iand","and","uand","iuxor","ixor","xor","uxor","bytesNeeded","bitsLeft","setn","bit","wbit","iadd","isub","add","sub","comb10MulTo","mid","o","a0","al0","ah0","a1","al1","ah1","a2","al2","ah2","a3","al3","ah3","a4","al4","ah4","a5","al5","ah5","a6","al6","ah6","a7","al7","ah7","a8","al8","ah8","a9","al9","ah9","b0","bl0","bh0","b1","bl1","bh1","b2","bl2","bh2","b3","bl3","bh3","b4","bl4","bh4","b5","bl5","bh5","b6","bl6","bh6","b7","bl7","bh7","b8","bl8","bh8","b9","bl9","bh9","w0","imul","w1","w2","w3","w4","w5","w6","w7","w8","w9","w10","w11","w12","w13","w14","w15","w16","w17","w18","bigMulTo","hncarry","jumboMulTo","mulTo","mulf","isNegNum","muln","sqr","isqr","toBitArray","q","iushln","bits","s","carryMask","newCarry","ishln","iushrn","hint","extended","h","mask","maskedWords","ishrn","shln","ushln","shrn","ushrn","imaskn","maskn","isubn","addn","subn","iabs","_ishlnsubmul","_wordDiv","mode","bhi","m","diff","qj","div","divmod","positive","divn","umod","divRound","dm","half","r2","andln","p","acc","modn","egcd","x","y","A","B","C","D","g","isEven","yp","xp","im","isOdd","jm","gcd","_invmp","x1","x2","delta","cmpn","invm","bincn","ucmp","gtn","gt","gten","gte","ltn","lt","lten","lte","eqn","eq","Red","toRed","ctx","convertTo","_forceRed","fromRed","convertFrom","forceRed","redAdd","redIAdd","redSub","redISub","redShl","shl","redMul","_verify2","redIMul","redSqr","_verify1","redISqr","redSqrt","sqrt","redInvm","redNeg","redPow","primes","k256","p224","p192","p25519","MPrime","name","n","tmp","_tmp","K256","call","P224","P192","P25519","prime","_prime","Mont","imod","rinv","minv","ireduce","rlen","split","imulK","undefined","strip","input","output","outLen","prev","next","mod3","one","nOne","lpow","z","inv","wnd","current","currentLen","mont","u","TreeType","FIELD_SIZE","HIGHEST_ADDRESS_PLUS_ONE","COMPUTE_BUDGET_PATTERN","INVOKE_DISCRIMINATOR","from","INVOKE_CPI_DISCRIMINATOR","INSERT_INTO_QUEUES_DISCRIMINATOR","noopProgram","lightProgram","accountCompressionProgram","getRegisteredProgramPda","PublicKey","getAccountCompressionAuthority","findProgramAddressSync","defaultStaticAccountsStruct","registeredProgramPda","accountCompressionAuthority","cpiSignatureAccount","defaultStateTreeLookupTables","mainnet","stateTreeLookupTable","stateTreeLookupTableMainnet","nullifyTable","nullifiedStateTreeLookupTableMainnet","devnet","stateTreeLookupTableDevnet","nullifiedStateTreeLookupTableDevnet","isLocalTest","url","includes","localTestActiveStateTreeInfo","tree","merkletreePubkey","queue","nullifierQueuePubkey","cpiContext","cpiContextPubkey","treeType","State","merkleTree2Pubkey","nullifierQueue2Pubkey","cpiContext2Pubkey","defaultTestStateTreeAccounts","nullifierQueue","merkleTree","merkleTreeHeight","DEFAULT_MERKLE_TREE_HEIGHT","addressTree","addressQueue","TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD","floor","STATE_MERKLE_TREE_ROLLOVER_FEE","ADDRESS_QUEUE_ROLLOVER_FEE","STATE_MERKLE_TREE_NETWORK_FEE","ADDRESS_TREE_NETWORK_FEE","basex","ALPHABET","BASE_MAP","Uint8Array","charAt","xc","TypeError","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","it3","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","pbegin","pend","b58","it1","it2","repeat","decode","bn","createBN254","bs58","bigintNumber","enforceSize","encodeBN254toBase58","bn254Buffer","createCompressedAccount","owner","lamports","data","address","createCompressedAccountWithMerkleContext","merkleContext","Object","assign","readOnly","createMerkleContext","hash","leafIndex","Number","isSafeInteger","bytes","lengths","exists","instance","checkFinished","destroyed","finished","U32_MASK64","BigInt","_32n","fromBig","le","l","lst","Ah","Uint32Array","Al","isLE","byteSwap32","arr","toBytes","TextEncoder","utf8ToBytes","abytes","Hash","_cloneInto","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","push","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlBH","rotlSH","rotlL","rotlBL","rotlSL","Keccak","blockLen","suffix","outputLen","enableXOF","rounds","super","pos","posOut","state","state32","keccak","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","fill","keccakP","update","take","finish","writeInto","bufferOut","set","subarray","xofInto","xof","digestInto","destroy","digest","to","keccak_256","hashCons","hashC","create","wrapConstructor","gen","isObject","value","isObjectCustom","RegExp","Date","mapObjectSkip","_mapObject","object","mapper","options","isSeen","WeakMap","deep","target","has","get","mapArray","array","map","element","key","entries","mapResult","newKey","newValue","shouldRecurse","mapObject","UPPERCASE","LOWERCASE","LEADING_CAPITAL","IDENTIFIER","SEPARATORS","LEADING_SEPARATORS","SEPARATORS_AND_IDENTIFIER","NUMBERS_AND_IDENTIFIER","QuickLRU","Map","maxSize","maxAge","POSITIVE_INFINITY","onEviction","cache","oldCache","_size","_emitEvictions","item","_deleteIfExpired","expiry","now","delete","_getOrDeleteIfExpired","_getItemValue","_peek","_set","_moveToRecent","_entriesAscending","peek","deleted","clear","resize","newSize","items","removeCount","slice","keys","values","iterator","entriesDescending","entriesAscending","oldCacheSize","forEach","callbackFunction","thisArgument","toStringTag","JSON","stringify","QuickLru","transform","exclude","pascalCase","stopPaths","preserveConsecutiveUppercase","stopPathsSet","Set","makeMapper","parentPath","path","some","lastIndex","test","cacheKey","returnValue","trim","filter","join","toLowerCase","locale","toLocaleLowerCase","toUpperCase","toLocaleUpperCase","isLastCharLower","isLastCharUpper","isLastLastCharUpper","isLastLastCharPreserved","character","preserveCamelCase","replaceAll","match","pattern","offset","_","identifier","postProcess","camelCase","toHex","isSmallerThanBn254FieldSizeBe","toCamelCase","camelcaseKeys","hashToBn254FieldSizeBe","bumpSeed","inputWithBumpSeed","concat","hashvToBn254FieldSizeBe","hasher","getIndexOrAdd","accountsArray","findIndex","existingKey","equals","padOutputStateMerkleTrees","outputStateMerkleTrees","numberOfOutputCompressedAccounts","inputCompressedAccountsWithMerkleContext","treesArray","toAccountMetas","remainingAccounts","account","pubkey","isWritable","isSigner","packCompressedAccounts","inputCompressedAccounts","inputStateRootIndices","outputCompressedAccounts","_remainingAccounts","packedInputCompressedAccounts","packedOutputCompressedAccounts","merkleTreePubkeyIndex","nullifierQueuePubkeyIndex","compressedAccount","queueIndex","rootIndex","paddedOutputStateMerkleTrees","merkleTreeIndex","validateSufficientBalance","balance","validateSameOwner","compressedAccounts","zerothOwner","every","validateNumbersForProof","hashesLength","newAddressesLength","validateNumbers","validateNumbersForNonInclusionProof","validateNumbersForInclusionProof","allowedNumbers","type","deriveAddressSeed","seeds","programId","deriveAddress","seed","addressMerkleTreePubkey","buf","packNewAddressParams","newAddressParams","newAddressParamsPacked","addressMerkleTreeRootIndex","addressMerkleTreeAccountIndex","addressQueueAccountIndex","params","addressQueuePubkey","async","confirmTransaction","connection","signature","confirmation","latestBlockHash","getLatestBlockhash","strategy","lastValidBlockHeight","blockhash","proofFromJsonStruct","json","proofAX","deserializeHexStringToBeBytes","ar","proofAY","proofA","proofBX0","bs","proofBX1","proofBY0","proofBY1","proofB","proofCX","krs","proofCY","negateAndCompressProof","proof","proofC","aXElement","proofAIsPositive","yElementIsPositiveG1","addBitmaskToByte","bXElement","bYElement","proofBIsPositive","yElement1","yElement2","fieldMidpoint","yElementIsPositiveG2","cXElement","cYElement","proofCIsPositive","hexStr","startsWith","substring","yElement","byte","yIsPositive","buildTx","instructions","payerPublicKey","lookupTableAccounts","messageV0","TransactionMessage","payerKey","recentBlockhash","compileToV0Message","VersionedTransaction","sendAndConfirmTx","rpc","tx","confirmOptions","blockHashCtx","txId","sendTransaction","transactionConfirmationStrategy0","slot","commitment","context","confirmTransactionIndexed","confirmTx","transactionConfirmationStrategy","buildAndSignTx","payer","additionalSigners","allSigners","publicKey","sign","getLightStateTreeInfo","stateTreeLookupTableAddress","nullifyTableAddress","getAddressLookupTable","addresses","stateTreePubkeys","nullifyTablePubkeys","bundles","Layout","span","property","isInteger","makeDestinationObject","getSpan","RangeError","replicate","rv","fromArray","nameWithProperty","Layout_1","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","defineProperty","writable","ExternalLayout","isCount","GreedyCount","elementSpan","rem","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","idx","elo","reduce","v","Structure","fields","decodePrefixes","fd","fsp","firstOffset","lastOffset","lastWrote","fv","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","isBuffer","union","fixBitwiseResult","BitStructure","msb","_packedSetValue","_packedGetValue","addField","bf","BitField","addBoolean","Boolean","fieldFor","container","totalBits","usedBits","sum","valueMask","wordMask","wordValue","Blob","write","CString","srcb","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","const","__importDefault","__esModule","default","rustEnum","vecU8","tagged","vec","bool","option","i256","u256","i128","u128","u64","i32","i16","i8","buffer_layout_1","require$$0","web3_js_1","require$$1","bn_js_1","require$$2","buffer_layout_2","enumerable","BNLayout","signed","i64","WrappedLayout","decoder","encoder","OptionLayout","decodeBool","encodeBool","wrappedLayout","receivedTag","variants","discriminant","unionLayout","MapEntryLayout","keyLayout","valueLayout","keyBytes","CompressedAccountLayout","MerkleContextLayout","NewAddressParamsLayout","InstructionDataInvokeLayout","encodeInstructionDataInvoke","alloc","dataBuffer","lengthBuffer","InstructionDataInvokeCpiLayout","decodeInstructionDataInvoke","decodeInstructionDataInvokeCpi","invokeAccountsLayout","accounts","defaultPubkey","LightSystemProgram","feePayer","authority","solPoolPda","decompressionRecipient","systemProgram","PublicTransactionEventLayout","decodePublicTransactionEvent","AppendNullifyCreateAddressInputsMetaLayout","AppendLeavesInputLayout","InsertNullifierInputLayout","InsertAddressInputLayout","MerkleTreeSequenceNumberLayout","deserializeAppendNullifyCreateAddressInputsIndexer","meta","leavesCount","readUInt8","leaves","leaf","nullifiersCount","nullifiers","nullifier","addressesCount","outputSequenceNumbersCount","output_sequence_numbers","inputSequenceNumbersCount","addressSequenceNumbersCount","outputLeafIndicesCount","output_leaf_indices","sequence_numbers","convertToPublicTransactionEvent","decoded","invokeData","convertByteArray","inputCompressedAccountHashes","account_hash","outputCompressedAccountHashes","_a","_b","_c","_d","_e","dataHash","_f","outputLeafIndices","sequenceNumbers","sn","pubkeyArray","pk","isCompress","relayFee","compressOrDecompressLamports","message","sumUpLamports","SOL_POOL_PDA_SEED","deriveCompressedSolPda","createTransferOutputState","toAddress","changeLamports","createDecompressOutputState","createNewAddressOutputState","createAccount","newAddress","recentValidityProof","outputStateTree","SystemProgram","TransactionInstruction","transfer","recentInputStateRootIndices","outputStateTrees","compress","outputCompressedAccount","decompress","selectMinCompressedSolAccountsForTransfer","transferLamports","accumulatedLamports","selectedAccounts","sort","StructError","failure","failures","cached","explanation","rest","cause","isNonArrayObject","print","toFailure","result","branch","refinement","toFailures","run","coerce","coercer","status","validator","ts","refiner","Struct","props","schema","validate","is","tuples","tuple","done","shiftIterator","define","any","Element","literal","constant","description","nullable","isNaN","Structs","S","error","coerced","first","unknown","condition","PublicKeyFromString","ArrayFromString","BN254FromString","BNFromStringOrNumber","Base64EncodedCompressedAccountDataResult","createRpcResult","pick","jsonrpc","id","code","UnknownRpcResult","jsonRpcResult","jsonRpcResultAndContext","CompressedAccountResult","slotCreated","TokenDataResult","mint","amount","delegate","CompressedTokenAccountResult","tokenData","MultipleCompressedAccountsResult","CompressedAccountsByOwnerResult","cursor","CompressedTokenAccountsByOwnerOrDelegateResult","SlotResult","HealthResult","LatestNonVotingSignaturesResult","blockTime","LatestNonVotingSignaturesResultPaginated","MerkeProofResult","rootSeq","root","NewAddressProofResult","nextIndex","lowerRangeAddress","higherRangeAddress","lowElementLeafIndex","CompressedProofResult","ValidityProofResult","compressedProof","leafIndices","rootIndices","roots","merkleTrees","MultipleMerkleProofsResult","BalanceResult","NativeBalanceResult","TokenBalanceResult","TokenBalanceListResult","tokenBalances","TokenBalanceListResultV2","CompressedMintTokenHoldersResult","AccountProofResult","SignatureListResult","SignatureListWithCursorResult","CompressedTransactionResult","compressionInfo","closedAccounts","optionalTokenData","openedAccounts","transaction","parseAccountData","getCompressedTokenAccountsByOwnerOrDelegate","ownerOrDelegate","filterByDelegate","endpoint","propertyToCheck","rpcRequest","compressionApiEndpoint","toBase58","limit","SolanaJSONRPCError","activeStateTreeInfo","getCachedActiveStateTreeInfo","_account","_tokenData","associatedQueue","getQueueForTree","parsed","indexOf","tlv","buildCompressedAccountWithMaybeTokenData","accountStructWithOptionalTokenData","compressedAccountResult","tokenDataResult","maybeTokenData","wrapBigNumbersAsStrings","text","p1","p2","p3","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","rpcEndpoint","method","convertToCamelCase","debug","body","generateCurlSnippet","escapedBody","console","stack","response","fetch","headers","ok","wrappedJsonString","parse","proverRequest","proverEndpoint","logMsg","time","circuitType","stateTreeHeight","addressTreeHeight","newAddresses","statusText","timeEnd","convertMerkleProofsWithContextToHex","merkleProofsWithContext","inputs","pathIndex","pathElements","merkleProof","hex","convertNonInclusionMerkleProofInputsToHex","nonInclusionMerkleProofInputs","indexHashedIndexedElementLeaf","merkleProofHashedIndexedElementLeaf","leafLowerRangeValue","leafHigherRangeValue","calculateTwoInputsHashChain","hashesFirst","hashesSecond","lightWasm","hashChain","poseidonHashBN","info","pickRandomTreeAndQueue","random","Rpc","Connection","config","setStateTreeInfo","getLatestActiveStateTreeInfo","getCompressedAccount","getCompressedBalance","getCompressedBalanceByOwner","getCompressedAccountProof","getMultipleCompressedAccounts","hashes","getMultipleCompressedAccountProofs","merkleProofs","getCompressedAccountsByOwner","filters","dataSlice","getCompressedTokenAccountsByOwner","getCompressedTokenAccountsByDelegate","getCompressedTokenAccountBalance","getCompressedTokenBalancesByOwner","tokenBalance","getCompressedTokenBalancesByOwnerV2","maybeFiltered","getCompressionSignaturesForAccount","getTransactionWithCompressionInfo","calculateTokenBalances","balances","preTokenBalances","postTokenBalances","getCompressionSignaturesForAddress","getCompressionSignaturesForOwner","getCompressionSignaturesForTokenOwner","getIndexerHealth","startTime","getIndexerSlot","Promise","resolve","setTimeout","getCompressedMintTokenHolders","getLatestCompressionSignatures","getLatestNonVotingSignatures","getMultipleNewAddressProofs","newAddressProofs","_proof","getValidityProofDirect","validityProof","nullifierQueues","newAddressInputs","getValidityProof","accs","trees","queues","defaultAddressTreePublicKey","defaultAddressQueuePublicKey","formattedHashes","formattedNewAddresses","getValidityProofV0","getValidityProofAndRpcContext","newAddressesWithTrees","dedupeSigner","signer","signers","UtxoErrorCode","SelectInUtxosErrorCode","CreateUtxoErrorCode","RpcErrorCode","LookupTableErrorCode","ProofErrorCode","MerkleTreeErrorCode","UtilsErrorCode","HashErrorCode","MetaError","functionName","codeMessage","IndexedElement","other","compareTo","nextValue","poseidonHash","IndexedElementBundle","newLowElement","newElement","newElementNextValue","IndexedArray","elements","currentNodeIndex","highestElementIndex","isEmpty","findElement","find","node","init","init_value","append","findLowElementIndex","findLowElement","lowElementIndex","lowElement","hashElement","nextElement","appendWithLowElementIndex","newElementBundle","newElementWithLowElementIndex","lowest","newElementIndex","MerkleTree","levels","zeroElement","capacity","_lightWasm","_zeros","_layers","poseidonHashString","_rebuild","level","insert","bulkInsert","pathIndices","comparator","el","serialize","deserialize","hashFunction","_hash","getParsedEvents","events","signatures","getConfirmedSignaturesForAddress2","txs","getParsedTransactions","maxSupportedTransactionVersion","txParsed","innerInstructions","allAccounts","accountKeys","dataVec","txRaw","getTransaction","ix","compiledInstructions","decodedData","groupedAccountVec","innerGroup","group","accountIdx","event","parseLightTransaction","transactionEvents","parseEvents","parsePublicTransactionEventWithIdl","indexerEventsTransactions","deserializeFn","transactions","err","ixInner","decodedEvent","numericData","foundSystemInstruction","appendInputsData","discriminatorStr","invokeDiscriminatorStr","invokeCpiDiscriminatorStr","getCompressedAccountByHashTest","getCompressedAccountsForTest","reverse","allOutputAccounts","allInputAccountHashes","withCtx","unspentAccounts","tokenProgramId","TokenDataLayout","parseTokenLayoutWithIdl","getCompressedTokenAccounts","eventsWithParsedTokenTlvData","all","outputHashes","outputCompressedAccountsWithParsedTokenData","parsedData","parseEventWithTokenTlvData","allOutCompressedAccounts","flatMap","allInCompressedAccountHashes","getCompressedTokenAccountsByOwnerTest","getCompressedTokenAccountsByDelegateTest","getCompressedTokenAccountByHashTest","filtered","TestRpc","connectionConfig","testRpcConfig","merkleTreeAddress","nullifierQueueAddress","depth","addressTreeAddress","addressQueueAddress","getMultipleCompressedAccountsByHashTest","_slot","then","allLeaves","allLeafIndices","bnPathElements","computedHash","hashArr","_config","getCompressedAccountsByOwnerTest","_cursor","_limit","_signature","_address","_options","_owner","indexedArray","allAddresses","higherRangeValue","_mint","ALICE","getTestKeypair","BOB","CHARLIE","DAVE","counter","Keypair","generate","fromSeed","version","constants","isMut","args","docs","isOptional","defined","kind","types","errors","recipientPublicKey","txHash","requestAirdrop","byteArray","fromSecretKey","targetLamports","computeUnits","stateTreeInfo","ComputeBudgetProgram","setComputeUnitLimit","units","preflightCommitment","inputAccounts","endpointOrWeb3JsConnection","recentSlot","createInstruction1","lookupTableAddress1","AddressLookupTableProgram","createLookupTable","recipient","userCompressedAccountsWithMerkleContext","inputLamports","deepEqual","ref","refKeys","valKeys","nullifierQueue2","merkleTree2","tableAddress","newStateTreeAddresses","newQueueAddresses","newCpiContextAddresses","lutState","extendLookupTable","lookupTable","addr","accountProofs","accountHashes","inclusionHashChain","newAddressHashes","nonInclusionHashChain","defaultAccounts","sig","fullStateTreeAddress","initialFunction","functions","initialValue","currentValue","currentFunction","ms","getTime","batchConfig","batch","signedTx"],"mappings":"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","x_google_ignoreList":[0,3,4,7,8,9,10,11,12,13,14,23,24,27]}