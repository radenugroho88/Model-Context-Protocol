import BN from 'bn.js';
import { PublicKey } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { NewAddressParamsPacked } from '../utils';
export declare enum TreeType {
    /**
     * v1 state merkle tree
     */
    State = 0,
    /**
     * v1 address merkle tree
     */
    Address = 1,
    /**
     * v2 state merkle tree
     */
    BatchedState = 2,
    /**
     * v2 address merkle tree
     */
    BatchedAddress = 3
}
export type ActiveTreeBundle = {
    tree: PublicKey;
    queue: PublicKey | null;
    cpiContext: PublicKey | null;
    treeType: TreeType;
};
export interface PackedCompressedAccountWithMerkleContext {
    compressedAccount: CompressedAccount;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    readOnly: boolean;
}
export interface PackedMerkleContext {
    merkleTreePubkeyIndex: number;
    nullifierQueuePubkeyIndex: number;
    leafIndex: number;
    queueIndex: null | QueueIndex;
}
export interface QueueIndex {
    queueId: number;
    index: number;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
export interface CompressedAccount {
    /** Public key of program or user that owns the account */
    owner: PublicKey;
    /** Lamports attached to the account */
    lamports: BN;
    /**
     * TODO: use PublicKey. Optional unique account ID that is persistent across
     * transactions.
     */
    address: number[] | null;
    /** Optional data attached to the account */
    data: CompressedAccountData | null;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
export interface OutputCompressedAccountWithPackedContext {
    compressedAccount: CompressedAccount;
    merkleTreeIndex: number;
}
export interface CompressedAccountData {
    discriminator: number[];
    data: Buffer;
    dataHash: number[];
}
export interface MerkleTreeSequenceNumber {
    pubkey: PublicKey;
    seq: BN;
}
export interface PublicTransactionEvent {
    inputCompressedAccountHashes: number[][];
    outputCompressedAccountHashes: number[][];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    outputLeafIndices: number[];
    sequenceNumbers: MerkleTreeSequenceNumber[];
    relayFee: BN | null;
    isCompress: boolean;
    compressOrDecompressLamports: BN | null;
    pubkeyArray: PublicKey[];
    message: Uint8Array | null;
}
export interface InstructionDataInvoke {
    proof: CompressedProof | null;
    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    relayFee: BN | null;
    newAddressParams: NewAddressParamsPacked[];
    compressOrDecompressLamports: BN | null;
    isCompress: boolean;
}
export interface InstructionDataInvokeCpi {
    proof: CompressedProof | null;
    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    relayFee: BN | null;
    newAddressParams: NewAddressParamsPacked[];
    compressOrDecompressLamports: BN | null;
    isCompress: boolean;
    compressedCpiContext: CompressedCpiContext | null;
}
export interface CompressedCpiContext {
    set_context: boolean;
    first_set_context: boolean;
    cpi_context_account_index: number;
}
export interface CompressedProof {
    a: number[];
    b: number[];
    c: number[];
}
export interface InputTokenDataWithContext {
    amount: BN;
    delegateIndex: number | null;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    lamports: BN | null;
    tlv: Buffer | null;
}
export type TokenData = {
    mint: PublicKey;
    owner: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: number;
    tlv: Buffer | null;
};
