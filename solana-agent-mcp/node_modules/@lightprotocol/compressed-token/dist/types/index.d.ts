import { PackedMerkleContext, CompressedProof, ParsedTokenAccount, InputTokenDataWithContext as InputTokenDataWithContext$1, Rpc } from '@lightprotocol/stateless.js';
import { PublicKey, AccountMeta, TransactionInstruction, Connection, Signer, ConfirmOptions, TransactionSignature, Keypair } from '@solana/web3.js';
import BN from 'bn.js';
import * as buffer_layout from 'buffer-layout';
import { Buffer as Buffer$1 } from 'buffer';

type CompressedCpiContext = {
    setContext: boolean;
    firstSetContext: boolean;
    cpiContextAccountIndex: number;
};
type TokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type PackedTokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * Merkle tree pubkey index in remaining accounts
     */
    merkleTreeIndex: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type InputTokenDataWithContext = {
    amount: BN;
    delegateIndex: number | null;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    lamports: BN | null;
    tlv: Buffer | null;
};
type DelegatedTransfer = {
    owner: PublicKey;
    delegateChangeAccountIndex: number | null;
};
type MintToInstructionData = {
    recipients: PublicKey[];
    amounts: BN[];
    lamports: BN | null;
};
type CompressSplTokenAccountInstructionData = {
    owner: PublicKey;
    remainingAmount: BN | null;
    cpiContext: CompressedCpiContext | null;
};
type CompressedTokenInstructionDataTransfer = {
    /**
     * Validity proof
     */
    proof: CompressedProof | null;
    /**
     * The mint of the transfer
     */
    mint: PublicKey;
    /**
     * Whether the signer is a delegate
     * TODO: implement delegated transfer struct
     */
    delegatedTransfer: DelegatedTransfer | null;
    /**
     * Input token data with packed merkle context
     */
    inputTokenDataWithContext: InputTokenDataWithContext[];
    /**
     * Data of the output token accounts
     */
    outputCompressedAccounts: PackedTokenTransferOutputData[];
    /**
     * Whether it's a compress or decompress action if compressOrDecompressAmount is non-null
     */
    isCompress: boolean;
    /**
     * If null, it's a transfer.
     * If some, the amount that is being deposited into (compress) or withdrawn from (decompress) the token escrow
     */
    compressOrDecompressAmount: BN | null;
    /**
     * CPI context if
     */
    cpiContext: CompressedCpiContext | null;
    /**
     * The index of the Merkle tree for a lamport change account.
     */
    lamportsChangeAccountMerkleTreeIndex: number | null;
};
type TokenData = {
    /**
     * The mint associated with this account
     */
    mint: PublicKey;
    /**
     * The owner of this account
     */
    owner: PublicKey;
    /**
     * The amount of tokens this account holds
     */
    amount: BN;
    /**
     * If `delegate` is `Some` then `delegated_amount` represents the amount
     * authorized by the delegate
     */
    delegate: PublicKey | null;
    /**
     * The account's state
     */
    state: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};

type PackCompressedTokenAccountsParams = {
    /** Input state to be consumed */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * State trees that the output should be inserted into. Defaults to the 0th
     * state tree of the input state. Gets padded to the length of
     * outputCompressedAccounts.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
    /** Optional remaining accounts to append to */
    remainingAccounts?: PublicKey[];
    /**
     *  Root indices that are used on-chain to fetch the correct root
     *  from the state Merkle tree account for validity proof verification.
     */
    rootIndices: number[];
    tokenTransferOutputs: TokenTransferOutputData[];
};
/**
 * Packs Compressed Token Accounts.
 */
declare function packCompressedTokenAccounts(params: PackCompressedTokenAccountsParams): {
    inputTokenDataWithContext: InputTokenDataWithContext$1[];
    remainingAccountMetas: AccountMeta[];
    packedOutputTokenData: PackedTokenTransferOutputData[];
};

declare const POOL_SEED: Buffer;
declare const CPI_AUTHORITY_SEED: Buffer;
declare const SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = 1461600;
declare const CREATE_TOKEN_POOL_DISCRIMINATOR: Buffer;
declare const MINT_TO_DISCRIMINATOR: Buffer;
declare const TRANSFER_DISCRIMINATOR: Buffer;
declare const COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR: Buffer;

type CompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * owner of the *uncompressed* token account.
     */
    owner: PublicKey;
    /**
     * source (associated) token account address.
     */
    source: PublicKey;
    /**
     * owner of the compressed token account.
     * To compress to a batch of recipients, pass an array of PublicKeys.
     */
    toAddress: PublicKey | PublicKey[];
    /**
     * Mint address of the token to compress.
     */
    mint: PublicKey;
    /**
     * amount of tokens to compress.
     */
    amount: number | BN | number[] | BN[];
    /**
     * The state tree that the tx output should be inserted into. Defaults to a
     * public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type CompressSplTokenAccountParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Authority that owns the token account
     */
    authority: PublicKey;
    /**
     * Token account to compress
     */
    tokenAccount: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Optional: remaining amount to leave in token account. Default: 0
     */
    remainingAmount?: BN;
    /**
     * The state tree that the compressed token account should be inserted into.
     */
    outputStateTree: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type DecompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * input state to be consumed
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * address of **uncompressed** destination token account.
     */
    toAddress: PublicKey;
    /**
     * amount of tokens to decompress.
     */
    amount: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state tree that the change tx output should be inserted into.
     * Defaults to a public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type TransferParams = {
    /**
     * The payer of the transaction
     */
    payer: PublicKey;
    /**
     * The input state to be consumed
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * Amount of tokens to transfer
     */
    amount: BN | number;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.

     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
};
/**
 * Create Mint account for compressed Tokens
 */
type CreateMintParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Mint decimals
     */
    decimals: number;
    /**
     * Optional: freeze authority
     */
    freezeAuthority: PublicKey | null;
    /**
     * lamport amount for mint account rent exemption
     */
    rentExemptBalance: number;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
    /**
     * Optional: Mint size to use, defaults to MINT_SIZE
     */
    mintSize?: number;
};
/**
 * Parameters for merging compressed token accounts
 */
type MergeTokenAccountsParams = {
    /**
     * Tx feepayer
     */
    payer: PublicKey;
    /**
     * Owner of the token accounts to be merged
     */
    owner: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Array of compressed token accounts to merge
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Optional: Public key of the state tree to merge into
     */
    outputStateTree: PublicKey;
    /**
     * Optional: Recent validity proof for state inclusion
     */
    recentValidityProof: CompressedProof;
    /**
     * Optional: Recent state root indices of the input state
     */
    recentInputStateRootIndices: number[];
};
/**
 * Create compressed token accounts
 */
type MintToParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * The Solana Public Keys to mint to.
     */
    toPubkey: PublicKey[] | PublicKey;
    /**
     * The amount of compressed tokens to mint.
     */
    amount: BN | BN[] | number | number[];
    /**
     * Public key of the state tree to mint into. Defaults to a public state
     * tree if unspecified.
     */
    merkleTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
/**
 * Register an existing SPL mint account to the compressed token program
 * Creates an omnibus account for the mint
 */
type RegisterMintParams = {
    /** Tx feepayer */
    feePayer: PublicKey;
    /** Mint public key */
    mint: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
/**
 * Mint from existing SPL mint to compressed token accounts
 */
type ApproveAndMintToParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint authority (associated) token account
     */
    authorityTokenAccount: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * The Solana Public Key to mint to.
     */
    toPubkey: PublicKey;
    /**
     * The amount of compressed tokens to mint.
     */
    amount: BN | number;
    /**
     * Public key of the state tree to mint into. Defaults to a public state
     * tree if unspecified.
     */
    merkleTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type CreateTokenProgramLookupTableParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The authority of the transaction.
     */
    authority: PublicKey;
    /**
     *  Recently finalized Solana slot.
     */
    recentSlot: number;
    /**
     * Optional Mint addresses to store in the lookup table.
     */
    mints?: PublicKey[];
    /**
     * Optional additional addresses to store in the lookup table.
     */
    remainingAccounts?: PublicKey[];
};
/**
 * Sum up the token amounts of the compressed token accounts
 */
declare const sumUpTokenAmount: (accounts: ParsedTokenAccount[]) => BN;
/**
 * Validate that all the compressed token accounts are owned by the same owner.
 */
declare const validateSameTokenOwner: (accounts: ParsedTokenAccount[]) => void;
/**
 * Parse compressed token accounts to get the mint, current owner and delegate.
 */
declare const parseTokenData: (compressedTokenAccounts: ParsedTokenAccount[]) => {
    mint: PublicKey;
    currentOwner: PublicKey;
    delegate: PublicKey | null;
};
/**
 * Create the output state for a transfer transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param toAddress                     Recipient address
 * @param amount                        Amount of tokens to transfer
 * @returns                             Output token data for the transfer
 *                                      instruction
 */
declare function createTransferOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], toAddress: PublicKey, amount: number | BN): TokenTransferOutputData[];
/**
 * Create the output state for a compress transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param amount                        Amount of tokens to compress
 * @returns                             Output token data for the compress
 *                                      instruction
 */
declare function createDecompressOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], amount: number | BN): TokenTransferOutputData[];
declare class CompressedTokenProgram {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    /**
     * Set a custom programId via PublicKey or base58 encoded string.
     * This method is not required for regular usage.
     *
     * Use this only if you know what you are doing.
     */
    static setProgramId(programId: PublicKey | string): void;
    /** @internal */
    static deriveTokenPoolPda(mint: PublicKey): PublicKey;
    /** @internal */
    static get deriveCpiAuthorityPda(): PublicKey;
    /**
     * Construct createMint instruction for compressed tokens.
     * @returns [createMintAccountInstruction, initializeMintInstruction, createTokenPoolInstruction]
     *
     * Note that `createTokenPoolInstruction` must be executed after `initializeMintInstruction`.
     */
    static createMint(params: CreateMintParams): Promise<TransactionInstruction[]>;
    /**
     * Enable compression for an existing SPL mint, creating an omnibus account.
     * For new mints, use `CompressedTokenProgram.createMint`.
     */
    static createTokenPool(params: RegisterMintParams): Promise<TransactionInstruction>;
    /**
     * Construct mintTo instruction for compressed tokens
     */
    static mintTo(params: MintToParams): Promise<TransactionInstruction>;
    /**
     * Mint tokens from registered SPL mint account to a compressed account
     */
    static approveAndMintTo(params: ApproveAndMintToParams): Promise<TransactionInstruction[]>;
    /**
     * Construct transfer instruction for compressed tokens
     */
    static transfer(params: TransferParams): Promise<TransactionInstruction>;
    /**
     * Create lookup table instructions for the token program's default accounts.
     */
    static createTokenProgramLookupTable(params: CreateTokenProgramLookupTableParams): Promise<{
        instructions: TransactionInstruction[];
        address: PublicKey;
    }>;
    /**
     * Create compress instruction
     * @returns compressInstruction
     */
    static compress(params: CompressParams): Promise<TransactionInstruction>;
    /**
     * Construct decompress instruction
     */
    static decompress(params: DecompressParams): Promise<TransactionInstruction>;
    static mergeTokenAccounts(params: MergeTokenAccountsParams): Promise<TransactionInstruction[]>;
    static compressSplTokenAccount(params: CompressSplTokenAccountParams): Promise<TransactionInstruction>;
    static get_mint_program_id(mint: PublicKey, connection: Connection): Promise<PublicKey | undefined>;
}

/**
 * Mint compressed tokens to a solana address from an external mint authority
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to
 * @param authority      Minting authority
 * @param amount         Amount to mint
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to random public state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function approveAndMintTo(rpc: Rpc, payer: Signer, mint: PublicKey, destination: PublicKey, authority: Signer, amount: number | BN, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Compress SPL tokens
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the compressed token
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens.
 * @param sourceTokenAccount    Source (associated) token account
 * @param toAddress             Destination address of the recipient
 * @param merkleTree            State tree account that the compressed tokens
 *                              should be inserted into. Defaults to a default
 *                              state tree account.
 * @param confirmOptions        Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function compress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN | number[] | BN[], owner: Signer, sourceTokenAccount: PublicKey, toAddress: PublicKey | Array<PublicKey>, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Decompress compressed tokens
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination **uncompressed** (associated) token account
 *                       address.
 * @param merkleTree     State tree account that any change compressed tokens should be
 *                       inserted into. Defaults to a default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function decompress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Create and initialize a new compressed token mint
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting
 * @param decimals        Location of the decimal place
 * @param keypair         Optional keypair, defaulting to a new random one
 * @param confirmOptions  Options for confirming the transaction
 * @param tokenProgramId  Program ID for the token. Defaults to
 *                        TOKEN_PROGRAM_ID. You can pass in a boolean to
 *                        automatically resolve to TOKEN_2022_PROGRAM_ID if
 *                        true, or TOKEN_PROGRAM_ID if false.
 * @param freezeAuthority Account that will control freeze and thaw. Defaults to null.
 *
 * @return Address of the new mint and the transaction signature
 */
declare function createMint(rpc: Rpc, payer: Signer, mintAuthority: PublicKey, decimals: number, keypair?: Keypair, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey | boolean, freezeAuthority?: PublicKey): Promise<{
    mint: PublicKey;
    transactionSignature: TransactionSignature;
}>;

/**
 * Mint compressed tokens to a solana address
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to. Can be an array of
 *                       addresses if the amount is an array of amounts.
 * @param authority      Minting authority
 * @param amount         Amount to mint. Can be an array of amounts if the
 *                       destination is an array of addresses.
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function mintTo(rpc: Rpc, payer: Signer, mint: PublicKey, destination: PublicKey | PublicKey[], authority: Signer, amount: number | BN | number[] | BN[], merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Merge multiple compressed token accounts for a given mint into a single
 * account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction fees
 * @param mint            Public key of the token's mint
 * @param owner           Owner of the token accounts to be merged
 * @param merkleTree      Optional merkle tree for compressed tokens
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Array of transaction signatures
 */
declare function mergeTokenAccounts(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Register an existing mint with the CompressedToken program
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting. Is signer.
 * @param mintAddress     Address of the existing mint
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return transaction signature
 */
declare function createTokenPool(rpc: Rpc, payer: Signer, mint: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Transfer compressed tokens from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       inserted into. Defaults to the default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function transfer(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Create a lookup table for the token program's default accounts
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param authority             Authority of the lookup table
 * @param mints                 Optional array of mint public keys to include in
 *                              the lookup table
 * @param additionalAccounts    Optional array of additional account public keys
 *                              to include in the lookup table
 *
 * @return Transaction signatures and the address of the created lookup table
 */
declare function createTokenProgramLookupTable(rpc: Rpc, payer: Signer, authority: Signer, mints?: PublicKey[], additionalAccounts?: PublicKey[]): Promise<{
    txIds: TransactionSignature[];
    address: PublicKey;
}>;

/**
 * Compress SPL tokens into compressed token format
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the token to compress
 * @param owner                 Owner of the token account
 * @param tokenAccount         Token account to compress
 * @param outputStateTree       State tree to insert the compressed token account into
 * @param remainingAmount      Optional: amount to leave in token account. Default: 0
 * @param confirmOptions       Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function compressSplTokenAccount(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, tokenAccount: PublicKey, outputStateTree: PublicKey, remainingAmount?: BN, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

declare const DelegatedTransferLayout: buffer_layout.Layout<unknown>;
declare const CpiContextLayout: buffer_layout.Layout<unknown>;
declare const CompressedTokenInstructionDataTransferLayout: buffer_layout.Layout<unknown>;
declare const mintToLayout: buffer_layout.Layout<unknown>;
declare const compressSplTokenAccountInstructionDataLayout: buffer_layout.Layout<unknown>;
declare function encodeMintToInstructionData(data: MintToInstructionData): Buffer$1;
declare function decodeMintToInstructionData(buffer: Buffer$1): MintToInstructionData;
declare function encodeCompressSplTokenAccountInstructionData(data: CompressSplTokenAccountInstructionData): Buffer$1;
declare function decodeCompressSplTokenAccountInstructionData(buffer: Buffer$1): CompressSplTokenAccountInstructionData;
declare function encodeTransferInstructionData(data: CompressedTokenInstructionDataTransfer): Buffer$1;
declare function decodeTransferInstructionData(buffer: Buffer$1): CompressedTokenInstructionDataTransfer;
interface BaseAccountsLayoutParams {
    feePayer: PublicKey;
    authority: PublicKey;
    cpiAuthorityPda: PublicKey;
    lightSystemProgram: PublicKey;
    registeredProgramPda: PublicKey;
    noopProgram: PublicKey;
    accountCompressionAuthority: PublicKey;
    accountCompressionProgram: PublicKey;
    selfProgram: PublicKey;
    systemProgram: PublicKey;
}
type createTokenPoolAccountsLayoutParams = {
    feePayer: PublicKey;
    tokenPoolPda: PublicKey;
    systemProgram: PublicKey;
    mint: PublicKey;
    tokenProgram: PublicKey;
    cpiAuthorityPda: PublicKey;
};
type mintToAccountsLayoutParams = BaseAccountsLayoutParams & {
    mint: PublicKey;
    tokenPoolPda: PublicKey;
    tokenProgram: PublicKey;
    merkleTree: PublicKey;
    solPoolPda: PublicKey | null;
};
type transferAccountsLayoutParams = BaseAccountsLayoutParams & {
    tokenPoolPda?: PublicKey;
    compressOrDecompressTokenAccount?: PublicKey;
    tokenProgram?: PublicKey;
};
type approveAccountsLayoutParams = BaseAccountsLayoutParams;
type revokeAccountsLayoutParams = approveAccountsLayoutParams;
type freezeAccountsLayoutParams = BaseAccountsLayoutParams & {
    mint: PublicKey;
};
type thawAccountsLayoutParams = freezeAccountsLayoutParams;
declare const createTokenPoolAccountsLayout: (accounts: createTokenPoolAccountsLayoutParams) => AccountMeta[];
declare const mintToAccountsLayout: (accounts: mintToAccountsLayoutParams) => AccountMeta[];
declare const transferAccountsLayout: (accounts: transferAccountsLayoutParams) => AccountMeta[];

type LightCompressedToken = {
    version: '1.2.0';
    name: 'light_compressed_token';
    instructions: [
        {
            name: 'createTokenPool';
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'addTokenPool';
            docs: [
                'This instruction creates an additional token pool for a given mint.',
                'The maximum number of token pools per mint is 5.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'existingTokenPoolPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'tokenPoolIndex';
                    type: 'u8';
                }
            ];
        },
        {
            name: 'mintTo';
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['programs'];
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'publicKeys';
                    type: {
                        vec: 'publicKey';
                    };
                },
                {
                    name: 'amounts';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'lamports';
                    type: {
                        option: 'u64';
                    };
                }
            ];
        },
        {
            name: 'compressSplTokenAccount';
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'owner';
                    type: 'publicKey';
                },
                {
                    name: 'remainingAmount';
                    type: {
                        option: 'u64';
                    };
                },
                {
                    name: 'cpiContext';
                    type: {
                        option: {
                            defined: 'CompressedCpiContext';
                        };
                    };
                }
            ];
        },
        {
            name: 'transfer';
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'approve';
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'revoke';
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'freeze';
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'thaw';
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'burn';
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'TokenData';
                    };
                }
            ];
        }
    ];
    types: [
        {
            name: 'AccountState';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'Initialized';
                    },
                    {
                        name: 'Frozen';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataTransfer';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegatedTransfer';
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.'
                        ];
                        type: {
                            option: {
                                defined: 'DelegatedTransfer';
                            };
                        };
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData';
                            };
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressAmount';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex';
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'DelegatedTransfer';
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegateChangeAccountIndex';
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.'
                        ];
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'InputTokenDataWithContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'delegateIndex';
                        type: {
                            option: 'u8';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        type: 'u16';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'queueIndex';
                        type: {
                            option: {
                                defined: 'QueueIndex';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'PackedTokenTransferOutputData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'TokenData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'mint';
                        docs: ['The mint associated with this account'];
                        type: 'publicKey';
                    },
                    {
                        name: 'owner';
                        docs: ['The owner of this account.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        docs: ['The amount of tokens this account holds.'];
                        type: 'u64';
                    },
                    {
                        name: 'delegate';
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate'
                        ];
                        type: {
                            option: 'publicKey';
                        };
                    },
                    {
                        name: 'state';
                        docs: ["The account's state"];
                        type: {
                            defined: 'AccountState';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'PublicKeyAmountMissmatch';
            msg: 'public keys and amounts must be of same length';
        },
        {
            code: 6001;
            name: 'ComputeInputSumFailed';
            msg: 'ComputeInputSumFailed';
        },
        {
            code: 6002;
            name: 'ComputeOutputSumFailed';
            msg: 'ComputeOutputSumFailed';
        },
        {
            code: 6003;
            name: 'ComputeCompressSumFailed';
            msg: 'ComputeCompressSumFailed';
        },
        {
            code: 6004;
            name: 'ComputeDecompressSumFailed';
            msg: 'ComputeDecompressSumFailed';
        },
        {
            code: 6005;
            name: 'SumCheckFailed';
            msg: 'SumCheckFailed';
        },
        {
            code: 6006;
            name: 'DecompressRecipientUndefinedForDecompress';
            msg: 'DecompressRecipientUndefinedForDecompress';
        },
        {
            code: 6007;
            name: 'CompressedPdaUndefinedForDecompress';
            msg: 'CompressedPdaUndefinedForDecompress';
        },
        {
            code: 6008;
            name: 'DeCompressAmountUndefinedForDecompress';
            msg: 'DeCompressAmountUndefinedForDecompress';
        },
        {
            code: 6009;
            name: 'CompressedPdaUndefinedForCompress';
            msg: 'CompressedPdaUndefinedForCompress';
        },
        {
            code: 6010;
            name: 'DeCompressAmountUndefinedForCompress';
            msg: 'DeCompressAmountUndefinedForCompress';
        },
        {
            code: 6011;
            name: 'DelegateSignerCheckFailed';
            msg: 'DelegateSignerCheckFailed';
        },
        {
            code: 6012;
            name: 'MintTooLarge';
            msg: 'Minted amount greater than u64::MAX';
        },
        {
            code: 6013;
            name: 'SplTokenSupplyMismatch';
            msg: 'SplTokenSupplyMismatch';
        },
        {
            code: 6014;
            name: 'HeapMemoryCheckFailed';
            msg: 'HeapMemoryCheckFailed';
        },
        {
            code: 6015;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6016;
            name: 'ArithmeticUnderflow';
            msg: 'ArithmeticUnderflow';
        },
        {
            code: 6017;
            name: 'HashToFieldError';
            msg: 'HashToFieldError';
        },
        {
            code: 6018;
            name: 'InvalidAuthorityMint';
            msg: 'Expected the authority to be also a mint authority';
        },
        {
            code: 6019;
            name: 'InvalidFreezeAuthority';
            msg: 'Provided authority is not the freeze authority';
        },
        {
            code: 6020;
            name: 'InvalidDelegateIndex';
        },
        {
            code: 6021;
            name: 'TokenPoolPdaUndefined';
        },
        {
            code: 6022;
            name: 'IsTokenPoolPda';
            msg: 'Compress or decompress recipient is the same account as the token pool pda.';
        },
        {
            code: 6023;
            name: 'InvalidTokenPoolPda';
        },
        {
            code: 6024;
            name: 'NoInputTokenAccountsProvided';
        },
        {
            code: 6025;
            name: 'NoInputsProvided';
        },
        {
            code: 6026;
            name: 'MintHasNoFreezeAuthority';
        },
        {
            code: 6027;
            name: 'MintWithInvalidExtension';
        },
        {
            code: 6028;
            name: 'InsufficientTokenAccountBalance';
            msg: 'The token account balance is less than the remaining amount.';
        },
        {
            code: 6029;
            name: 'InvalidTokenPoolBump';
            msg: 'Max number of token pools reached.';
        },
        {
            code: 6030;
            name: 'FailedToDecompress';
        },
        {
            code: 6031;
            name: 'FailedToBurnSplTokensFromTokenPool';
        },
        {
            code: 6032;
            name: 'NoMatchingBumpFound';
        }
    ];
};
declare const IDL: LightCompressedToken;

declare const ERROR_NO_ACCOUNTS_FOUND = "Could not find accounts to select for transfer.";
/**
 * Selects the minimum number of compressed token accounts required for a transfer, up to a specified maximum.
 *
 * @param {ParsedTokenAccount[]} accounts - Token accounts to choose from.
 * @param {BN} transferAmount - Amount to transfer.
 * @param {number} [maxInputs=4] - Max accounts to select. Default is 4.
 * @returns {[
 *   selectedAccounts: ParsedTokenAccount[],
 *   total: BN,
 *   totalLamports: BN | null,
 *   maxPossibleAmount: BN
 * ]} - Returns:
 *   - selectedAccounts: Accounts chosen for transfer.
 *   - total: Total amount from selected accounts.
 *   - totalLamports: Total lamports from selected accounts.
 *   - maxPossibleAmount: Max transferable amount given maxInputs.
 *
 * @example
 * const accounts = [
 *   { parsed: { amount: new BN(100) }, compressedAccount: { lamports: new BN(10) } },
 *   { parsed: { amount: new BN(50) }, compressedAccount: { lamports: new BN(5) } },
 *   { parsed: { amount: new BN(25) }, compressedAccount: { lamports: new BN(2) } },
 * ];
 * const transferAmount = new BN(75);
 * const maxInputs = 2;
 *
 * const [selectedAccounts, total, totalLamports, maxPossibleAmount] =
 *   selectMinCompressedTokenAccountsForTransfer(accounts, transferAmount, maxInputs);
 *
 * console.log(selectedAccounts.length); // 2
 * console.log(total.toString()); // '150'
 * console.log(totalLamports!.toString()); // '15'
 */
declare function selectMinCompressedTokenAccountsForTransfer(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,
 * returns partial amounts if insufficient accounts are found instead of
 * throwing an error.
 */
declare function selectMinCompressedTokenAccountsForTransferOrPartial(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Selects compressed token accounts for a transfer, ensuring one extra account
 * if possible, up to maxInputs.
 *
 * 1. Sorts accounts by amount (desc)
 * 2. Selects accounts until transfer amount is met or maxInputs is reached,
 *    attempting to add one extra account if possible.
 *
 * @param {ParsedTokenAccount[]} accounts - The list of token accounts to select from.
 * @param {BN} transferAmount - The token amount to be transferred.
 * @param {number} [maxInputs=4] - The maximum number of accounts to select. Default: 4.
 * @returns {[
 *   selectedAccounts: ParsedTokenAccount[],
 *   total: BN,
 *   totalLamports: BN | null,
 *   maxPossibleAmount: BN
 * ]} - An array containing:
 *   - selectedAccounts: The accounts selected for the transfer.
 *   - total: The total amount accumulated from the selected accounts.
 *   - totalLamports: The total lamports accumulated from the selected accounts.
 *   - maxPossibleAmount: The maximum possible amount that can be transferred considering maxInputs.
 *
 * @example
 * const accounts = [
 *   { parsed: { amount: new BN(100) }, compressedAccount: { lamports: new BN(10) } },
 *   { parsed: { amount: new BN(50) }, compressedAccount: { lamports: new BN(5) } },
 *   { parsed: { amount: new BN(25) }, compressedAccount: { lamports: new BN(2) } },
 * ];
 * const transferAmount = new BN(75);
 * const maxInputs = 2;
 *
 * const [selectedAccounts, total, totalLamports, maxPossibleAmount] =
 *   selectSmartCompressedTokenAccountsForTransfer(accounts, transferAmount, maxInputs);
 *
 * console.log(selectedAccounts.length); // 2
 * console.log(total.toString()); // '150'
 * console.log(totalLamports!.toString()); // '15'
 * console.log(maxPossibleAmount.toString()); // '150'
 */
declare function selectSmartCompressedTokenAccountsForTransfer(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];
/**
 * Executes {@link selectMinCompressedTokenAccountsForTransfer} strategy,
 * returns partial amounts if insufficient accounts are found instead of
 * throwing an error.
 */
declare function selectSmartCompressedTokenAccountsForTransferOrPartial(accounts: ParsedTokenAccount[], transferAmount: BN, maxInputs?: number): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null,
    maxPossibleAmount: BN
];

export { type ApproveAndMintToParams, COMPRESS_SPL_TOKEN_ACCOUNT_DISCRIMINATOR, CPI_AUTHORITY_SEED, CREATE_TOKEN_POOL_DISCRIMINATOR, type CompressParams, type CompressSplTokenAccountInstructionData, type CompressSplTokenAccountParams, type CompressedCpiContext, type CompressedTokenInstructionDataTransfer, CompressedTokenInstructionDataTransferLayout, CompressedTokenProgram, CpiContextLayout, type CreateMintParams, type CreateTokenProgramLookupTableParams, type DecompressParams, type DelegatedTransfer, DelegatedTransferLayout, ERROR_NO_ACCOUNTS_FOUND, IDL, type InputTokenDataWithContext, type LightCompressedToken, MINT_TO_DISCRIMINATOR, type MergeTokenAccountsParams, type MintToInstructionData, type MintToParams, POOL_SEED, type PackCompressedTokenAccountsParams, type PackedTokenTransferOutputData, type RegisterMintParams, SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE, TRANSFER_DISCRIMINATOR, type TokenData, type TokenTransferOutputData, type TransferParams, type approveAccountsLayoutParams, approveAndMintTo, compress, compressSplTokenAccount, compressSplTokenAccountInstructionDataLayout, createDecompressOutputState, createMint, createTokenPool, createTokenPoolAccountsLayout, type createTokenPoolAccountsLayoutParams, createTokenProgramLookupTable, createTransferOutputState, decodeCompressSplTokenAccountInstructionData, decodeMintToInstructionData, decodeTransferInstructionData, decompress, encodeCompressSplTokenAccountInstructionData, encodeMintToInstructionData, encodeTransferInstructionData, type freezeAccountsLayoutParams, mergeTokenAccounts, mintTo, mintToAccountsLayout, type mintToAccountsLayoutParams, mintToLayout, packCompressedTokenAccounts, parseTokenData, type revokeAccountsLayoutParams, selectMinCompressedTokenAccountsForTransfer, selectMinCompressedTokenAccountsForTransferOrPartial, selectSmartCompressedTokenAccountsForTransfer, selectSmartCompressedTokenAccountsForTransferOrPartial, sumUpTokenAmount, type thawAccountsLayoutParams, transfer, transferAccountsLayout, type transferAccountsLayoutParams, validateSameTokenOwner };
